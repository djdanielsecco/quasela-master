/**
* @module vue-mdc-adapterdrawer 0.14.0
* @exports VueMDCDrawer
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.34.1"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCDrawer = factory());
}(this, (function () { 'use strict';

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.14.0',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var get = function get(object, property, receiver) {
    if (object === null) object = Function.prototype;
    var desc = Object.getOwnPropertyDescriptor(object, property);

    if (desc === undefined) {
      var parent = Object.getPrototypeOf(object);

      if (parent === null) {
        return undefined;
      } else {
        return get(parent, property, receiver);
      }
    } else if ("value" in desc) {
      return desc.value;
    } else {
      var getter = desc.get;

      if (getter === undefined) {
        return undefined;
      }

      return getter.call(receiver);
    }
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  var CustomLink = {
    name: 'custom-link',
    functional: true,
    props: {
      tag: { type: String, default: 'a' },
      link: Object
    },
    render: function render(h, context) {
      var element = void 0;
      var data = _extends({}, context.data);

      if (context.props.link && context.parent.$router) {
        // router-link case
        element = context.parent.$root.$options.components['router-link'];
        data.props = _extends({ tag: context.props.tag }, context.props.link);
        if (data.on.click) {
          data.nativeOn = { click: data.on.click };
        }
      } else {
        // element fallback
        element = context.props.tag;
      }

      return h(element, data, context.children);
    }
  };

  var CustomLinkMixin = {
    props: {
      to: [String, Object],
      exact: Boolean,
      append: Boolean,
      replace: Boolean,
      activeClass: String,
      exactActiveClass: String
    },
    computed: {
      link: function link() {
        return this.to && {
          to: this.to,
          exact: this.exact,
          append: this.append,
          replace: this.replace,
          activeClass: this.activeClass,
          exactActiveClass: this.exactActiveClass
        };
      }
    },
    components: {
      CustomLink: CustomLink
    }
  };

  /* global CustomEvent */

  var DispatchEventMixin = {
    props: {
      event: String,
      'event-target': Object,
      'event-args': Array
    },
    methods: {
      dispatchEvent: function dispatchEvent(evt) {
        evt && this.$emit(evt.type, evt);
        if (this.event) {
          var target = this.eventTarget || this.$root;
          var args = this.eventArgs || [];
          target.$emit.apply(target, [this.event].concat(toConsumableArray(args)));
        }
      }
    },
    computed: {
      listeners: function listeners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            return _this.dispatchEvent(e);
          }
        });
      }
    }
  };

  var mdcPermanentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-permanent-drawer mdc-drawer--permanent mdc-typography" }, [_c('nav', { staticClass: "mdc-drawer__content" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-permanent-drawer',
    props: {
      'toolbar-spacer': Boolean
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var FOCUSABLE_ELEMENTS = 'a[href], area[href], input:not([disabled]), select:not([disabled]), textarea:not([disabled]), ' + 'button:not([disabled]), iframe, object, embed, [tabindex], [contenteditable]';

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template F
   */

  var MDCComponent = function () {
    createClass(MDCComponent, null, [{
      key: 'attachTo',

      /**
       * @param {!Element} root
       * @return {!MDCComponent}
       */
      value: function attachTo(root) {
        // Subclasses which extend MDCBase should provide an attachTo() method that takes a root element and
        // returns an instantiated component with its root set to that element. Also note that in the cases of
        // subclasses, an explicit foundation class will not have to be passed in; it will simply be initialized
        // from getDefaultFoundation().
        return new MDCComponent(root, new MDCFoundation());
      }

      /**
       * @param {!Element} root
       * @param {F=} foundation
       * @param {...?} args
       */

    }]);

    function MDCComponent(root) {
      var foundation = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : undefined;
      classCallCheck(this, MDCComponent);

      /** @protected {!Element} */
      this.root_ = root;

      for (var _len = arguments.length, args = Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        args[_key - 2] = arguments[_key];
      }

      this.initialize.apply(this, args);
      // Note that we initialize foundation here and not within the constructor's default param so that
      // this.root_ is defined and can be used within the foundation class.
      /** @protected {!F} */
      this.foundation_ = foundation === undefined ? this.getDefaultFoundation() : foundation;
      this.foundation_.init();
      this.initialSyncWithDOM();
    }

    createClass(MDCComponent, [{
      key: 'initialize',
      value: function initialize() /* ...args */{}
      // Subclasses can override this to do any additional setup work that would be considered part of a
      // "constructor". Essentially, it is a hook into the parent constructor before the foundation is
      // initialized. Any additional arguments besides root and foundation will be passed in here.


      /**
       * @return {!F} foundation
       */

    }, {
      key: 'getDefaultFoundation',
      value: function getDefaultFoundation() {
        // Subclasses must override this method to return a properly configured foundation class for the
        // component.
        throw new Error('Subclasses must override getDefaultFoundation to return a properly configured ' + 'foundation class');
      }
    }, {
      key: 'initialSyncWithDOM',
      value: function initialSyncWithDOM() {
        // Subclasses should override this method if they need to perform work to synchronize with a host DOM
        // object. An example of this would be a form control wrapper that needs to synchronize its internal state
        // to some property or attribute of the host DOM. Please note: this is *not* the place to perform DOM
        // reads/writes that would cause layout / paint, as this is called synchronously from within the constructor.
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        // Subclasses may implement this method to release any resources / deregister any listeners they have
        // attached. An example of this might be deregistering a resize event from the window object.
        this.foundation_.destroy();
      }

      /**
       * Wrapper method to add an event listener to the component's root element. This is most useful when
       * listening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'listen',
      value: function listen(evtType, handler) {
        this.root_.addEventListener(evtType, handler);
      }

      /**
       * Wrapper method to remove an event listener to the component's root element. This is most useful when
       * unlistening for custom events.
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: 'unlisten',
      value: function unlisten(evtType, handler) {
        this.root_.removeEventListener(evtType, handler);
      }

      /**
       * Fires a cross-browser-compatible custom event from the component root of the given type,
       * with the given data.
       * @param {string} evtType
       * @param {!Object} evtData
       * @param {boolean=} shouldBubble
       */

    }, {
      key: 'emit',
      value: function emit(evtType, evtData) {
        var shouldBubble = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        var evt = void 0;
        if (typeof CustomEvent === 'function') {
          evt = new CustomEvent(evtType, {
            detail: evtData,
            bubbles: shouldBubble
          });
        } else {
          evt = document.createEvent('CustomEvent');
          evt.initCustomEvent(evtType, shouldBubble, false, evtData);
        }

        this.root_.dispatchEvent(evt);
      }
    }]);
    return MDCComponent;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCSlidableDrawerFoundation = function (_MDCFoundation) {
    inherits(MDCSlidableDrawerFoundation, _MDCFoundation);
    createClass(MDCSlidableDrawerFoundation, null, [{
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          hasClass: function hasClass() /* className: string */{},
          hasNecessaryDom: function hasNecessaryDom() {
            return (/* boolean */false
            );
          },
          registerInteractionHandler: function registerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evt: string, handler: EventListener */{},
          registerDrawerInteractionHandler: function registerDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler() /* evt: string, handler: EventListener */{},
          registerTransitionEndHandler: function registerTransitionEndHandler() /* handler: EventListener */{},
          deregisterTransitionEndHandler: function deregisterTransitionEndHandler() /* handler: EventListener */{},
          registerDocumentKeydownHandler: function registerDocumentKeydownHandler() /* handler: EventListener */{},
          deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler() /* handler: EventListener */{},
          setTranslateX: function setTranslateX() /* value: number | null */{},
          getFocusableElements: function getFocusableElements() /* NodeList */{},
          saveElementTabState: function saveElementTabState() /* el: Element */{},
          restoreElementTabState: function restoreElementTabState() /* el: Element */{},
          makeElementUntabbable: function makeElementUntabbable() /* el: Element */{},
          notifyOpen: function notifyOpen() {},
          notifyClose: function notifyClose() {},
          isRtl: function isRtl() {
            return (/* boolean */false
            );
          },
          getDrawerWidth: function getDrawerWidth() {
            return (/* number */0
            );
          }
        };
      }
    }]);

    function MDCSlidableDrawerFoundation(adapter, rootCssClass, animatingCssClass, openCssClass) {
      classCallCheck(this, MDCSlidableDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCSlidableDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCSlidableDrawerFoundation)).call(this, _extends(MDCSlidableDrawerFoundation.defaultAdapter, adapter)));

      _this.rootCssClass_ = rootCssClass;
      _this.animatingCssClass_ = animatingCssClass;
      _this.openCssClass_ = openCssClass;

      _this.transitionEndHandler_ = function (evt) {
        return _this.handleTransitionEnd_(evt);
      };

      _this.inert_ = false;

      _this.componentTouchStartHandler_ = function (evt) {
        return _this.handleTouchStart_(evt);
      };
      _this.componentTouchMoveHandler_ = function (evt) {
        return _this.handleTouchMove_(evt);
      };
      _this.componentTouchEndHandler_ = function (evt) {
        return _this.handleTouchEnd_(evt);
      };
      _this.documentKeydownHandler_ = function (evt) {
        if (evt.key && evt.key === 'Escape' || evt.keyCode === 27) {
          _this.close();
        }
      };
      return _this;
    }

    createClass(MDCSlidableDrawerFoundation, [{
      key: 'init',
      value: function init() {
        var ROOT = this.rootCssClass_;
        var OPEN = this.openCssClass_;

        if (!this.adapter_.hasClass(ROOT)) {
          throw new Error(ROOT + ' class required in root element.');
        }

        if (!this.adapter_.hasNecessaryDom()) {
          throw new Error('Required DOM nodes missing in ' + ROOT + ' component.');
        }

        if (this.adapter_.hasClass(OPEN)) {
          this.isOpen_ = true;
        } else {
          this.detabinate_();
          this.isOpen_ = false;
        }

        this.adapter_.registerDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.registerInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.registerInteractionHandler('touchend', this.componentTouchEndHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        this.adapter_.deregisterDrawerInteractionHandler('touchstart', this.componentTouchStartHandler_);
        this.adapter_.deregisterInteractionHandler('touchmove', this.componentTouchMoveHandler_);
        this.adapter_.deregisterInteractionHandler('touchend', this.componentTouchEndHandler_);
        // Deregister the document keydown handler just in case the component is destroyed while the menu is open.
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
      }
    }, {
      key: 'open',
      value: function open() {
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.registerDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.addClass(this.openCssClass_);
        this.retabinate_();
        // Debounce multiple calls
        if (!this.isOpen_) {
          this.adapter_.notifyOpen();
        }
        this.isOpen_ = true;
      }
    }, {
      key: 'close',
      value: function close() {
        this.adapter_.deregisterDocumentKeydownHandler(this.documentKeydownHandler_);
        this.adapter_.registerTransitionEndHandler(this.transitionEndHandler_);
        this.adapter_.addClass(this.animatingCssClass_);
        this.adapter_.removeClass(this.openCssClass_);
        this.detabinate_();
        // Debounce multiple calls
        if (this.isOpen_) {
          this.adapter_.notifyClose();
        }
        this.isOpen_ = false;
      }
    }, {
      key: 'isOpen',
      value: function isOpen() {
        return this.isOpen_;
      }

      /**
       *  Render all children of the drawer inert when it's closed.
       */

    }, {
      key: 'detabinate_',
      value: function detabinate_() {
        if (this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.saveElementTabState(elements[i]);
            this.adapter_.makeElementUntabbable(elements[i]);
          }
        }

        this.inert_ = true;
      }

      /**
       *  Make all children of the drawer tabbable again when it's open.
       */

    }, {
      key: 'retabinate_',
      value: function retabinate_() {
        if (!this.inert_) {
          return;
        }

        var elements = this.adapter_.getFocusableElements();
        if (elements) {
          for (var i = 0; i < elements.length; i++) {
            this.adapter_.restoreElementTabState(elements[i]);
          }
        }

        this.inert_ = false;
      }
    }, {
      key: 'handleTouchStart_',
      value: function handleTouchStart_(evt) {
        if (!this.adapter_.hasClass(this.openCssClass_)) {
          return;
        }
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.direction_ = this.adapter_.isRtl() ? -1 : 1;
        this.drawerWidth_ = this.adapter_.getDrawerWidth();
        this.startX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
        this.currentX_ = this.startX_;

        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
      }
    }, {
      key: 'handleTouchMove_',
      value: function handleTouchMove_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.currentX_ = evt.touches ? evt.touches[0].pageX : evt.pageX;
      }
    }, {
      key: 'handleTouchEnd_',
      value: function handleTouchEnd_(evt) {
        if (evt.pointerType && evt.pointerType !== 'touch') {
          return;
        }

        this.prepareForTouchEnd_();

        // Did the user close the drawer by more than 50%?
        if (Math.abs(this.newPosition_ / this.drawerWidth_) >= 0.5) {
          this.close();
        } else {
          // Triggering an open here means we'll get a nice animation back to the fully open state.
          this.open();
        }
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        cancelAnimationFrame(this.updateRaf_);
        this.adapter_.setTranslateX(null);
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        this.updateRaf_ = requestAnimationFrame(this.updateDrawer_.bind(this));
        this.adapter_.setTranslateX(this.newPosition_);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_() {
        // Classes extending MDCSlidableDrawerFoundation should implement this method to return true or false
        // if the event target is the root event target currently transitioning.
        return false;
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        if (this.isRootTransitioningEventTarget_(evt.target)) {
          this.adapter_.removeClass(this.animatingCssClass_);
          this.adapter_.deregisterTransitionEndHandler(this.transitionEndHandler_);
        }
      }
    }, {
      key: 'newPosition_',
      get: function get$$1() {
        var newPos = null;

        if (this.direction_ === 1) {
          newPos = Math.min(0, this.currentX_ - this.startX_);
        } else {
          newPos = Math.max(0, this.currentX_ - this.startX_);
        }

        return newPos;
      }
    }]);
    return MDCSlidableDrawerFoundation;
  }(MDCFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses = {
    ROOT: 'mdc-drawer--persistent',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating'
  };

  var strings = {
    DRAWER_SELECTOR: '.mdc-drawer--persistent .mdc-drawer__drawer',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCPersistentDrawer:open',
    CLOSE_EVENT: 'MDCPersistentDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCPersistentDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCPersistentDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCPersistentDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          isDrawer: function isDrawer() {
            return false;
          }
        });
      }
    }]);

    function MDCPersistentDrawerFoundation(adapter) {
      classCallCheck(this, MDCPersistentDrawerFoundation);
      return possibleConstructorReturn(this, (MDCPersistentDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCPersistentDrawerFoundation)).call(this, _extends(MDCPersistentDrawerFoundation.defaultAdapter, adapter), MDCPersistentDrawerFoundation.cssClasses.ROOT, MDCPersistentDrawerFoundation.cssClasses.ANIMATING, MDCPersistentDrawerFoundation.cssClasses.OPEN));
    }

    createClass(MDCPersistentDrawerFoundation, [{
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }]);
    return MDCPersistentDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var TAB_DATA = 'data-mdc-tabindex';
  var TAB_DATA_HANDLED = 'data-mdc-tabindex-handled';

  var storedTransformPropertyName_ = void 0;
  var supportsPassive_ = void 0;

  // Remap touch events to pointer events, if the browser doesn't support touch events.
  function remapEvent(eventName) {
    var globalObj = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : window;

    if (!('ontouchstart' in globalObj.document)) {
      switch (eventName) {
        case 'touchstart':
          return 'pointerdown';
        case 'touchmove':
          return 'pointermove';
        case 'touchend':
          return 'pointerup';
        default:
          return eventName;
      }
    }

    return eventName;
  }

  // Choose the correct transform property to use on the current browser.
  function getTransformPropertyName() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (storedTransformPropertyName_ === undefined || forceRefresh) {
      var el = globalObj.document.createElement('div');
      var transformPropertyName = 'transform' in el.style ? 'transform' : '-webkit-transform';
      storedTransformPropertyName_ = transformPropertyName;
    }

    return storedTransformPropertyName_;
  }

  // Determine whether the current browser supports CSS properties.
  function supportsCssCustomProperties() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;

    if ('CSS' in globalObj) {
      return globalObj.CSS.supports('(--color: red)');
    }
    return false;
  }

  // Determine whether the current browser supports passive event listeners, and if so, use them.
  function applyPassive() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_ === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_ = isSupported;
    }

    return supportsPassive_ ? { passive: true } : false;
  }

  // Save the tab state for an element.
  function saveElementTabState(el) {
    if (el.hasAttribute('tabindex')) {
      el.setAttribute(TAB_DATA, el.getAttribute('tabindex'));
    }
    el.setAttribute(TAB_DATA_HANDLED, true);
  }

  // Restore the tab state for an element, if it was saved.
  function restoreElementTabState(el) {
    // Only modify elements we've already handled, in case anything was dynamically added since we saved state.
    if (el.hasAttribute(TAB_DATA_HANDLED)) {
      if (el.hasAttribute(TAB_DATA)) {
        el.setAttribute('tabindex', el.getAttribute(TAB_DATA));
        el.removeAttribute(TAB_DATA);
      } else {
        el.removeAttribute('tabindex');
      }
      el.removeAttribute(TAB_DATA_HANDLED);
    }
  }

  var mdcPersistentDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-persistent-drawer mdc-drawer--persistent mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-persistent-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'toolbar-spacer': Boolean,
      'open': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: function open() {
        this._refresh();
      }
    },
    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      var FOCUSABLE_ELEMENTS = MDCPersistentDrawerFoundation.strings.FOCUSABLE_ELEMENTS;


      this.foundation = new MDCPersistentDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    }
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$1 = {
    ROOT: 'mdc-drawer--temporary',
    OPEN: 'mdc-drawer--open',
    ANIMATING: 'mdc-drawer--animating',
    SCROLL_LOCK: 'mdc-drawer-scroll-lock'
  };

  var strings$1 = {
    DRAWER_SELECTOR: '.mdc-drawer--temporary .mdc-drawer__drawer',
    OPACITY_VAR_NAME: '--mdc-temporary-drawer-opacity',
    FOCUSABLE_ELEMENTS: FOCUSABLE_ELEMENTS,
    OPEN_EVENT: 'MDCTemporaryDrawer:open',
    CLOSE_EVENT: 'MDCTemporaryDrawer:close'
  };

  /**
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var MDCTemporaryDrawerFoundation = function (_MDCSlidableDrawerFou) {
    inherits(MDCTemporaryDrawerFoundation, _MDCSlidableDrawerFou);
    createClass(MDCTemporaryDrawerFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$1;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$1;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return _extends(MDCSlidableDrawerFoundation.defaultAdapter, {
          addBodyClass: function addBodyClass() /* className: string */{},
          removeBodyClass: function removeBodyClass() /* className: string */{},
          isDrawer: function isDrawer() {
            return false;
          },
          updateCssVariable: function updateCssVariable() /* value: string */{},
          eventTargetHasClass: function eventTargetHasClass() {
            return (/* target: EventTarget, className: string */ /* boolean */false
            );
          }
        });
      }
    }]);

    function MDCTemporaryDrawerFoundation(adapter) {
      classCallCheck(this, MDCTemporaryDrawerFoundation);

      var _this = possibleConstructorReturn(this, (MDCTemporaryDrawerFoundation.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation)).call(this, _extends(MDCTemporaryDrawerFoundation.defaultAdapter, adapter), MDCTemporaryDrawerFoundation.cssClasses.ROOT, MDCTemporaryDrawerFoundation.cssClasses.ANIMATING, MDCTemporaryDrawerFoundation.cssClasses.OPEN));

      _this.componentClickHandler_ = function (evt) {
        if (_this.adapter_.eventTargetHasClass(evt.target, cssClasses$1.ROOT)) {
          _this.close(true);
        }
      };
      return _this;
    }

    createClass(MDCTemporaryDrawerFoundation, [{
      key: 'init',
      value: function init() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'init', this).call(this);

        // Make browser aware of custom property being used in this element.
        // Workaround for certain types of hard-to-reproduce heisenbugs.
        this.adapter_.updateCssVariable(0);
        this.adapter_.registerInteractionHandler('click', this.componentClickHandler_);
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'destroy', this).call(this);

        this.adapter_.deregisterInteractionHandler('click', this.componentClickHandler_);
        this.enableScroll_();
      }
    }, {
      key: 'open',
      value: function open() {
        this.disableScroll_();
        // Make sure custom property values are cleared before starting.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'open', this).call(this);
      }
    }, {
      key: 'close',
      value: function close() {
        // Make sure custom property values are cleared before making any changes.
        this.adapter_.updateCssVariable('');

        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'close', this).call(this);
      }
    }, {
      key: 'prepareForTouchEnd_',
      value: function prepareForTouchEnd_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'prepareForTouchEnd_', this).call(this);

        this.adapter_.updateCssVariable('');
      }
    }, {
      key: 'updateDrawer_',
      value: function updateDrawer_() {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'updateDrawer_', this).call(this);

        var newOpacity = Math.max(0, 1 + this.direction_ * (this.newPosition_ / this.drawerWidth_));
        this.adapter_.updateCssVariable(newOpacity);
      }
    }, {
      key: 'isRootTransitioningEventTarget_',
      value: function isRootTransitioningEventTarget_(el) {
        return this.adapter_.isDrawer(el);
      }
    }, {
      key: 'handleTransitionEnd_',
      value: function handleTransitionEnd_(evt) {
        get(MDCTemporaryDrawerFoundation.prototype.__proto__ || Object.getPrototypeOf(MDCTemporaryDrawerFoundation.prototype), 'handleTransitionEnd_', this).call(this, evt);
        if (!this.isOpen_) {
          this.enableScroll_();
        }
      }
    }, {
      key: 'disableScroll_',
      value: function disableScroll_() {
        this.adapter_.addBodyClass(cssClasses$1.SCROLL_LOCK);
      }
    }, {
      key: 'enableScroll_',
      value: function enableScroll_() {
        this.adapter_.removeBodyClass(cssClasses$1.SCROLL_LOCK);
      }
    }]);
    return MDCTemporaryDrawerFoundation;
  }(MDCSlidableDrawerFoundation);

  var mdcTemporaryDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('aside', { staticClass: "mdc-temporary-drawer mdc-drawer--temporary mdc-typography", class: _vm.classes }, [_c('nav', { ref: "drawer", staticClass: "mdc-drawer__drawer" }, [_vm.toolbarSpacer ? _c('div', { staticClass: "mdc-drawer__toolbar-spacer" }) : _vm._e(), _vm._v(" "), _vm._t("default")], 2)]);
    }, staticRenderFns: [],
    name: 'mdc-temporary-drawer',
    model: {
      prop: 'open',
      event: 'change'
    },
    props: {
      'open': Boolean,
      'toolbar-spacer': Boolean
    },
    data: function data() {
      return {
        classes: {}
      };
    },

    watch: {
      open: function open() {
        this._refresh();
      }
    },
    methods: {
      _refresh: function _refresh() {
        if (this.open) {
          this.foundation && this.foundation.open();
        } else {
          this.foundation && this.foundation.close();
        }
      }
    },
    mounted: function mounted() {
      var _this = this;

      var _MDCTemporaryDrawerFo = MDCTemporaryDrawerFoundation.strings,
          FOCUSABLE_ELEMENTS = _MDCTemporaryDrawerFo.FOCUSABLE_ELEMENTS,
          OPACITY_VAR_NAME = _MDCTemporaryDrawerFo.OPACITY_VAR_NAME;


      this.foundation = new MDCTemporaryDrawerFoundation({
        addClass: function addClass(className) {
          _this.$set(_this.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this.$delete(_this.classes, className);
        },
        hasClass: function hasClass(className) {
          return _this.$el.classList.contains(className);
        },
        addBodyClass: function addBodyClass(className) {
          return document.body.classList.add(className);
        },
        removeBodyClass: function removeBodyClass(className) {
          return document.body.classList.remove(className);
        },
        eventTargetHasClass: function eventTargetHasClass(target, className) {
          return target.classList.contains(className);
        },
        hasNecessaryDom: function hasNecessaryDom() {
          return !!_this.$refs.drawer;
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          _this.$el.addEventListener(remapEvent(evt), handler, applyPassive());
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          _this.$el.removeEventListener(remapEvent(evt), handler, applyPassive());
        },
        registerDrawerInteractionHandler: function registerDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.addEventListener(remapEvent(evt), handler);
        },
        deregisterDrawerInteractionHandler: function deregisterDrawerInteractionHandler(evt, handler) {
          _this.$refs.drawer.removeEventListener(remapEvent(evt), handler);
        },
        registerTransitionEndHandler: function registerTransitionEndHandler(handler) {
          _this.$refs.drawer.addEventListener('transitionend', handler);
        },
        deregisterTransitionEndHandler: function deregisterTransitionEndHandler(handler) {
          _this.$refs.drawer.removeEventListener('transitionend', handler);
        },
        registerDocumentKeydownHandler: function registerDocumentKeydownHandler(handler) {
          document.addEventListener('keydown', handler);
        },
        deregisterDocumentKeydownHandler: function deregisterDocumentKeydownHandler(handler) {
          document.removeEventListener('keydown', handler);
        },
        getDrawerWidth: function getDrawerWidth() {
          return _this.$refs.drawer.offsetWidth;
        },
        setTranslateX: function setTranslateX(value) {
          _this.$refs.drawer.style.setProperty(getTransformPropertyName(), value === null ? null : 'translateX(' + value + 'px)');
        },
        updateCssVariable: function updateCssVariable(value) {
          if (supportsCssCustomProperties()) {
            _this.$el.style.setProperty(OPACITY_VAR_NAME, value);
          }
        },
        getFocusableElements: function getFocusableElements() {
          return _this.$refs.drawer.querySelectorAll(FOCUSABLE_ELEMENTS);
        },
        saveElementTabState: function saveElementTabState$$1(el) {
          saveElementTabState(el);
        },
        restoreElementTabState: function restoreElementTabState$$1(el) {
          restoreElementTabState(el);
        },
        makeElementUntabbable: function makeElementUntabbable(el) {
          el.setAttribute('tabindex', -1);
        },
        notifyOpen: function notifyOpen() {
          _this.$emit('change', true);
          _this.$emit('open');
        },
        notifyClose: function notifyClose() {
          _this.$emit('change', false);
          _this.$emit('close');
        },
        isRtl: function isRtl() {
          /* global getComputedStyle */
          return getComputedStyle(_this.$el).getPropertyValue('direction') === 'rtl';
        },
        isDrawer: function isDrawer(el) {
          return el === _this.$refs.drawer;
        }
      });
      this.foundation && this.foundation.init();
      this._refresh();
    },
    beforeDestroy: function beforeDestroy() {
      this.foundation && this.foundation.destroy();
      this.foundation = null;
    }
  };

  var bus_ = void 0;

  var eventBus = {
    install: function install(vue) {
      bus_ = new vue();
    },
    $emit: function $emit(event) {
      var _bus_;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      bus_ && (_bus_ = bus_).$emit.apply(_bus_, [event].concat(toConsumableArray(args)));
    },
    $on: function $on(event, callback) {
      bus_ && bus_.$on(event, callback);
    },
    $once: function $once(event, callback) {
      bus_ && bus_.$once(event, callback);
    },
    $off: function $off(event, callback) {
      bus_ && bus_.$off(event, callback);
    }
  };

  var media = new (function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, [{
      key: 'small',
      get: function get$$1() {
        return this._small || (this._small = window.matchMedia('(max-width: 839px)'));
      }
    }, {
      key: 'large',
      get: function get$$1() {
        return this._large || (this._large = window.matchMedia('(min-width: 1200px)'));
      }
    }]);
    return _class;
  }())();

  var mdcDrawer = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c(_vm.type, { ref: "drawer", tag: "component", staticClass: "mdc-drawer", attrs: { "toolbar-spacer": _vm.toolbarSpacer }, on: { "change": function change($event) {
            _vm.busemit('mdc:layout');
          }, "open": function open($event) {
            _vm.$emit('open');
          }, "close": function close($event) {
            _vm.$emit('close');
          } }, model: { value: _vm.open_, callback: function callback($$v) {
            _vm.open_ = $$v;
          }, expression: "open_" } }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer',
    props: {
      permanent: Boolean,
      persistent: Boolean,
      temporary: Boolean,
      drawerType: {
        type: String,
        validator: function validator(val) {
          return val in ['temporary', 'persistent', 'permanent'];
        }
      },
      toolbarSpacer: Boolean,
      toggleOn: String,
      toggleOnSource: { type: Object, required: false },
      openOn: String,
      openOnSource: { type: Object, required: false },
      closeOn: String,
      closeOnSource: { type: Object, required: false }
    },
    provide: function provide() {
      return { mdcDrawer: this };
    },
    data: function data() {
      return {
        small: false,
        large: false,
        open_: false
      };
    },

    components: {
      'mdc-permanent-drawer': mdcPermanentDrawer,
      'mdc-persistent-drawer': mdcPersistentDrawer,
      'mdc-temporary-drawer': mdcTemporaryDrawer
    },
    computed: {
      type: function type() {
        if (this.permanent) {
          return 'mdc-permanent-drawer';
        } else if (this.persistent) {
          return 'mdc-persistent-drawer';
        } else if (this.temporary) {
          return 'mdc-temporary-drawer';
        } else {
          switch (this.drawerType) {
            case 'permanent':
              return 'mdc-permanent-drawer';
            case 'persistent':
              return 'mdc-persistent-drawer';
            case 'temporary':
              return 'mdc-temporary-drawer';
            default:
              return this.small ? 'mdc-temporary-drawer' : 'mdc-persistent-drawer';
          }
        }
      },
      isPermanent: function isPermanent() {
        return this.permanent || this.type === 'mdc-permanent-drawer';
      },
      isPersistent: function isPersistent() {
        return this.persistent || this.type === 'mdc-persistent-drawer';
      },
      isTemporary: function isTemporary() {
        return this.temporary || this.type === 'mdc-temporary-drawer';
      },
      isResponsive: function isResponsive() {
        return !(this.permanent || this.persistent || this.temporary || this.drawerType);
      }
    },
    methods: {
      busemit: function busemit(event) {
        eventBus.$emit(event);
      },
      open: function open() {
        this.open_ = true;
      },
      close: function close() {
        this.isPermanent || (this.open_ = false);
      },
      toggle: function toggle() {
        this.isPermanent || (this.isOpen() ? this.close() : this.open());
      },
      isOpen: function isOpen() {
        return this.isPermanent || this.open_;
      },
      refreshMedia: function refreshMedia() {
        this.small = media.small.matches;
        this.large = media.large.matches;
        if (this.isResponsive) {
          if (this.large) {
            this.open();
          } else {
            this.close();
          }
        }
      }
    },
    created: function created() {
      if (window && window.matchMedia) {
        this.small = media.small.matches;
        this.large = media.large.matches;
      }
    },
    mounted: function mounted() {
      var _this = this;

      if (this.toggleOn) {
        this.toggleOnEventSource = this.toggleOnSource || this.$root;
        this.toggleOnEventSource.$on(this.toggleOn, this.toggle);
      }
      if (this.openOn) {
        this.openOnEventSource = this.openOnSource || this.$root;
        this.openOnEventSource.$on(this.openOn, this.open);
      }
      if (this.closeOn) {
        this.closeOnEventSource = this.closeOnSource || this.$root;
        this.closeOnEventSource.$on(this.closeOn, this.close);
      }
      media.small.addListener(this.refreshMedia);
      media.large.addListener(this.refreshMedia);
      this.$nextTick(function () {
        return _this.refreshMedia();
      });
    },
    beforeDestroy: function beforeDestroy() {
      media.small.removeListener(this.refreshMedia);
      media.large.removeListener(this.refreshMedia);

      if (this.toggleOnEventSource) {
        this.toggleOnEventSource.$off(this.toggleOn, this.toggle);
      }
      if (this.openOnEventSource) {
        this.openOnEventSource.$off(this.openOn, this.open);
      }
      if (this.closeOnEventSource) {
        this.closeOnEventSource.$off(this.closeOn, this.close);
      }
    }
  };

  var mdcDrawerLayout = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-drawer-layout" }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-layout'
  };

  var mdcDrawerHeader = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _vm.show ? _c('header', { staticClass: "mdc-drawer-header mdc-drawer__header" }, [_c('div', { staticClass: "mdc-drawer__header-content" }, [_vm._t("default")], 2)]) : _vm._e();
    }, staticRenderFns: [],
    name: 'mdc-drawer-header',
    props: {
      'permanent': Boolean,
      'persistent': Boolean,
      'temporary': Boolean
    },
    inject: ['mdcDrawer'],
    computed: {
      show: function show() {
        if (this.temporary || this.persistent || this.permanent) {
          return this.temporary && this.mdcDrawer.isTemporary || this.persistent && this.mdcDrawer.isPersistent || this.permanent && this.mdcDrawer.isPermanent;
        } else {
          return true;
        }
      }
    }
  };

  var mdcDrawerList = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('nav', { staticClass: "mdc-drawer-list mdc-list", class: _vm.classes }, [_vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-list',
    props: {
      'dense': Boolean
    },
    data: function data() {
      return {
        classes: {
          'mdc-list--dense': this.dense
        }
      };
    }
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint no-unused-vars: [2, {"args": "none"}] */

  /**
   * Adapter for MDC Ripple. Provides an interface for managing
   * - classes
   * - dom
   * - CSS variables
   * - position
   * - dimensions
   * - scroll position
   * - event handlers
   * - unbounded, active and disabled states
   *
   * Additionally, provides type information for the adapter to the Closure
   * compiler.
   *
   * Implement this adapter for your framework of choice to delegate updates to
   * the component in your framework of choice. See architecture documentation
   * for more details.
   * https://github.com/material-components/material-components-web/blob/master/docs/code/architecture.md
   *
   * @record
   */
  var MDCRippleAdapter = function () {
    function MDCRippleAdapter() {
      classCallCheck(this, MDCRippleAdapter);
    }

    createClass(MDCRippleAdapter, [{
      key: "browserSupportsCssVars",

      /** @return {boolean} */
      value: function browserSupportsCssVars() {}

      /** @return {boolean} */

    }, {
      key: "isUnbounded",
      value: function isUnbounded() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceActive",
      value: function isSurfaceActive() {}

      /** @return {boolean} */

    }, {
      key: "isSurfaceDisabled",
      value: function isSurfaceDisabled() {}

      /** @param {string} className */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /** @param {string} className */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /** @param {!EventTarget} target */

    }, {
      key: "containsEventTarget",
      value: function containsEventTarget(target) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "registerDocumentInteractionHandler",
      value: function registerDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {string} evtType
       * @param {!Function} handler
       */

    }, {
      key: "deregisterDocumentInteractionHandler",
      value: function deregisterDocumentInteractionHandler(evtType, handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * @param {!Function} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * @param {string} varName
       * @param {?number|string} value
       */

    }, {
      key: "updateCssVariable",
      value: function updateCssVariable(varName, value) {}

      /** @return {!ClientRect} */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /** @return {{x: number, y: number}} */

    }, {
      key: "getWindowPageOffset",
      value: function getWindowPageOffset() {}
    }]);
    return MDCRippleAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  var cssClasses$2 = {
    // Ripple is a special case where the "root" component is really a "mixin" of sorts,
    // given that it's an 'upgrade' to an existing component. That being said it is the root
    // CSS class that all other CSS classes derive from.
    ROOT: 'mdc-ripple-upgraded',
    UNBOUNDED: 'mdc-ripple-upgraded--unbounded',
    BG_FOCUSED: 'mdc-ripple-upgraded--background-focused',
    FG_ACTIVATION: 'mdc-ripple-upgraded--foreground-activation',
    FG_DEACTIVATION: 'mdc-ripple-upgraded--foreground-deactivation'
  };

  var strings$2 = {
    VAR_LEFT: '--mdc-ripple-left',
    VAR_TOP: '--mdc-ripple-top',
    VAR_FG_SIZE: '--mdc-ripple-fg-size',
    VAR_FG_SCALE: '--mdc-ripple-fg-scale',
    VAR_FG_TRANSLATE_START: '--mdc-ripple-fg-translate-start',
    VAR_FG_TRANSLATE_END: '--mdc-ripple-fg-translate-end'
  };

  var numbers = {
    PADDING: 10,
    INITIAL_ORIGIN_SCALE: 0.6,
    DEACTIVATION_TIMEOUT_MS: 225, // Corresponds to $mdc-ripple-translate-duration (i.e. activation animation duration)
    FG_DEACTIVATION_MS: 150, // Corresponds to $mdc-ripple-fade-out-duration (i.e. deactivation animation duration)
    TAP_DELAY_MS: 300 // Delay between touch and simulated mouse events on touch devices
  };

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * Stores result from supportsCssVariables to avoid redundant processing to detect CSS custom variable support.
   * @private {boolean|undefined}
   */
  var supportsCssVariables_ = void 0;

  /**
   * Stores result from applyPassive to avoid redundant processing to detect passive event listener support.
   * @private {boolean|undefined}
   */
  var supportsPassive_$1 = void 0;

  /**
   * @param {!Window} windowObj
   * @return {boolean}
   */
  function detectEdgePseudoVarBug(windowObj) {
    // Detect versions of Edge with buggy var() support
    // See: https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/11495448/
    var document = windowObj.document;
    var node = document.createElement('div');
    node.className = 'mdc-ripple-surface--test-edge-var-bug';
    document.body.appendChild(node);

    // The bug exists if ::before style ends up propagating to the parent element.
    // Additionally, getComputedStyle returns null in iframes with display: "none" in Firefox,
    // but Firefox is known to support CSS custom properties correctly.
    // See: https://bugzilla.mozilla.org/show_bug.cgi?id=548397
    var computedStyle = windowObj.getComputedStyle(node);
    var hasPseudoVarBug = computedStyle !== null && computedStyle.borderTopStyle === 'solid';
    node.remove();
    return hasPseudoVarBug;
  }

  /**
   * @param {!Window} windowObj
   * @param {boolean=} forceRefresh
   * @return {boolean|undefined}
   */

  function supportsCssVariables(windowObj) {
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var supportsCssVariables = supportsCssVariables_;
    if (typeof supportsCssVariables_ === 'boolean' && !forceRefresh) {
      return supportsCssVariables;
    }

    var supportsFunctionPresent = windowObj.CSS && typeof windowObj.CSS.supports === 'function';
    if (!supportsFunctionPresent) {
      return;
    }

    var explicitlySupportsCssVars = windowObj.CSS.supports('--css-vars', 'yes');
    // See: https://bugs.webkit.org/show_bug.cgi?id=154669
    // See: README section on Safari
    var weAreFeatureDetectingSafari10plus = windowObj.CSS.supports('(--css-vars: yes)') && windowObj.CSS.supports('color', '#00000000');

    if (explicitlySupportsCssVars || weAreFeatureDetectingSafari10plus) {
      supportsCssVariables = !detectEdgePseudoVarBug(windowObj);
    } else {
      supportsCssVariables = false;
    }

    if (!forceRefresh) {
      supportsCssVariables_ = supportsCssVariables;
    }
    return supportsCssVariables;
  }

  //
  /**
   * Determine whether the current browser supports passive event listeners, and if so, use them.
   * @param {!Window=} globalObj
   * @param {boolean=} forceRefresh
   * @return {boolean|{passive: boolean}}
   */
  function applyPassive$1() {
    var globalObj = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : window;
    var forceRefresh = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    if (supportsPassive_$1 === undefined || forceRefresh) {
      var isSupported = false;
      try {
        globalObj.document.addEventListener('test', null, { get passive() {
            isSupported = true;
          } });
      } catch (e) {}

      supportsPassive_$1 = isSupported;
    }

    return supportsPassive_$1 ? { passive: true } : false;
  }

  /**
   * @param {!Object} HTMLElementPrototype
   * @return {!Array<string>}
   */
  function getMatchesProperty(HTMLElementPrototype) {
    return ['webkitMatchesSelector', 'msMatchesSelector', 'matches'].filter(function (p) {
      return p in HTMLElementPrototype;
    }).pop();
  }

  /**
   * @param {!Event} ev
   * @param {!{x: number, y: number}} pageOffset
   * @param {!ClientRect} clientRect
   * @return {!{x: number, y: number}}
   */
  function getNormalizedEventCoords(ev, pageOffset, clientRect) {
    var x = pageOffset.x,
        y = pageOffset.y;

    var documentX = x + clientRect.left;
    var documentY = y + clientRect.top;

    var normalizedX = void 0;
    var normalizedY = void 0;
    // Determine touch point relative to the ripple container.
    if (ev.type === 'touchstart') {
      normalizedX = ev.changedTouches[0].pageX - documentX;
      normalizedY = ev.changedTouches[0].pageY - documentY;
    } else {
      normalizedX = ev.pageX - documentX;
      normalizedY = ev.pageY - documentY;
    }

    return { x: normalizedX, y: normalizedY };
  }

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  // Activation events registered on the root element of each instance for activation
  var ACTIVATION_EVENT_TYPES = ['touchstart', 'pointerdown', 'mousedown', 'keydown'];

  // Deactivation events registered on documentElement when a pointer-related down event occurs
  var POINTER_DEACTIVATION_EVENT_TYPES = ['touchend', 'pointerup', 'mouseup'];

  // Tracks activations that have occurred on the current frame, to avoid simultaneous nested activations
  /** @type {!Array<!EventTarget>} */
  var activatedTargets = [];

  /**
   * @extends {MDCFoundation<!MDCRippleAdapter>}
   */

  var MDCRippleFoundation = function (_MDCFoundation) {
    inherits(MDCRippleFoundation, _MDCFoundation);
    createClass(MDCRippleFoundation, null, [{
      key: 'cssClasses',
      get: function get$$1() {
        return cssClasses$2;
      }
    }, {
      key: 'strings',
      get: function get$$1() {
        return strings$2;
      }
    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }
    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return {
          browserSupportsCssVars: function browserSupportsCssVars() /* boolean - cached */{},
          isUnbounded: function isUnbounded() /* boolean */{},
          isSurfaceActive: function isSurfaceActive() /* boolean */{},
          isSurfaceDisabled: function isSurfaceDisabled() /* boolean */{},
          addClass: function addClass() /* className: string */{},
          removeClass: function removeClass() /* className: string */{},
          containsEventTarget: function containsEventTarget() /* target: !EventTarget */{},
          registerInteractionHandler: function registerInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterInteractionHandler: function deregisterInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerDocumentInteractionHandler: function registerDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler() /* evtType: string, handler: EventListener */{},
          registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
          deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
          updateCssVariable: function updateCssVariable() /* varName: string, value: string */{},
          computeBoundingRect: function computeBoundingRect() /* ClientRect */{},
          getWindowPageOffset: function getWindowPageOffset() /* {x: number, y: number} */{}
        };
      }
    }]);

    function MDCRippleFoundation(adapter) {
      classCallCheck(this, MDCRippleFoundation);

      /** @private {number} */
      var _this = possibleConstructorReturn(this, (MDCRippleFoundation.__proto__ || Object.getPrototypeOf(MDCRippleFoundation)).call(this, _extends(MDCRippleFoundation.defaultAdapter, adapter)));

      _this.layoutFrame_ = 0;

      /** @private {!ClientRect} */
      _this.frame_ = /** @type {!ClientRect} */{ width: 0, height: 0 };

      /** @private {!ActivationStateType} */
      _this.activationState_ = _this.defaultActivationState_();

      /** @private {number} */
      _this.initialSize_ = 0;

      /** @private {number} */
      _this.maxRadius_ = 0;

      /** @private {function(!Event)} */
      _this.activateHandler_ = function (e) {
        return _this.activate_(e);
      };

      /** @private {function(!Event)} */
      _this.deactivateHandler_ = function (e) {
        return _this.deactivate_(e);
      };

      /** @private {function(?Event=)} */
      _this.focusHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.addClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {function(?Event=)} */
      _this.blurHandler_ = function () {
        return requestAnimationFrame(function () {
          return _this.adapter_.removeClass(MDCRippleFoundation.cssClasses.BG_FOCUSED);
        });
      };

      /** @private {!Function} */
      _this.resizeHandler_ = function () {
        return _this.layout();
      };

      /** @private {!{left: number, top:number}} */
      _this.unboundedCoords_ = {
        left: 0,
        top: 0
      };

      /** @private {number} */
      _this.fgScale_ = 0;

      /** @private {number} */
      _this.activationTimer_ = 0;

      /** @private {number} */
      _this.fgDeactivationRemovalTimer_ = 0;

      /** @private {boolean} */
      _this.activationAnimationHasEnded_ = false;

      /** @private {!Function} */
      _this.activationTimerCallback_ = function () {
        _this.activationAnimationHasEnded_ = true;
        _this.runDeactivationUXLogicIfReady_();
      };

      /** @private {?Event} */
      _this.previousActivationEvent_ = null;
      return _this;
    }

    /**
     * We compute this property so that we are not querying information about the client
     * until the point in time where the foundation requests it. This prevents scenarios where
     * client-side feature-detection may happen too early, such as when components are rendered on the server
     * and then initialized at mount time on the client.
     * @return {boolean}
     * @private
     */


    createClass(MDCRippleFoundation, [{
      key: 'isSupported_',
      value: function isSupported_() {
        return this.adapter_.browserSupportsCssVars();
      }

      /**
       * @return {!ActivationStateType}
       */

    }, {
      key: 'defaultActivationState_',
      value: function defaultActivationState_() {
        return {
          isActivated: false,
          hasDeactivationUXRun: false,
          wasActivatedByPointer: false,
          wasElementMadeActive: false,
          activationEvent: null,
          isProgrammatic: false
        };
      }
    }, {
      key: 'init',
      value: function init() {
        var _this2 = this;

        if (!this.isSupported_()) {
          return;
        }
        this.registerRootHandlers_();

        var _MDCRippleFoundation$ = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$.ROOT,
            UNBOUNDED = _MDCRippleFoundation$.UNBOUNDED;

        requestAnimationFrame(function () {
          _this2.adapter_.addClass(ROOT);
          if (_this2.adapter_.isUnbounded()) {
            _this2.adapter_.addClass(UNBOUNDED);
          }
          _this2.layoutInternal_();
        });
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        if (!this.isSupported_()) {
          return;
        }

        if (this.activationTimer_) {
          clearTimeout(this.activationTimer_);
          this.activationTimer_ = 0;
          var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

          this.adapter_.removeClass(FG_ACTIVATION);
        }

        this.deregisterRootHandlers_();
        this.deregisterDeactivationHandlers_();

        var _MDCRippleFoundation$2 = MDCRippleFoundation.cssClasses,
            ROOT = _MDCRippleFoundation$2.ROOT,
            UNBOUNDED = _MDCRippleFoundation$2.UNBOUNDED;

        requestAnimationFrame(function () {
          _this3.adapter_.removeClass(ROOT);
          _this3.adapter_.removeClass(UNBOUNDED);
          _this3.removeCssVars_();
        });
      }

      /** @private */

    }, {
      key: 'registerRootHandlers_',
      value: function registerRootHandlers_() {
        var _this4 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this4.adapter_.registerInteractionHandler(type, _this4.activateHandler_);
        });
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        this.adapter_.registerResizeHandler(this.resizeHandler_);
      }

      /**
       * @param {!Event} e
       * @private
       */

    }, {
      key: 'registerDeactivationHandlers_',
      value: function registerDeactivationHandlers_(e) {
        var _this5 = this;

        if (e.type === 'keydown') {
          this.adapter_.registerInteractionHandler('keyup', this.deactivateHandler_);
        } else {
          POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
            _this5.adapter_.registerDocumentInteractionHandler(type, _this5.deactivateHandler_);
          });
        }
      }

      /** @private */

    }, {
      key: 'deregisterRootHandlers_',
      value: function deregisterRootHandlers_() {
        var _this6 = this;

        ACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this6.adapter_.deregisterInteractionHandler(type, _this6.activateHandler_);
        });
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }

      /** @private */

    }, {
      key: 'deregisterDeactivationHandlers_',
      value: function deregisterDeactivationHandlers_() {
        var _this7 = this;

        this.adapter_.deregisterInteractionHandler('keyup', this.deactivateHandler_);
        POINTER_DEACTIVATION_EVENT_TYPES.forEach(function (type) {
          _this7.adapter_.deregisterDocumentInteractionHandler(type, _this7.deactivateHandler_);
        });
      }

      /** @private */

    }, {
      key: 'removeCssVars_',
      value: function removeCssVars_() {
        var _this8 = this;

        var strings = MDCRippleFoundation.strings;

        Object.keys(strings).forEach(function (k) {
          if (k.indexOf('VAR_') === 0) {
            _this8.adapter_.updateCssVariable(strings[k], null);
          }
        });
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'activate_',
      value: function activate_(e) {
        var _this9 = this;

        if (this.adapter_.isSurfaceDisabled()) {
          return;
        }

        var activationState = this.activationState_;
        if (activationState.isActivated) {
          return;
        }

        // Avoid reacting to follow-on events fired by touch device after an already-processed user interaction
        var previousActivationEvent = this.previousActivationEvent_;
        var isSameInteraction = previousActivationEvent && e && previousActivationEvent.type !== e.type;
        if (isSameInteraction) {
          return;
        }

        activationState.isActivated = true;
        activationState.isProgrammatic = e === null;
        activationState.activationEvent = e;
        activationState.wasActivatedByPointer = activationState.isProgrammatic ? false : e.type === 'mousedown' || e.type === 'touchstart' || e.type === 'pointerdown';

        var hasActivatedChild = e && activatedTargets.length > 0 && activatedTargets.some(function (target) {
          return _this9.adapter_.containsEventTarget(target);
        });
        if (hasActivatedChild) {
          // Immediately reset activation state, while preserving logic that prevents touch follow-on events
          this.resetActivationState_();
          return;
        }

        if (e) {
          activatedTargets.push( /** @type {!EventTarget} */e.target);
          this.registerDeactivationHandlers_(e);
        }

        requestAnimationFrame(function () {
          // This needs to be wrapped in an rAF call b/c web browsers
          // report active states inconsistently when they're called within
          // event handling code:
          // - https://bugs.chromium.org/p/chromium/issues/detail?id=635971
          // - https://bugzilla.mozilla.org/show_bug.cgi?id=1293741
          activationState.wasElementMadeActive = e && e.type === 'keydown' ? _this9.adapter_.isSurfaceActive() : true;
          if (activationState.wasElementMadeActive) {
            _this9.animateActivation_();
          } else {
            // Reset activation state immediately if element was not made active.
            _this9.activationState_ = _this9.defaultActivationState_();
          }

          // Reset array on next frame after the current event has had a chance to bubble to prevent ancestor ripples
          activatedTargets = [];
        });
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'activate',
      value: function activate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.activate_(event);
      }

      /** @private */

    }, {
      key: 'animateActivation_',
      value: function animateActivation_() {
        var _this10 = this;

        var _MDCRippleFoundation$3 = MDCRippleFoundation.strings,
            VAR_FG_TRANSLATE_START = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_START,
            VAR_FG_TRANSLATE_END = _MDCRippleFoundation$3.VAR_FG_TRANSLATE_END;
        var _MDCRippleFoundation$4 = MDCRippleFoundation.cssClasses,
            FG_DEACTIVATION = _MDCRippleFoundation$4.FG_DEACTIVATION,
            FG_ACTIVATION = _MDCRippleFoundation$4.FG_ACTIVATION;
        var DEACTIVATION_TIMEOUT_MS = MDCRippleFoundation.numbers.DEACTIVATION_TIMEOUT_MS;


        var translateStart = '';
        var translateEnd = '';

        if (!this.adapter_.isUnbounded()) {
          var _getFgTranslationCoor = this.getFgTranslationCoordinates_(),
              startPoint = _getFgTranslationCoor.startPoint,
              endPoint = _getFgTranslationCoor.endPoint;

          translateStart = startPoint.x + 'px, ' + startPoint.y + 'px';
          translateEnd = endPoint.x + 'px, ' + endPoint.y + 'px';
        }

        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_START, translateStart);
        this.adapter_.updateCssVariable(VAR_FG_TRANSLATE_END, translateEnd);
        // Cancel any ongoing activation/deactivation animations
        clearTimeout(this.activationTimer_);
        clearTimeout(this.fgDeactivationRemovalTimer_);
        this.rmBoundedActivationClasses_();
        this.adapter_.removeClass(FG_DEACTIVATION);

        // Force layout in order to re-trigger the animation.
        this.adapter_.computeBoundingRect();
        this.adapter_.addClass(FG_ACTIVATION);
        this.activationTimer_ = setTimeout(function () {
          return _this10.activationTimerCallback_();
        }, DEACTIVATION_TIMEOUT_MS);
      }

      /**
       * @private
       * @return {{startPoint: PointType, endPoint: PointType}}
       */

    }, {
      key: 'getFgTranslationCoordinates_',
      value: function getFgTranslationCoordinates_() {
        var _activationState_ = this.activationState_,
            activationEvent = _activationState_.activationEvent,
            wasActivatedByPointer = _activationState_.wasActivatedByPointer;


        var startPoint = void 0;
        if (wasActivatedByPointer) {
          startPoint = getNormalizedEventCoords(
          /** @type {!Event} */activationEvent, this.adapter_.getWindowPageOffset(), this.adapter_.computeBoundingRect());
        } else {
          startPoint = {
            x: this.frame_.width / 2,
            y: this.frame_.height / 2
          };
        }
        // Center the element around the start point.
        startPoint = {
          x: startPoint.x - this.initialSize_ / 2,
          y: startPoint.y - this.initialSize_ / 2
        };

        var endPoint = {
          x: this.frame_.width / 2 - this.initialSize_ / 2,
          y: this.frame_.height / 2 - this.initialSize_ / 2
        };

        return { startPoint: startPoint, endPoint: endPoint };
      }

      /** @private */

    }, {
      key: 'runDeactivationUXLogicIfReady_',
      value: function runDeactivationUXLogicIfReady_() {
        var _this11 = this;

        // This method is called both when a pointing device is released, and when the activation animation ends.
        // The deactivation animation should only run after both of those occur.
        var FG_DEACTIVATION = MDCRippleFoundation.cssClasses.FG_DEACTIVATION;
        var _activationState_2 = this.activationState_,
            hasDeactivationUXRun = _activationState_2.hasDeactivationUXRun,
            isActivated = _activationState_2.isActivated;

        var activationHasEnded = hasDeactivationUXRun || !isActivated;

        if (activationHasEnded && this.activationAnimationHasEnded_) {
          this.rmBoundedActivationClasses_();
          this.adapter_.addClass(FG_DEACTIVATION);
          this.fgDeactivationRemovalTimer_ = setTimeout(function () {
            _this11.adapter_.removeClass(FG_DEACTIVATION);
          }, numbers.FG_DEACTIVATION_MS);
        }
      }

      /** @private */

    }, {
      key: 'rmBoundedActivationClasses_',
      value: function rmBoundedActivationClasses_() {
        var FG_ACTIVATION = MDCRippleFoundation.cssClasses.FG_ACTIVATION;

        this.adapter_.removeClass(FG_ACTIVATION);
        this.activationAnimationHasEnded_ = false;
        this.adapter_.computeBoundingRect();
      }
    }, {
      key: 'resetActivationState_',
      value: function resetActivationState_() {
        var _this12 = this;

        this.previousActivationEvent_ = this.activationState_.activationEvent;
        this.activationState_ = this.defaultActivationState_();
        // Touch devices may fire additional events for the same interaction within a short time.
        // Store the previous event until it's safe to assume that subsequent events are for new interactions.
        setTimeout(function () {
          return _this12.previousActivationEvent_ = null;
        }, MDCRippleFoundation.numbers.TAP_DELAY_MS);
      }

      /**
       * @param {?Event} e
       * @private
       */

    }, {
      key: 'deactivate_',
      value: function deactivate_(e) {
        var _this13 = this;

        var activationState = this.activationState_;
        // This can happen in scenarios such as when you have a keyup event that blurs the element.
        if (!activationState.isActivated) {
          return;
        }

        var state = /** @type {!ActivationStateType} */_extends({}, activationState);

        if (activationState.isProgrammatic) {
          var evtObject = null;
          requestAnimationFrame(function () {
            return _this13.animateDeactivation_(evtObject, state);
          });
          this.resetActivationState_();
        } else {
          this.deregisterDeactivationHandlers_();
          requestAnimationFrame(function () {
            _this13.activationState_.hasDeactivationUXRun = true;
            _this13.animateDeactivation_(e, state);
            _this13.resetActivationState_();
          });
        }
      }

      /**
       * @param {?Event=} event Optional event containing position information.
       */

    }, {
      key: 'deactivate',
      value: function deactivate() {
        var event = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

        this.deactivate_(event);
      }

      /**
       * @param {Event} e
       * @param {!ActivationStateType} options
       * @private
       */

    }, {
      key: 'animateDeactivation_',
      value: function animateDeactivation_(e, _ref) {
        var wasActivatedByPointer = _ref.wasActivatedByPointer,
            wasElementMadeActive = _ref.wasElementMadeActive;

        if (wasActivatedByPointer || wasElementMadeActive) {
          this.runDeactivationUXLogicIfReady_();
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        var _this14 = this;

        if (this.layoutFrame_) {
          cancelAnimationFrame(this.layoutFrame_);
        }
        this.layoutFrame_ = requestAnimationFrame(function () {
          _this14.layoutInternal_();
          _this14.layoutFrame_ = 0;
        });
      }

      /** @private */

    }, {
      key: 'layoutInternal_',
      value: function layoutInternal_() {
        var _this15 = this;

        this.frame_ = this.adapter_.computeBoundingRect();
        var maxDim = Math.max(this.frame_.height, this.frame_.width);

        // Surface diameter is treated differently for unbounded vs. bounded ripples.
        // Unbounded ripple diameter is calculated smaller since the surface is expected to already be padded appropriately
        // to extend the hitbox, and the ripple is expected to meet the edges of the padded hitbox (which is typically
        // square). Bounded ripples, on the other hand, are fully expected to expand beyond the surface's longest diameter
        // (calculated based on the diagonal plus a constant padding), and are clipped at the surface's border via
        // `overflow: hidden`.
        var getBoundedRadius = function getBoundedRadius() {
          var hypotenuse = Math.sqrt(Math.pow(_this15.frame_.width, 2) + Math.pow(_this15.frame_.height, 2));
          return hypotenuse + MDCRippleFoundation.numbers.PADDING;
        };

        this.maxRadius_ = this.adapter_.isUnbounded() ? maxDim : getBoundedRadius();

        // Ripple is sized as a fraction of the largest dimension of the surface, then scales up using a CSS scale transform
        this.initialSize_ = maxDim * MDCRippleFoundation.numbers.INITIAL_ORIGIN_SCALE;
        this.fgScale_ = this.maxRadius_ / this.initialSize_;

        this.updateLayoutCssVars_();
      }

      /** @private */

    }, {
      key: 'updateLayoutCssVars_',
      value: function updateLayoutCssVars_() {
        var _MDCRippleFoundation$5 = MDCRippleFoundation.strings,
            VAR_FG_SIZE = _MDCRippleFoundation$5.VAR_FG_SIZE,
            VAR_LEFT = _MDCRippleFoundation$5.VAR_LEFT,
            VAR_TOP = _MDCRippleFoundation$5.VAR_TOP,
            VAR_FG_SCALE = _MDCRippleFoundation$5.VAR_FG_SCALE;


        this.adapter_.updateCssVariable(VAR_FG_SIZE, this.initialSize_ + 'px');
        this.adapter_.updateCssVariable(VAR_FG_SCALE, this.fgScale_);

        if (this.adapter_.isUnbounded()) {
          this.unboundedCoords_ = {
            left: Math.round(this.frame_.width / 2 - this.initialSize_ / 2),
            top: Math.round(this.frame_.height / 2 - this.initialSize_ / 2)
          };

          this.adapter_.updateCssVariable(VAR_LEFT, this.unboundedCoords_.left + 'px');
          this.adapter_.updateCssVariable(VAR_TOP, this.unboundedCoords_.top + 'px');
        }
      }

      /** @param {boolean} unbounded */

    }, {
      key: 'setUnbounded',
      value: function setUnbounded(unbounded) {
        var UNBOUNDED = MDCRippleFoundation.cssClasses.UNBOUNDED;

        if (unbounded) {
          this.adapter_.addClass(UNBOUNDED);
        } else {
          this.adapter_.removeClass(UNBOUNDED);
        }
      }
    }]);
    return MDCRippleFoundation;
  }(MDCFoundation);

  var RippleBase = function (_MDCRippleFoundation) {
    inherits(RippleBase, _MDCRippleFoundation);
    createClass(RippleBase, null, [{
      key: 'isSurfaceActive',
      value: function isSurfaceActive(ref) {
        return ref[RippleBase.MATCHES](':active');
      }
    }, {
      key: 'MATCHES',
      get: function get$$1() {
        /* global HTMLElement */
        return RippleBase._matches || (RippleBase._matches = getMatchesProperty(HTMLElement.prototype));
      }
    }]);

    function RippleBase(vm, options) {
      classCallCheck(this, RippleBase);
      return possibleConstructorReturn(this, (RippleBase.__proto__ || Object.getPrototypeOf(RippleBase)).call(this, _extends({
        browserSupportsCssVars: function browserSupportsCssVars() {
          return supportsCssVariables(window);
        },
        isUnbounded: function isUnbounded() {
          return false;
        },
        isSurfaceActive: function isSurfaceActive() {
          return vm.$el[RippleBase.MATCHES](':active');
        },
        isSurfaceDisabled: function isSurfaceDisabled() {
          return vm.disabled;
        },
        addClass: function addClass(className) {
          vm.$set(vm.classes, className, true);
        },
        removeClass: function removeClass(className) {
          vm.$delete(vm.classes, className);
        },

        containsEventTarget: function containsEventTarget(target) {
          return vm.$el.contains(target);
        },
        registerInteractionHandler: function registerInteractionHandler(evt, handler) {
          vm.$el.addEventListener(evt, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(evt, handler) {
          vm.$el.removeEventListener(evt, handler);
        },
        registerDocumentInteractionHandler: function registerDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.addEventListener(evtType, handler, applyPassive$1());
        },
        deregisterDocumentInteractionHandler: function deregisterDocumentInteractionHandler(evtType, handler) {
          return document.documentElement.removeEventListener(evtType, handler, applyPassive$1());
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          return window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          return window.removeEventListener('resize', handler);
        },
        updateCssVariable: function updateCssVariable(varName, value) {
          vm.$set(vm.styles, varName, value);
        },
        computeBoundingRect: function computeBoundingRect() {
          return vm.$el.getBoundingClientRect();
        },
        getWindowPageOffset: function getWindowPageOffset() {
          return { x: window.pageXOffset, y: window.pageYOffset };
        }
      }, options)));
    }

    return RippleBase;
  }(MDCRippleFoundation);

  var mdcDrawerItem = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('custom-link', _vm._g({ staticClass: "mdc-drawer-item mdc-list-item", class: [_vm.classes, _vm.itemClasses], style: _vm.styles, attrs: { "link": _vm.link } }, _vm.mylisteners), [_vm.hasStartDetail ? _c('span', { staticClass: "mdc-list-item__graphic" }, [_vm._t("start-detail", [_c('i', { staticClass: "material-icons", attrs: { "aria-hidden": "true" } }, [_vm._v(_vm._s(_vm.startIcon))])])], 2) : _vm._e(), _vm._v(" "), _vm._t("default")], 2);
    }, staticRenderFns: [],
    name: 'mdc-drawer-item',
    inject: ['mdcDrawer'],
    mixins: [DispatchEventMixin, CustomLinkMixin],
    props: {
      startIcon: String,
      temporaryClose: {
        type: Boolean,
        default: true
      },
      activated: Boolean,
      exactActiveClass: {
        type: String,
        default: 'mdc-list-item--activated'
      }
    },
    data: function data() {
      return {
        classes: {},
        styles: {}
      };
    },

    computed: {
      mylisteners: function mylisteners() {
        var _this = this;

        return _extends({}, this.$listeners, {
          click: function click(e) {
            _this.mdcDrawer.isTemporary && _this.temporaryClose && _this.mdcDrawer.close();
            _this.dispatchEvent(e);
          }
        });
      },
      itemClasses: function itemClasses() {
        return {
          'mdc-list-item--activated': this.activated
        };
      },
      hasStartDetail: function hasStartDetail() {
        return this.startIcon || this.$slots['start-detail'];
      }
    },
    mounted: function mounted() {
      this.ripple = new RippleBase(this);
      this.ripple.init();
    },
    beforeDestroy: function beforeDestroy() {
      this.ripple && this.ripple.destroy();
      this.ripple = null;
    }
  };

  var mdcDrawerDivider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('hr', { staticClass: "mdc-list-divider" });
    }, staticRenderFns: [],
    name: 'mdc-drawer-divider'
  };

  var plugin = BasePlugin({
    mdcDrawer: mdcDrawer,
    mdcDrawerLayout: mdcDrawerLayout,
    mdcDrawerHeader: mdcDrawerHeader,
    mdcDrawerList: mdcDrawerList,
    mdcDrawerItem: mdcDrawerItem,
    mdcDrawerDivider: mdcDrawerDivider
  });

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZHJhd2VyLmpzIiwic291cmNlcyI6WyIuLi8uLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1saW5rLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uLy4uL2NvbXBvbmVudHMvYmFzZS9kaXNwYXRjaC1ldmVudC1taXhpbi5qcyIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1wZXJtYW5lbnQtZHJhd2VyLnZ1ZSIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9iYXNlL2NvbXBvbmVudC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3NsaWRhYmxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci9zbGlkYWJsZS9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvZHJhd2VyL3BlcnNpc3RlbnQvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvcGVyc2lzdGVudC9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdXRpbC5qcyIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1wZXJzaXN0ZW50LWRyYXdlci52dWUiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2RyYXdlci90ZW1wb3JhcnkvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2ZvdW5kYXRpb24uanMiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUiLCIuLi8uLi9jb21wb25lbnRzL2NvbW1vbi9ldmVudC1idXMuanMiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItbGF5b3V0LnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItaGVhZGVyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL21kYy1kcmF3ZXItbGlzdC52dWUiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL3JpcHBsZS9hZGFwdGVyLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvY29uc3RhbnRzLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9yaXBwbGUvdXRpbC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvcmlwcGxlL2ZvdW5kYXRpb24uanMiLCIuLi8uLi9jb21wb25lbnRzL3JpcHBsZS9tZGMtcmlwcGxlLWJhc2UuanMiLCIuLi8uLi9jb21wb25lbnRzL2RyYXdlci9tZGMtZHJhd2VyLWl0ZW0udnVlIiwiLi4vLi4vY29tcG9uZW50cy9kcmF3ZXIvbWRjLWRyYXdlci1kaXZpZGVyLnZ1ZSIsIi4uLy4uL2NvbXBvbmVudHMvZHJhd2VyL2luZGV4LmpzIiwiLi4vLi4vY29tcG9uZW50cy9kcmF3ZXIvZW50cnkuanMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGF1dG9Jbml0IChwbHVnaW4pIHtcbiAgLy8gQXV0by1pbnN0YWxsXG4gIGxldCBfVnVlID0gbnVsbFxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBfVnVlID0gd2luZG93LlZ1ZVxuICB9IGVsc2UgaWYgKHR5cGVvZiBnbG9iYWwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgLypnbG9iYWwgZ2xvYmFsKi9cbiAgICBfVnVlID0gZ2xvYmFsLlZ1ZVxuICB9XG4gIGlmIChfVnVlKSB7XG4gICAgX1Z1ZS51c2UocGx1Z2luKVxuICB9XG59XG4gICIsImV4cG9ydCBmdW5jdGlvbiBCYXNlUGx1Z2luIChjb21wb25lbnRzKSB7IFxuICByZXR1cm4ge1xuICAgIHZlcnNpb246ICdfX1ZFUlNJT05fXycsXG4gICAgaW5zdGFsbDogKHZtKSA9PiB7XG4gICAgICBmb3IgKGxldCBrZXkgaW4gY29tcG9uZW50cykge1xuICAgICAgICBsZXQgY29tcG9uZW50ID0gY29tcG9uZW50c1trZXldXG4gICAgICAgICAgdm0uY29tcG9uZW50KGNvbXBvbmVudC5uYW1lLGNvbXBvbmVudClcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbXBvbmVudHNcbiAgfSBcbn1cblxuIiwiZXhwb3J0IGNvbnN0IEN1c3RvbUxpbmsgPSB7XG4gIG5hbWU6ICdjdXN0b20tbGluaycsXG4gIGZ1bmN0aW9uYWw6IHRydWUsXG4gIHByb3BzOiB7XG4gICAgdGFnOiB7IHR5cGU6IFN0cmluZywgZGVmYXVsdDogJ2EnIH0sXG4gICAgbGluayA6IE9iamVjdCxcbiAgfSxcbiAgcmVuZGVyIChoLCBjb250ZXh0KSB7XG4gICAgbGV0IGVsZW1lbnQgXG4gICAgbGV0IGRhdGEgPSBPYmplY3QuYXNzaWduKHt9LCBjb250ZXh0LmRhdGEpXG5cbiAgICBpZiAoY29udGV4dC5wcm9wcy5saW5rICYmIGNvbnRleHQucGFyZW50LiRyb3V0ZXIpIHtcbiAgICAgIC8vIHJvdXRlci1saW5rIGNhc2VcbiAgICAgIGVsZW1lbnQgPSBjb250ZXh0LnBhcmVudC4kcm9vdC4kb3B0aW9ucy5jb21wb25lbnRzWydyb3V0ZXItbGluayddIFxuICAgICAgZGF0YS5wcm9wcyA9IE9iamVjdC5hc3NpZ24oe3RhZzogY29udGV4dC5wcm9wcy50YWd9LCBjb250ZXh0LnByb3BzLmxpbmspXG4gICAgICBpZiAoZGF0YS5vbi5jbGljaykge1xuICAgICAgICBkYXRhLm5hdGl2ZU9uID0ge2NsaWNrOiBkYXRhLm9uLmNsaWNrIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gZWxlbWVudCBmYWxsYmFja1xuICAgICAgZWxlbWVudCA9IGNvbnRleHQucHJvcHMudGFnIFxuICAgIH0gXG5cbiAgICByZXR1cm4gaChlbGVtZW50LCBkYXRhLCBjb250ZXh0LmNoaWxkcmVuKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBDdXN0b21MaW5rTWl4aW4gPSB7XG4gIHByb3BzOiB7XG4gICAgdG86IFtTdHJpbmcsIE9iamVjdF0sXG4gICAgZXhhY3Q6IEJvb2xlYW4sXG4gICAgYXBwZW5kOiBCb29sZWFuLFxuICAgIHJlcGxhY2U6IEJvb2xlYW4sXG4gICAgYWN0aXZlQ2xhc3M6IFN0cmluZyxcbiAgICBleGFjdEFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGluayAoKSB7XG4gICAgICByZXR1cm4gdGhpcy50byAmJiB7XG4gICAgICAgIHRvOiB0aGlzLnRvLFxuICAgICAgICBleGFjdDogdGhpcy5leGFjdCxcbiAgICAgICAgYXBwZW5kOiB0aGlzLmFwcGVuZCxcbiAgICAgICAgcmVwbGFjZTogdGhpcy5yZXBsYWNlLFxuICAgICAgICBhY3RpdmVDbGFzczogdGhpcy5hY3RpdmVDbGFzcyxcbiAgICAgICAgZXhhY3RBY3RpdmVDbGFzczogdGhpcy5leGFjdEFjdGl2ZUNsYXNzLFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgY29tcG9uZW50cyA6IHsgXG4gICAgQ3VzdG9tTGluayBcbiAgfVxufSIsIi8qIGdsb2JhbCBDdXN0b21FdmVudCAqL1xuXG5leHBvcnQgZnVuY3Rpb24gZW1pdEN1c3RvbUV2ZW50IChlbCwgZXZ0VHlwZSwgZXZ0RGF0YSwgc2hvdWxkQnViYmxlID0gZmFsc2UpIHtcbiAgbGV0IGV2dFxuICBpZiAodHlwZW9mIEN1c3RvbUV2ZW50ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgIGRldGFpbDogZXZ0RGF0YSxcbiAgICAgIGJ1YmJsZXM6IHNob3VsZEJ1YmJsZVxuICAgIH0pXG4gIH0gZWxzZSB7XG4gICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50JylcbiAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpXG4gIH1cbiAgZWwuZGlzcGF0Y2hFdmVudChldnQpXG59XG4iLCJleHBvcnQgY29uc3QgRGlzcGF0Y2hFdmVudE1peGluID0ge1xuICBwcm9wczoge1xuICAgIGV2ZW50OiBTdHJpbmcsXG4gICAgJ2V2ZW50LXRhcmdldCc6IE9iamVjdCxcbiAgICAnZXZlbnQtYXJncyc6IEFycmF5LFxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgZGlzcGF0Y2hFdmVudChldnQpIHtcbiAgICAgIGV2dCAmJiB0aGlzLiRlbWl0KGV2dC50eXBlLCBldnQpO1xuICAgICAgaWYgKHRoaXMuZXZlbnQpIHtcbiAgICAgICAgbGV0IHRhcmdldCA9IHRoaXMuZXZlbnRUYXJnZXQgfHwgdGhpcy4kcm9vdDtcbiAgICAgICAgbGV0IGFyZ3MgPSB0aGlzLmV2ZW50QXJncyB8fCBbXTtcbiAgICAgICAgdGFyZ2V0LiRlbWl0KHRoaXMuZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgfVxuICAgIH0sXG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgbGlzdGVuZXJzKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxuICAgICAgICBjbGljazogZSA9PiB0aGlzLmRpc3BhdGNoRXZlbnQoZSksXG4gICAgICB9O1xuICAgIH0sXG4gIH0sXG59O1xuIiwiPHRlbXBsYXRlPlxuICA8bmF2IGNsYXNzPVwibWRjLXBlcm1hbmVudC1kcmF3ZXIgbWRjLWRyYXdlci0tcGVybWFuZW50IG1kYy10eXBvZ3JhcGh5XCI+XG4gICAgPG5hdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2NvbnRlbnRcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiIFxuICAgICAgICB2LWlmPVwidG9vbGJhclNwYWNlclwiPjwvZGl2PlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9uYXY+XG48L3RlbXBsYXRlPlxuXG48c2NyaXB0PlxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXBlcm1hbmVudC1kcmF3ZXInLFxuICBwcm9wczoge1xuICAgICd0b29sYmFyLXNwYWNlcic6IEJvb2xlYW4sXG4gIH1cbn1cbjwvc2NyaXB0PlxuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuZXhwb3J0IGNvbnN0IEZPQ1VTQUJMRV9FTEVNRU5UUyA9XG4gICdhW2hyZWZdLCBhcmVhW2hyZWZdLCBpbnB1dDpub3QoW2Rpc2FibGVkXSksIHNlbGVjdDpub3QoW2Rpc2FibGVkXSksIHRleHRhcmVhOm5vdChbZGlzYWJsZWRdKSwgJyArXG4gICdidXR0b246bm90KFtkaXNhYmxlZF0pLCBpZnJhbWUsIG9iamVjdCwgZW1iZWQsIFt0YWJpbmRleF0sIFtjb250ZW50ZWRpdGFibGVdJztcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5XG4gICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBzZW1hbnRpYyBzdHJpbmdzIGFzIGNvbnN0YW50cy4gZS5nLiB7QVJJQV9ST0xFOiAndGFibGlzdCd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0fSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAvLyB3YXkgb2Ygdmlld2luZyB0aGUgbmVjZXNzYXJ5IG1ldGhvZHMgb2YgYW4gYWRhcHRlci4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGFkYXB0ZXJcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0E9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0ge30pIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUF9ICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnLi9mb3VuZGF0aW9uJztcblxuLyoqXG4gKiBAdGVtcGxhdGUgRlxuICovXG5jbGFzcyBNRENDb21wb25lbnQge1xuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcmV0dXJuIHshTURDQ29tcG9uZW50fVxuICAgKi9cbiAgc3RhdGljIGF0dGFjaFRvKHJvb3QpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHdoaWNoIGV4dGVuZCBNRENCYXNlIHNob3VsZCBwcm92aWRlIGFuIGF0dGFjaFRvKCkgbWV0aG9kIHRoYXQgdGFrZXMgYSByb290IGVsZW1lbnQgYW5kXG4gICAgLy8gcmV0dXJucyBhbiBpbnN0YW50aWF0ZWQgY29tcG9uZW50IHdpdGggaXRzIHJvb3Qgc2V0IHRvIHRoYXQgZWxlbWVudC4gQWxzbyBub3RlIHRoYXQgaW4gdGhlIGNhc2VzIG9mXG4gICAgLy8gc3ViY2xhc3NlcywgYW4gZXhwbGljaXQgZm91bmRhdGlvbiBjbGFzcyB3aWxsIG5vdCBoYXZlIHRvIGJlIHBhc3NlZCBpbjsgaXQgd2lsbCBzaW1wbHkgYmUgaW5pdGlhbGl6ZWRcbiAgICAvLyBmcm9tIGdldERlZmF1bHRGb3VuZGF0aW9uKCkuXG4gICAgcmV0dXJuIG5ldyBNRENDb21wb25lbnQocm9vdCwgbmV3IE1EQ0ZvdW5kYXRpb24oKSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRWxlbWVudH0gcm9vdFxuICAgKiBAcGFyYW0ge0Y9fSBmb3VuZGF0aW9uXG4gICAqIEBwYXJhbSB7Li4uP30gYXJnc1xuICAgKi9cbiAgY29uc3RydWN0b3Iocm9vdCwgZm91bmRhdGlvbiA9IHVuZGVmaW5lZCwgLi4uYXJncykge1xuICAgIC8qKiBAcHJvdGVjdGVkIHshRWxlbWVudH0gKi9cbiAgICB0aGlzLnJvb3RfID0gcm9vdDtcbiAgICB0aGlzLmluaXRpYWxpemUoLi4uYXJncyk7XG4gICAgLy8gTm90ZSB0aGF0IHdlIGluaXRpYWxpemUgZm91bmRhdGlvbiBoZXJlIGFuZCBub3Qgd2l0aGluIHRoZSBjb25zdHJ1Y3RvcidzIGRlZmF1bHQgcGFyYW0gc28gdGhhdFxuICAgIC8vIHRoaXMucm9vdF8gaXMgZGVmaW5lZCBhbmQgY2FuIGJlIHVzZWQgd2l0aGluIHRoZSBmb3VuZGF0aW9uIGNsYXNzLlxuICAgIC8qKiBAcHJvdGVjdGVkIHshRn0gKi9cbiAgICB0aGlzLmZvdW5kYXRpb25fID0gZm91bmRhdGlvbiA9PT0gdW5kZWZpbmVkID8gdGhpcy5nZXREZWZhdWx0Rm91bmRhdGlvbigpIDogZm91bmRhdGlvbjtcbiAgICB0aGlzLmZvdW5kYXRpb25fLmluaXQoKTtcbiAgICB0aGlzLmluaXRpYWxTeW5jV2l0aERPTSgpO1xuICB9XG5cbiAgaW5pdGlhbGl6ZSgvKiAuLi5hcmdzICovKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBjYW4gb3ZlcnJpZGUgdGhpcyB0byBkbyBhbnkgYWRkaXRpb25hbCBzZXR1cCB3b3JrIHRoYXQgd291bGQgYmUgY29uc2lkZXJlZCBwYXJ0IG9mIGFcbiAgICAvLyBcImNvbnN0cnVjdG9yXCIuIEVzc2VudGlhbGx5LCBpdCBpcyBhIGhvb2sgaW50byB0aGUgcGFyZW50IGNvbnN0cnVjdG9yIGJlZm9yZSB0aGUgZm91bmRhdGlvbiBpc1xuICAgIC8vIGluaXRpYWxpemVkLiBBbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgYmVzaWRlcyByb290IGFuZCBmb3VuZGF0aW9uIHdpbGwgYmUgcGFzc2VkIGluIGhlcmUuXG4gIH1cblxuICAvKipcbiAgICogQHJldHVybiB7IUZ9IGZvdW5kYXRpb25cbiAgICovXG4gIGdldERlZmF1bHRGb3VuZGF0aW9uKCkge1xuICAgIC8vIFN1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSB0aGlzIG1ldGhvZCB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkIGZvdW5kYXRpb24gY2xhc3MgZm9yIHRoZVxuICAgIC8vIGNvbXBvbmVudC5cbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1N1YmNsYXNzZXMgbXVzdCBvdmVycmlkZSBnZXREZWZhdWx0Rm91bmRhdGlvbiB0byByZXR1cm4gYSBwcm9wZXJseSBjb25maWd1cmVkICcgK1xuICAgICAgJ2ZvdW5kYXRpb24gY2xhc3MnKTtcbiAgfVxuXG4gIGluaXRpYWxTeW5jV2l0aERPTSgpIHtcbiAgICAvLyBTdWJjbGFzc2VzIHNob3VsZCBvdmVycmlkZSB0aGlzIG1ldGhvZCBpZiB0aGV5IG5lZWQgdG8gcGVyZm9ybSB3b3JrIHRvIHN5bmNocm9uaXplIHdpdGggYSBob3N0IERPTVxuICAgIC8vIG9iamVjdC4gQW4gZXhhbXBsZSBvZiB0aGlzIHdvdWxkIGJlIGEgZm9ybSBjb250cm9sIHdyYXBwZXIgdGhhdCBuZWVkcyB0byBzeW5jaHJvbml6ZSBpdHMgaW50ZXJuYWwgc3RhdGVcbiAgICAvLyB0byBzb21lIHByb3BlcnR5IG9yIGF0dHJpYnV0ZSBvZiB0aGUgaG9zdCBET00uIFBsZWFzZSBub3RlOiB0aGlzIGlzICpub3QqIHRoZSBwbGFjZSB0byBwZXJmb3JtIERPTVxuICAgIC8vIHJlYWRzL3dyaXRlcyB0aGF0IHdvdWxkIGNhdXNlIGxheW91dCAvIHBhaW50LCBhcyB0aGlzIGlzIGNhbGxlZCBzeW5jaHJvbm91c2x5IGZyb20gd2l0aGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBtYXkgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJlbGVhc2UgYW55IHJlc291cmNlcyAvIGRlcmVnaXN0ZXIgYW55IGxpc3RlbmVycyB0aGV5IGhhdmVcbiAgICAvLyBhdHRhY2hlZC4gQW4gZXhhbXBsZSBvZiB0aGlzIG1pZ2h0IGJlIGRlcmVnaXN0ZXJpbmcgYSByZXNpemUgZXZlbnQgZnJvbSB0aGUgd2luZG93IG9iamVjdC5cbiAgICB0aGlzLmZvdW5kYXRpb25fLmRlc3Ryb3koKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBXcmFwcGVyIG1ldGhvZCB0byBhZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gdGhlIGNvbXBvbmVudCdzIHJvb3QgZWxlbWVudC4gVGhpcyBpcyBtb3N0IHVzZWZ1bCB3aGVuXG4gICAqIGxpc3RlbmluZyBmb3IgY3VzdG9tIGV2ZW50cy5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIFdyYXBwZXIgbWV0aG9kIHRvIHJlbW92ZSBhbiBldmVudCBsaXN0ZW5lciB0byB0aGUgY29tcG9uZW50J3Mgcm9vdCBlbGVtZW50LiBUaGlzIGlzIG1vc3QgdXNlZnVsIHdoZW5cbiAgICogdW5saXN0ZW5pbmcgZm9yIGN1c3RvbSBldmVudHMuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICB1bmxpc3RlbihldnRUeXBlLCBoYW5kbGVyKSB7XG4gICAgdGhpcy5yb290Xy5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEZpcmVzIGEgY3Jvc3MtYnJvd3Nlci1jb21wYXRpYmxlIGN1c3RvbSBldmVudCBmcm9tIHRoZSBjb21wb25lbnQgcm9vdCBvZiB0aGUgZ2l2ZW4gdHlwZSxcbiAgICogd2l0aCB0aGUgZ2l2ZW4gZGF0YS5cbiAgICogQHBhcmFtIHtzdHJpbmd9IGV2dFR5cGVcbiAgICogQHBhcmFtIHshT2JqZWN0fSBldnREYXRhXG4gICAqIEBwYXJhbSB7Ym9vbGVhbj19IHNob3VsZEJ1YmJsZVxuICAgKi9cbiAgZW1pdChldnRUeXBlLCBldnREYXRhLCBzaG91bGRCdWJibGUgPSBmYWxzZSkge1xuICAgIGxldCBldnQ7XG4gICAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgZXZ0ID0gbmV3IEN1c3RvbUV2ZW50KGV2dFR5cGUsIHtcbiAgICAgICAgZGV0YWlsOiBldnREYXRhLFxuICAgICAgICBidWJibGVzOiBzaG91bGRCdWJibGUsXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXZ0ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0N1c3RvbUV2ZW50Jyk7XG4gICAgICBldnQuaW5pdEN1c3RvbUV2ZW50KGV2dFR5cGUsIHNob3VsZEJ1YmJsZSwgZmFsc2UsIGV2dERhdGEpO1xuICAgIH1cblxuICAgIHRoaXMucm9vdF8uZGlzcGF0Y2hFdmVudChldnQpO1xuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0NvbXBvbmVudDtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICcuL2ZvdW5kYXRpb24nO1xuaW1wb3J0IE1EQ0NvbXBvbmVudCBmcm9tICcuL2NvbXBvbmVudCc7XG5cbmV4cG9ydCB7TURDRm91bmRhdGlvbiwgTURDQ29tcG9uZW50fTtcbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7TURDRm91bmRhdGlvbn0gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvaW5kZXgnO1xuXG5leHBvcnQgY2xhc3MgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBoYXNDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGhhc05lY2Vzc2FyeURvbTogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIHJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0OiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dDogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgc2V0VHJhbnNsYXRlWDogKC8qIHZhbHVlOiBudW1iZXIgfCBudWxsICovKSA9PiB7fSxcbiAgICAgIGdldEZvY3VzYWJsZUVsZW1lbnRzOiAoKSA9PiAvKiBOb2RlTGlzdCAqLyB7fSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6ICgvKiBlbDogRWxlbWVudCAqLykgPT4ge30sXG4gICAgICByZXN0b3JlRWxlbWVudFRhYlN0YXRlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbWFrZUVsZW1lbnRVbnRhYmJhYmxlOiAoLyogZWw6IEVsZW1lbnQgKi8pID0+IHt9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge30sXG4gICAgICBub3RpZnlDbG9zZTogKCkgPT4ge30sXG4gICAgICBpc1J0bDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiAvKiBudW1iZXIgKi8gMCxcbiAgICB9O1xuICB9XG5cbiAgY29uc3RydWN0b3IoYWRhcHRlciwgcm9vdENzc0NsYXNzLCBhbmltYXRpbmdDc3NDbGFzcywgb3BlbkNzc0NsYXNzKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24uZGVmYXVsdEFkYXB0ZXIsIGFkYXB0ZXIpKTtcblxuICAgIHRoaXMucm9vdENzc0NsYXNzXyA9IHJvb3RDc3NDbGFzcztcbiAgICB0aGlzLmFuaW1hdGluZ0Nzc0NsYXNzXyA9IGFuaW1hdGluZ0Nzc0NsYXNzO1xuICAgIHRoaXMub3BlbkNzc0NsYXNzXyA9IG9wZW5Dc3NDbGFzcztcblxuICAgIHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpO1xuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcblxuICAgIHRoaXMuY29tcG9uZW50VG91Y2hTdGFydEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVUb3VjaFN0YXJ0XyhldnQpO1xuICAgIHRoaXMuY29tcG9uZW50VG91Y2hNb3ZlSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoTW92ZV8oZXZ0KTtcbiAgICB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8gPSAoZXZ0KSA9PiB0aGlzLmhhbmRsZVRvdWNoRW5kXyhldnQpO1xuICAgIHRoaXMuZG9jdW1lbnRLZXlkb3duSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAoZXZ0LmtleSAmJiBldnQua2V5ID09PSAnRXNjYXBlJyB8fCBldnQua2V5Q29kZSA9PT0gMjcpIHtcbiAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgfVxuICAgIH07XG4gIH1cblxuICBpbml0KCkge1xuICAgIGNvbnN0IFJPT1QgPSB0aGlzLnJvb3RDc3NDbGFzc187XG4gICAgY29uc3QgT1BFTiA9IHRoaXMub3BlbkNzc0NsYXNzXztcblxuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhST09UKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGAke1JPT1R9IGNsYXNzIHJlcXVpcmVkIGluIHJvb3QgZWxlbWVudC5gKTtcbiAgICB9XG5cbiAgICBpZiAoIXRoaXMuYWRhcHRlcl8uaGFzTmVjZXNzYXJ5RG9tKCkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgUmVxdWlyZWQgRE9NIG5vZGVzIG1pc3NpbmcgaW4gJHtST09UfSBjb21wb25lbnQuYCk7XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaGFzQ2xhc3MoT1BFTikpIHtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IHRydWU7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGV0YWJpbmF0ZV8oKTtcbiAgICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2htb3ZlJywgdGhpcy5jb21wb25lbnRUb3VjaE1vdmVIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigndG91Y2hlbmQnLCB0aGlzLmNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8pO1xuICB9XG5cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoc3RhcnQnLCB0aGlzLmNvbXBvbmVudFRvdWNoU3RhcnRIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCd0b3VjaG1vdmUnLCB0aGlzLmNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ3RvdWNoZW5kJywgdGhpcy5jb21wb25lbnRUb3VjaEVuZEhhbmRsZXJfKTtcbiAgICAvLyBEZXJlZ2lzdGVyIHRoZSBkb2N1bWVudCBrZXlkb3duIGhhbmRsZXIganVzdCBpbiBjYXNlIHRoZSBjb21wb25lbnQgaXMgZGVzdHJveWVkIHdoaWxlIHRoZSBtZW51IGlzIG9wZW4uXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgfVxuXG4gIG9wZW4oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKHRoaXMub3BlbkNzc0NsYXNzXyk7XG4gICAgdGhpcy5yZXRhYmluYXRlXygpO1xuICAgIC8vIERlYm91bmNlIG11bHRpcGxlIGNhbGxzXG4gICAgaWYgKCF0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5T3BlbigpO1xuICAgIH1cbiAgICB0aGlzLmlzT3Blbl8gPSB0cnVlO1xuICB9XG5cbiAgY2xvc2UoKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcih0aGlzLmRvY3VtZW50S2V5ZG93bkhhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXIodGhpcy50cmFuc2l0aW9uRW5kSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3ModGhpcy5hbmltYXRpbmdDc3NDbGFzc18pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3ModGhpcy5vcGVuQ3NzQ2xhc3NfKTtcbiAgICB0aGlzLmRldGFiaW5hdGVfKCk7XG4gICAgLy8gRGVib3VuY2UgbXVsdGlwbGUgY2FsbHNcbiAgICBpZiAodGhpcy5pc09wZW5fKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLm5vdGlmeUNsb3NlKCk7XG4gICAgfVxuICAgIHRoaXMuaXNPcGVuXyA9IGZhbHNlO1xuICB9XG5cbiAgaXNPcGVuKCkge1xuICAgIHJldHVybiB0aGlzLmlzT3Blbl87XG4gIH1cblxuICAvKipcbiAgICogIFJlbmRlciBhbGwgY2hpbGRyZW4gb2YgdGhlIGRyYXdlciBpbmVydCB3aGVuIGl0J3MgY2xvc2VkLlxuICAgKi9cbiAgZGV0YWJpbmF0ZV8oKSB7XG4gICAgaWYgKHRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ubWFrZUVsZW1lbnRVbnRhYmJhYmxlKGVsZW1lbnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICB0aGlzLmluZXJ0XyA9IHRydWU7XG4gIH1cblxuICAvKipcbiAgICogIE1ha2UgYWxsIGNoaWxkcmVuIG9mIHRoZSBkcmF3ZXIgdGFiYmFibGUgYWdhaW4gd2hlbiBpdCdzIG9wZW4uXG4gICAqL1xuICByZXRhYmluYXRlXygpIHtcbiAgICBpZiAoIXRoaXMuaW5lcnRfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgY29uc3QgZWxlbWVudHMgPSB0aGlzLmFkYXB0ZXJfLmdldEZvY3VzYWJsZUVsZW1lbnRzKCk7XG4gICAgaWYgKGVsZW1lbnRzKSB7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGVsZW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbGVtZW50c1tpXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5pbmVydF8gPSBmYWxzZTtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoU3RhcnRfKGV2dCkge1xuICAgIGlmICghdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyh0aGlzLm9wZW5Dc3NDbGFzc18pKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldnQucG9pbnRlclR5cGUgJiYgZXZ0LnBvaW50ZXJUeXBlICE9PSAndG91Y2gnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXJlY3Rpb25fID0gdGhpcy5hZGFwdGVyXy5pc1J0bCgpID8gLTEgOiAxO1xuICAgIHRoaXMuZHJhd2VyV2lkdGhfID0gdGhpcy5hZGFwdGVyXy5nZXREcmF3ZXJXaWR0aCgpO1xuICAgIHRoaXMuc3RhcnRYXyA9IGV2dC50b3VjaGVzID8gZXZ0LnRvdWNoZXNbMF0ucGFnZVggOiBldnQucGFnZVg7XG4gICAgdGhpcy5jdXJyZW50WF8gPSB0aGlzLnN0YXJ0WF87XG5cbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICB9XG5cbiAgaGFuZGxlVG91Y2hNb3ZlXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMuY3VycmVudFhfID0gZXZ0LnRvdWNoZXMgPyBldnQudG91Y2hlc1swXS5wYWdlWCA6IGV2dC5wYWdlWDtcbiAgfVxuXG4gIGhhbmRsZVRvdWNoRW5kXyhldnQpIHtcbiAgICBpZiAoZXZ0LnBvaW50ZXJUeXBlICYmIGV2dC5wb2ludGVyVHlwZSAhPT0gJ3RvdWNoJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJlcGFyZUZvclRvdWNoRW5kXygpO1xuXG4gICAgLy8gRGlkIHRoZSB1c2VyIGNsb3NlIHRoZSBkcmF3ZXIgYnkgbW9yZSB0aGFuIDUwJT9cbiAgICBpZiAoTWF0aC5hYnModGhpcy5uZXdQb3NpdGlvbl8gLyB0aGlzLmRyYXdlcldpZHRoXykgPj0gMC41KSB7XG4gICAgICB0aGlzLmNsb3NlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRyaWdnZXJpbmcgYW4gb3BlbiBoZXJlIG1lYW5zIHdlJ2xsIGdldCBhIG5pY2UgYW5pbWF0aW9uIGJhY2sgdG8gdGhlIGZ1bGx5IG9wZW4gc3RhdGUuXG4gICAgICB0aGlzLm9wZW4oKTtcbiAgICB9XG4gIH1cblxuICBwcmVwYXJlRm9yVG91Y2hFbmRfKCkge1xuICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMudXBkYXRlUmFmXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRUcmFuc2xhdGVYKG51bGwpO1xuICB9XG5cbiAgdXBkYXRlRHJhd2VyXygpIHtcbiAgICB0aGlzLnVwZGF0ZVJhZl8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy51cGRhdGVEcmF3ZXJfLmJpbmQodGhpcykpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0VHJhbnNsYXRlWCh0aGlzLm5ld1Bvc2l0aW9uXyk7XG4gIH1cblxuICBnZXQgbmV3UG9zaXRpb25fKCkge1xuICAgIGxldCBuZXdQb3MgPSBudWxsO1xuXG4gICAgaWYgKHRoaXMuZGlyZWN0aW9uXyA9PT0gMSkge1xuICAgICAgbmV3UG9zID0gTWF0aC5taW4oMCwgdGhpcy5jdXJyZW50WF8gLSB0aGlzLnN0YXJ0WF8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBuZXdQb3MgPSBNYXRoLm1heCgwLCB0aGlzLmN1cnJlbnRYXyAtIHRoaXMuc3RhcnRYXyk7XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld1BvcztcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIHRydWUgb3IgZmFsc2VcbiAgICAvLyBpZiB0aGUgZXZlbnQgdGFyZ2V0IGlzIHRoZSByb290IGV2ZW50IHRhcmdldCBjdXJyZW50bHkgdHJhbnNpdGlvbmluZy5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBoYW5kbGVUcmFuc2l0aW9uRW5kXyhldnQpIHtcbiAgICBpZiAodGhpcy5pc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfKGV2dC50YXJnZXQpKSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKHRoaXMuYW5pbWF0aW5nQ3NzQ2xhc3NfKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyKHRoaXMudHJhbnNpdGlvbkVuZEhhbmRsZXJfKTtcbiAgICB9XG4gIH07XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5leHBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi9jb25zdGFudHMnO1xuZXhwb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4vZm91bmRhdGlvbic7XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge0ZPQ1VTQUJMRV9FTEVNRU5UU30gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuXG5leHBvcnQgY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgUk9PVDogJ21kYy1kcmF3ZXItLXBlcnNpc3RlbnQnLFxuICBPUEVOOiAnbWRjLWRyYXdlci0tb3BlbicsXG4gIEFOSU1BVElORzogJ21kYy1kcmF3ZXItLWFuaW1hdGluZycsXG59O1xuXG5leHBvcnQgY29uc3Qgc3RyaW5ncyA9IHtcbiAgRFJBV0VSX1NFTEVDVE9SOiAnLm1kYy1kcmF3ZXItLXBlcnNpc3RlbnQgLm1kYy1kcmF3ZXJfX2RyYXdlcicsXG4gIEZPQ1VTQUJMRV9FTEVNRU5UUyxcbiAgT1BFTl9FVkVOVDogJ01EQ1BlcnNpc3RlbnREcmF3ZXI6b3BlbicsXG4gIENMT1NFX0VWRU5UOiAnTURDUGVyc2lzdGVudERyYXdlcjpjbG9zZScsXG59O1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb259IGZyb20gJy4uL3NsaWRhYmxlL2luZGV4JztcbmltcG9ydCB7Y3NzQ2xhc3Nlcywgc3RyaW5nc30gZnJvbSAnLi9jb25zdGFudHMnO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiBleHRlbmRzIE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCB7XG4gICAgICBpc0RyYXdlcjogKCkgPT4gZmFsc2UsXG4gICAgfSk7XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoXG4gICAgICBPYmplY3QuYXNzaWduKE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUk9PVCxcbiAgICAgIE1EQ1BlcnNpc3RlbnREcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuQU5JTUFUSU5HLFxuICAgICAgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5PUEVOKTtcbiAgfVxuXG4gIGlzUm9vdFRyYW5zaXRpb25pbmdFdmVudFRhcmdldF8oZWwpIHtcbiAgICByZXR1cm4gdGhpcy5hZGFwdGVyXy5pc0RyYXdlcihlbCk7XG4gIH1cbn1cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmNvbnN0IFRBQl9EQVRBID0gJ2RhdGEtbWRjLXRhYmluZGV4JztcbmNvbnN0IFRBQl9EQVRBX0hBTkRMRUQgPSAnZGF0YS1tZGMtdGFiaW5kZXgtaGFuZGxlZCc7XG5cbmxldCBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfO1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8vIFJlbWFwIHRvdWNoIGV2ZW50cyB0byBwb2ludGVyIGV2ZW50cywgaWYgdGhlIGJyb3dzZXIgZG9lc24ndCBzdXBwb3J0IHRvdWNoIGV2ZW50cy5cbmV4cG9ydCBmdW5jdGlvbiByZW1hcEV2ZW50KGV2ZW50TmFtZSwgZ2xvYmFsT2JqID0gd2luZG93KSB7XG4gIGlmICghKCdvbnRvdWNoc3RhcnQnIGluIGdsb2JhbE9iai5kb2N1bWVudCkpIHtcbiAgICBzd2l0Y2ggKGV2ZW50TmFtZSkge1xuICAgIGNhc2UgJ3RvdWNoc3RhcnQnOlxuICAgICAgcmV0dXJuICdwb2ludGVyZG93bic7XG4gICAgY2FzZSAndG91Y2htb3ZlJzpcbiAgICAgIHJldHVybiAncG9pbnRlcm1vdmUnO1xuICAgIGNhc2UgJ3RvdWNoZW5kJzpcbiAgICAgIHJldHVybiAncG9pbnRlcnVwJztcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIGV2ZW50TmFtZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZXZlbnROYW1lO1xufVxuXG4vLyBDaG9vc2UgdGhlIGNvcnJlY3QgdHJhbnNmb3JtIHByb3BlcnR5IHRvIHVzZSBvbiB0aGUgY3VycmVudCBicm93c2VyLlxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyYW5zZm9ybVByb3BlcnR5TmFtZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgY29uc3QgZWwgPSBnbG9iYWxPYmouZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgY29uc3QgdHJhbnNmb3JtUHJvcGVydHlOYW1lID0gKCd0cmFuc2Zvcm0nIGluIGVsLnN0eWxlID8gJ3RyYW5zZm9ybScgOiAnLXdlYmtpdC10cmFuc2Zvcm0nKTtcbiAgICBzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfID0gdHJhbnNmb3JtUHJvcGVydHlOYW1lO1xuICB9XG5cbiAgcmV0dXJuIHN0b3JlZFRyYW5zZm9ybVByb3BlcnR5TmFtZV87XG59XG5cbi8vIERldGVybWluZSB3aGV0aGVyIHRoZSBjdXJyZW50IGJyb3dzZXIgc3VwcG9ydHMgQ1NTIHByb3BlcnRpZXMuXG5leHBvcnQgZnVuY3Rpb24gc3VwcG9ydHNDc3NDdXN0b21Qcm9wZXJ0aWVzKGdsb2JhbE9iaiA9IHdpbmRvdykge1xuICBpZiAoJ0NTUycgaW4gZ2xvYmFsT2JqKSB7XG4gICAgcmV0dXJuIGdsb2JhbE9iai5DU1Muc3VwcG9ydHMoJygtLWNvbG9yOiByZWQpJyk7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG4vLyBEZXRlcm1pbmUgd2hldGhlciB0aGUgY3VycmVudCBicm93c2VyIHN1cHBvcnRzIHBhc3NpdmUgZXZlbnQgbGlzdGVuZXJzLCBhbmQgaWYgc28sIHVzZSB0aGVtLlxuZXhwb3J0IGZ1bmN0aW9uIGFwcGx5UGFzc2l2ZShnbG9iYWxPYmogPSB3aW5kb3csIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGlmIChzdXBwb3J0c1Bhc3NpdmVfID09PSB1bmRlZmluZWQgfHwgZm9yY2VSZWZyZXNoKSB7XG4gICAgbGV0IGlzU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdHJ5IHtcbiAgICAgIGdsb2JhbE9iai5kb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCd0ZXN0JywgbnVsbCwge2dldCBwYXNzaXZlKCkge1xuICAgICAgICBpc1N1cHBvcnRlZCA9IHRydWU7XG4gICAgICB9fSk7XG4gICAgfSBjYXRjaCAoZSkgeyB9XG5cbiAgICBzdXBwb3J0c1Bhc3NpdmVfID0gaXNTdXBwb3J0ZWQ7XG4gIH1cblxuICByZXR1cm4gc3VwcG9ydHNQYXNzaXZlXyA/IHtwYXNzaXZlOiB0cnVlfSA6IGZhbHNlO1xufVxuXG4vLyBTYXZlIHRoZSB0YWIgc3RhdGUgZm9yIGFuIGVsZW1lbnQuXG5leHBvcnQgZnVuY3Rpb24gc2F2ZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICBpZiAoZWwuaGFzQXR0cmlidXRlKCd0YWJpbmRleCcpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKFRBQl9EQVRBLCBlbC5nZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JykpO1xuICB9XG4gIGVsLnNldEF0dHJpYnV0ZShUQUJfREFUQV9IQU5ETEVELCB0cnVlKTtcbn1cblxuLy8gUmVzdG9yZSB0aGUgdGFiIHN0YXRlIGZvciBhbiBlbGVtZW50LCBpZiBpdCB3YXMgc2F2ZWQuXG5leHBvcnQgZnVuY3Rpb24gcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbCkge1xuICAvLyBPbmx5IG1vZGlmeSBlbGVtZW50cyB3ZSd2ZSBhbHJlYWR5IGhhbmRsZWQsIGluIGNhc2UgYW55dGhpbmcgd2FzIGR5bmFtaWNhbGx5IGFkZGVkIHNpbmNlIHdlIHNhdmVkIHN0YXRlLlxuICBpZiAoZWwuaGFzQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpKSB7XG4gICAgaWYgKGVsLmhhc0F0dHJpYnV0ZShUQUJfREFUQSkpIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBlbC5nZXRBdHRyaWJ1dGUoVEFCX0RBVEEpKTtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZShUQUJfREFUQSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgndGFiaW5kZXgnKTtcbiAgICB9XG4gICAgZWwucmVtb3ZlQXR0cmlidXRlKFRBQl9EQVRBX0hBTkRMRUQpO1xuICB9XG59XG4iLCI8dGVtcGxhdGU+XG4gIDxhc2lkZSBjbGFzcz1cIm1kYy1wZXJzaXN0ZW50LWRyYXdlciBtZGMtZHJhd2VyLS1wZXJzaXN0ZW50IG1kYy10eXBvZ3JhcGh5XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxuYXYgcmVmPVwiZHJhd2VyXCIgY2xhc3M9XCJtZGMtZHJhd2VyX19kcmF3ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiIFxuICAgICAgICB2LWlmPVwidG9vbGJhclNwYWNlclwiPjwvZGl2PlxuICAgICAgPHNsb3QgLz5cbiAgICA8L25hdj5cbiAgPC9hc2lkZT5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2RyYXdlci9wZXJzaXN0ZW50L2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJyxcbiAgbW9kZWw6IHtcbiAgICBwcm9wOiAnb3BlbicsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnXG4gIH0sXG4gIHByb3BzOiB7XG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgICAnb3Blbic6Qm9vbGVhblxuICB9LFxuICBkYXRhICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge30sXG4gICAgfVxuICB9LFxuICB3YXRjaDoge1xuICAgIG9wZW4oKSB7XG4gICAgICB0aGlzLl9yZWZyZXNoKClcbiAgICB9XG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBfcmVmcmVzaCgpIHtcbiAgICAgIGlmICh0aGlzLm9wZW4pIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5vcGVuKCkgICAgICAgICAgXG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5jbG9zZSgpICAgICAgICAgIFxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgY29uc3Qge0ZPQ1VTQUJMRV9FTEVNRU5UU30gPSBNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbi5zdHJpbmdzXG5cbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDUGVyc2lzdGVudERyYXdlckZvdW5kYXRpb24oe1xuICAgICAgYWRkQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHRoaXMuJGRlbGV0ZSh0aGlzLmNsYXNzZXMsIGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICByZXR1cm4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSlcbiAgICAgIH0sXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6ICh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICB1dGlsLmdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIHZhbHVlID09PSBudWxsID8gbnVsbCA6IGB0cmFuc2xhdGVYKCR7dmFsdWV9cHgpYFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgfSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6IChlbCkgPT4ge1xuICAgICAgICB1dGlsLnNhdmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6IChlbCkgPT4ge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG4gICAgICBpc1J0bDogKCkgPT4ge1xuICAgICAgICAvKiBnbG9iYWwgZ2V0Q29tcHV0ZWRTdHlsZSAqL1xuICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnXG4gICAgICB9LFxuICAgICAgaXNEcmF3ZXI6IChlbCkgPT4ge1xuICAgICAgICByZXR1cm4gZWwgPT09IHRoaXMuJHJlZnMuZHJhd2VyXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmluaXQoKSAgXG4gICAgdGhpcy5fcmVmcmVzaCgpXG4gIH0sXG4gIGJlZm9yZURlc3Ryb3kgKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uZGVzdHJveSgpXG4gICAgdGhpcy5mb3VuZGF0aW9uID0gbnVsbFxuICB9XG59XG48L3NjcmlwdD5cbiIsIi8qKlxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbmltcG9ydCB7Rk9DVVNBQkxFX0VMRU1FTlRTfSBmcm9tICcuLi9zbGlkYWJsZS9pbmRleCc7XG5cbmV4cG9ydCBjb25zdCBjc3NDbGFzc2VzID0ge1xuICBST09UOiAnbWRjLWRyYXdlci0tdGVtcG9yYXJ5JyxcbiAgT1BFTjogJ21kYy1kcmF3ZXItLW9wZW4nLFxuICBBTklNQVRJTkc6ICdtZGMtZHJhd2VyLS1hbmltYXRpbmcnLFxuICBTQ1JPTExfTE9DSzogJ21kYy1kcmF3ZXItc2Nyb2xsLWxvY2snLFxufTtcblxuZXhwb3J0IGNvbnN0IHN0cmluZ3MgPSB7XG4gIERSQVdFUl9TRUxFQ1RPUjogJy5tZGMtZHJhd2VyLS10ZW1wb3JhcnkgLm1kYy1kcmF3ZXJfX2RyYXdlcicsXG4gIE9QQUNJVFlfVkFSX05BTUU6ICctLW1kYy10ZW1wb3JhcnktZHJhd2VyLW9wYWNpdHknLFxuICBGT0NVU0FCTEVfRUxFTUVOVFMsXG4gIE9QRU5fRVZFTlQ6ICdNRENUZW1wb3JhcnlEcmF3ZXI6b3BlbicsXG4gIENMT1NFX0VWRU5UOiAnTURDVGVtcG9yYXJ5RHJhd2VyOmNsb3NlJyxcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQge01EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbn0gZnJvbSAnLi4vc2xpZGFibGUvaW5kZXgnO1xuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENTbGlkYWJsZURyYXdlckZvdW5kYXRpb24ge1xuICBzdGF0aWMgZ2V0IGNzc0NsYXNzZXMoKSB7XG4gICAgcmV0dXJuIGNzc0NsYXNzZXM7XG4gIH1cblxuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgcmV0dXJuIHN0cmluZ3M7XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE1EQ1NsaWRhYmxlRHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwge1xuICAgICAgYWRkQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQm9keUNsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgaXNEcmF3ZXI6ICgpID0+IGZhbHNlLFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICgvKiB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGV2ZW50VGFyZ2V0SGFzQ2xhc3M6ICgvKiB0YXJnZXQ6IEV2ZW50VGFyZ2V0LCBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIGNvbnN0cnVjdG9yKGFkYXB0ZXIpIHtcbiAgICBzdXBlcihcbiAgICAgIE9iamVjdC5hc3NpZ24oTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlciksXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuUk9PVCxcbiAgICAgIE1EQ1RlbXBvcmFyeURyYXdlckZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5BTklNQVRJTkcsXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLmNzc0NsYXNzZXMuT1BFTik7XG5cbiAgICB0aGlzLmNvbXBvbmVudENsaWNrSGFuZGxlcl8gPSAoZXZ0KSA9PiB7XG4gICAgICBpZiAodGhpcy5hZGFwdGVyXy5ldmVudFRhcmdldEhhc0NsYXNzKGV2dC50YXJnZXQsIGNzc0NsYXNzZXMuUk9PVCkpIHtcbiAgICAgICAgdGhpcy5jbG9zZSh0cnVlKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgaW5pdCgpIHtcbiAgICBzdXBlci5pbml0KCk7XG5cbiAgICAvLyBNYWtlIGJyb3dzZXIgYXdhcmUgb2YgY3VzdG9tIHByb3BlcnR5IGJlaW5nIHVzZWQgaW4gdGhpcyBlbGVtZW50LlxuICAgIC8vIFdvcmthcm91bmQgZm9yIGNlcnRhaW4gdHlwZXMgb2YgaGFyZC10by1yZXByb2R1Y2UgaGVpc2VuYnVncy5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKDApO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2NsaWNrJywgdGhpcy5jb21wb25lbnRDbGlja0hhbmRsZXJfKTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgc3VwZXIuZGVzdHJveSgpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdjbGljaycsIHRoaXMuY29tcG9uZW50Q2xpY2tIYW5kbGVyXyk7XG4gICAgdGhpcy5lbmFibGVTY3JvbGxfKCk7XG4gIH1cblxuICBvcGVuKCkge1xuICAgIHRoaXMuZGlzYWJsZVNjcm9sbF8oKTtcbiAgICAvLyBNYWtlIHN1cmUgY3VzdG9tIHByb3BlcnR5IHZhbHVlcyBhcmUgY2xlYXJlZCBiZWZvcmUgc3RhcnRpbmcuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG5cbiAgICBzdXBlci5vcGVuKCk7XG4gIH1cblxuICBjbG9zZSgpIHtcbiAgICAvLyBNYWtlIHN1cmUgY3VzdG9tIHByb3BlcnR5IHZhbHVlcyBhcmUgY2xlYXJlZCBiZWZvcmUgbWFraW5nIGFueSBjaGFuZ2VzLlxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoJycpO1xuXG4gICAgc3VwZXIuY2xvc2UoKTtcbiAgfVxuXG4gIHByZXBhcmVGb3JUb3VjaEVuZF8oKSB7XG4gICAgc3VwZXIucHJlcGFyZUZvclRvdWNoRW5kXygpO1xuXG4gICAgdGhpcy5hZGFwdGVyXy51cGRhdGVDc3NWYXJpYWJsZSgnJyk7XG4gIH1cblxuICB1cGRhdGVEcmF3ZXJfKCkge1xuICAgIHN1cGVyLnVwZGF0ZURyYXdlcl8oKTtcblxuICAgIGNvbnN0IG5ld09wYWNpdHkgPSBNYXRoLm1heCgwLCAxICsgdGhpcy5kaXJlY3Rpb25fICogKHRoaXMubmV3UG9zaXRpb25fIC8gdGhpcy5kcmF3ZXJXaWR0aF8pKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKG5ld09wYWNpdHkpO1xuICB9XG5cbiAgaXNSb290VHJhbnNpdGlvbmluZ0V2ZW50VGFyZ2V0XyhlbCkge1xuICAgIHJldHVybiB0aGlzLmFkYXB0ZXJfLmlzRHJhd2VyKGVsKTtcbiAgfVxuXG4gIGhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCkge1xuICAgIHN1cGVyLmhhbmRsZVRyYW5zaXRpb25FbmRfKGV2dCk7XG4gICAgaWYgKCF0aGlzLmlzT3Blbl8pIHtcbiAgICAgIHRoaXMuZW5hYmxlU2Nyb2xsXygpO1xuICAgIH1cbiAgfTtcblxuICBkaXNhYmxlU2Nyb2xsXygpIHtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZEJvZHlDbGFzcyhjc3NDbGFzc2VzLlNDUk9MTF9MT0NLKTtcbiAgfVxuXG4gIGVuYWJsZVNjcm9sbF8oKSB7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVCb2R5Q2xhc3MoY3NzQ2xhc3Nlcy5TQ1JPTExfTE9DSyk7XG4gIH1cbn1cbiIsIjx0ZW1wbGF0ZT5cbiAgPGFzaWRlIGNsYXNzPVwibWRjLXRlbXBvcmFyeS1kcmF3ZXIgbWRjLWRyYXdlci0tdGVtcG9yYXJ5IG1kYy10eXBvZ3JhcGh5XCIgOmNsYXNzPVwiY2xhc3Nlc1wiPlxuICAgIDxuYXYgcmVmPVwiZHJhd2VyXCIgY2xhc3M9XCJtZGMtZHJhd2VyX19kcmF3ZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtZHJhd2VyX190b29sYmFyLXNwYWNlclwiIHYtaWY9XCJ0b29sYmFyU3BhY2VyXCI+PC9kaXY+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvbmF2PlxuICA8L2FzaWRlPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmltcG9ydCBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdGVtcG9yYXJ5L2ZvdW5kYXRpb24nXG5pbXBvcnQgKiBhcyB1dGlsIGZyb20gJ0BtYXRlcmlhbC9kcmF3ZXIvdXRpbCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICBuYW1lOiAnbWRjLXRlbXBvcmFyeS1kcmF3ZXInLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICdvcGVuJyxcbiAgICBldmVudDogJ2NoYW5nZSdcbiAgfSxcbiAgcHJvcHM6IHtcbiAgICAnb3Blbic6IEJvb2xlYW4sXG4gICAgJ3Rvb2xiYXItc3BhY2VyJzogQm9vbGVhbixcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgIH1cbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICBvcGVuKCkge1xuICAgICAgdGhpcy5fcmVmcmVzaCgpXG4gICAgfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgX3JlZnJlc2goKSB7XG4gICAgICBpZiAodGhpcy5vcGVuKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ub3BlbigpICAgICAgICAgIFxuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24uY2xvc2UoKSAgICAgICAgICBcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIGNvbnN0IHtGT0NVU0FCTEVfRUxFTUVOVFMsIE9QQUNJVFlfVkFSX05BTUV9ID0gXG4gICAgICBNRENUZW1wb3JhcnlEcmF3ZXJGb3VuZGF0aW9uLnN0cmluZ3NcbiAgICBcbiAgICB0aGlzLmZvdW5kYXRpb24gPSBuZXcgTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbih7XG4gICAgICBhZGRDbGFzczogKGNsYXNzTmFtZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5jbGFzc2VzLCBjbGFzc05hbWUsIHRydWUpXG4gICAgICB9LFxuICAgICAgcmVtb3ZlQ2xhc3M6IChjbGFzc05hbWUpID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGhhc0NsYXNzOiAoY2xhc3NOYW1lKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRlbC5jbGFzc0xpc3QuY29udGFpbnMoY2xhc3NOYW1lKVxuICAgICAgfSxcbiAgICAgIGFkZEJvZHlDbGFzczogKGNsYXNzTmFtZSkgPT4gZG9jdW1lbnQuYm9keS5jbGFzc0xpc3QuYWRkKGNsYXNzTmFtZSksXG4gICAgICByZW1vdmVCb2R5Q2xhc3M6IChjbGFzc05hbWUpID0+IGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LnJlbW92ZShjbGFzc05hbWUpLFxuICAgICAgZXZlbnRUYXJnZXRIYXNDbGFzczogKHRhcmdldCwgY2xhc3NOYW1lKSA9PiB0YXJnZXQuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBoYXNOZWNlc3NhcnlEb206ICgpID0+IHtcbiAgICAgICAgcmV0dXJuICEhdGhpcy4kcmVmcy5kcmF3ZXJcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyLCB1dGlsLmFwcGx5UGFzc2l2ZSgpKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlciwgdXRpbC5hcHBseVBhc3NpdmUoKSlcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckRyYXdlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKHV0aWwucmVtYXBFdmVudChldnQpLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXI6IChldnQsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kcmVmcy5kcmF3ZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih1dGlsLnJlbWFwRXZlbnQoZXZ0KSwgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICByZWdpc3RlclRyYW5zaXRpb25FbmRIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5hZGRFdmVudExpc3RlbmVyKCd0cmFuc2l0aW9uZW5kJywgaGFuZGxlcilcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVHJhbnNpdGlvbkVuZEhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMuZHJhd2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3RyYW5zaXRpb25lbmQnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcigna2V5ZG93bicsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50S2V5ZG93bkhhbmRsZXI6IChoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2tleWRvd24nLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGdldERyYXdlcldpZHRoOiAoKSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLiRyZWZzLmRyYXdlci5vZmZzZXRXaWR0aFxuICAgICAgfSxcbiAgICAgIHNldFRyYW5zbGF0ZVg6ICh2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRyZWZzLmRyYXdlci5zdHlsZS5zZXRQcm9wZXJ0eShcbiAgICAgICAgICB1dGlsLmdldFRyYW5zZm9ybVByb3BlcnR5TmFtZSgpLFxuICAgICAgICAgIHZhbHVlID09PSBudWxsID8gbnVsbCA6IGB0cmFuc2xhdGVYKCR7dmFsdWV9cHgpYFxuICAgICAgICApXG4gICAgICB9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBpZiAodXRpbC5zdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMoKSkge1xuICAgICAgICAgIHRoaXMuJGVsLnN0eWxlLnNldFByb3BlcnR5KE9QQUNJVFlfVkFSX05BTUUsIHZhbHVlKVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgZ2V0Rm9jdXNhYmxlRWxlbWVudHM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHRoaXMuJHJlZnMuZHJhd2VyLnF1ZXJ5U2VsZWN0b3JBbGwoRk9DVVNBQkxFX0VMRU1FTlRTKVxuICAgICAgfSxcbiAgICAgIHNhdmVFbGVtZW50VGFiU3RhdGU6IChlbCkgPT4ge1xuICAgICAgICB1dGlsLnNhdmVFbGVtZW50VGFiU3RhdGUoZWwpXG4gICAgICB9LFxuICAgICAgcmVzdG9yZUVsZW1lbnRUYWJTdGF0ZTogKGVsKSA9PiB7XG4gICAgICAgIHV0aWwucmVzdG9yZUVsZW1lbnRUYWJTdGF0ZShlbClcbiAgICAgIH0sXG4gICAgICBtYWtlRWxlbWVudFVudGFiYmFibGU6IChlbCkgPT4ge1xuICAgICAgICBlbC5zZXRBdHRyaWJ1dGUoJ3RhYmluZGV4JywgLTEpXG4gICAgICB9LFxuICAgICAgbm90aWZ5T3BlbjogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdjaGFuZ2UnLHRydWUpXG4gICAgICAgIHRoaXMuJGVtaXQoJ29wZW4nKVxuICAgICAgfSxcbiAgICAgIG5vdGlmeUNsb3NlOiAoKSA9PiB7XG4gICAgICAgIHRoaXMuJGVtaXQoJ2NoYW5nZScsZmFsc2UpXG4gICAgICAgIHRoaXMuJGVtaXQoJ2Nsb3NlJylcbiAgICAgIH0sXG4gICAgICBpc1J0bDogKCkgPT4ge1xuICAgICAgICAvKiBnbG9iYWwgZ2V0Q29tcHV0ZWRTdHlsZSAqL1xuICAgICAgICByZXR1cm4gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLiRlbCkuZ2V0UHJvcGVydHlWYWx1ZSgnZGlyZWN0aW9uJykgPT09ICdydGwnXG4gICAgICB9LFxuICAgICAgaXNEcmF3ZXI6IChlbCkgPT4gZWwgPT09IHRoaXMuJHJlZnMuZHJhd2VyLFxuICAgIH0pXG4gICAgdGhpcy5mb3VuZGF0aW9uICYmIHRoaXMuZm91bmRhdGlvbi5pbml0KCkgIFxuICAgIHRoaXMuX3JlZnJlc2goKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLmZvdW5kYXRpb24gJiYgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKVxuICAgIHRoaXMuZm91bmRhdGlvbiA9IG51bGxcbiAgfVxufVxuPC9zY3JpcHQ+XG4iLCJsZXQgYnVzXztcblxuZXhwb3J0IGNvbnN0IGV2ZW50QnVzID0ge1xuICBpbnN0YWxsKHZ1ZSkge1xuICAgIGJ1c18gPSBuZXcgdnVlKCk7XG4gIH0sXG4gICRlbWl0KGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgYnVzXyAmJiBidXNfLiRlbWl0KGV2ZW50LCAuLi5hcmdzKTtcbiAgfSxcbiAgJG9uKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGJ1c18gJiYgYnVzXy4kb24oZXZlbnQsIGNhbGxiYWNrKTtcbiAgfSxcbiAgJG9uY2UoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgYnVzXyAmJiBidXNfLiRvbmNlKGV2ZW50LCBjYWxsYmFjayk7XG4gIH0sXG4gICRvZmYoZXZlbnQsIGNhbGxiYWNrKSB7XG4gICAgYnVzXyAmJiBidXNfLiRvZmYoZXZlbnQsIGNhbGxiYWNrKTtcbiAgfSxcbn07XG4iLCI8dGVtcGxhdGU+XHJcbiAgPGNvbXBvbmVudCAgcmVmPVwiZHJhd2VyXCIgY2xhc3M9XCJtZGMtZHJhd2VyXCJcclxuICAgICAgOmlzPVwidHlwZVwiIHYtbW9kZWw9XCJvcGVuX1wiXHJcbiAgICAgIDp0b29sYmFyLXNwYWNlcj1cInRvb2xiYXJTcGFjZXJcIlxyXG4gICAgICBAY2hhbmdlPVwiYnVzZW1pdCgnbWRjOmxheW91dCcpXCJcclxuICAgICAgQG9wZW49XCIkZW1pdCgnb3BlbicpXCJcclxuICAgICAgQGNsb3NlPVwiJGVtaXQoJ2Nsb3NlJylcIiA+XHJcbiAgICA8c2xvdCAvPlxyXG4gIDwvY29tcG9uZW50PlxyXG48L3RlbXBsYXRlPlxyXG5cclxuPHNjcmlwdD5cclxuaW1wb3J0IG1kY1Blcm1hbmVudERyYXdlciBmcm9tICcuL21kYy1wZXJtYW5lbnQtZHJhd2VyLnZ1ZSc7XHJcbmltcG9ydCBtZGNQZXJzaXN0ZW50RHJhd2VyIGZyb20gJy4vbWRjLXBlcnNpc3RlbnQtZHJhd2VyLnZ1ZSc7XHJcbmltcG9ydCBtZGNUZW1wb3JhcnlEcmF3ZXIgZnJvbSAnLi9tZGMtdGVtcG9yYXJ5LWRyYXdlci52dWUnO1xyXG5pbXBvcnQgeyBldmVudEJ1cyB9IGZyb20gJy4uL2NvbW1vbic7XHJcblxyXG5jb25zdCBtZWRpYSA9IG5ldyBjbGFzcyB7XHJcbiAgZ2V0IHNtYWxsKCkge1xyXG4gICAgcmV0dXJuIChcclxuICAgICAgdGhpcy5fc21hbGwgfHwgKHRoaXMuX3NtYWxsID0gd2luZG93Lm1hdGNoTWVkaWEoJyhtYXgtd2lkdGg6IDgzOXB4KScpKVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIGdldCBsYXJnZSgpIHtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIHRoaXMuX2xhcmdlIHx8ICh0aGlzLl9sYXJnZSA9IHdpbmRvdy5tYXRjaE1lZGlhKCcobWluLXdpZHRoOiAxMjAwcHgpJykpXHJcbiAgICApO1xyXG4gIH1cclxufSgpO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQge1xyXG4gIG5hbWU6ICdtZGMtZHJhd2VyJyxcclxuICBwcm9wczoge1xyXG4gICAgcGVybWFuZW50OiBCb29sZWFuLFxyXG4gICAgcGVyc2lzdGVudDogQm9vbGVhbixcclxuICAgIHRlbXBvcmFyeTogQm9vbGVhbixcclxuICAgIGRyYXdlclR5cGU6IHtcclxuICAgICAgdHlwZTogU3RyaW5nLFxyXG4gICAgICB2YWxpZGF0b3I6IHZhbCA9PiB7XHJcbiAgICAgICAgcmV0dXJuIHZhbCBpbiBbJ3RlbXBvcmFyeScsICdwZXJzaXN0ZW50JywgJ3Blcm1hbmVudCddO1xyXG4gICAgICB9LFxyXG4gICAgfSxcclxuICAgIHRvb2xiYXJTcGFjZXI6IEJvb2xlYW4sXHJcbiAgICB0b2dnbGVPbjogU3RyaW5nLFxyXG4gICAgdG9nZ2xlT25Tb3VyY2U6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2UgfSxcclxuICAgIG9wZW5PbjogU3RyaW5nLFxyXG4gICAgb3Blbk9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH0sXHJcbiAgICBjbG9zZU9uOiBTdHJpbmcsXHJcbiAgICBjbG9zZU9uU291cmNlOiB7IHR5cGU6IE9iamVjdCwgcmVxdWlyZWQ6IGZhbHNlIH0sXHJcbiAgfSxcclxuICBwcm92aWRlKCkge1xyXG4gICAgcmV0dXJuIHsgbWRjRHJhd2VyOiB0aGlzIH07XHJcbiAgfSxcclxuICBkYXRhKCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgc21hbGw6IGZhbHNlLFxyXG4gICAgICBsYXJnZTogZmFsc2UsXHJcbiAgICAgIG9wZW5fOiBmYWxzZSxcclxuICAgIH07XHJcbiAgfSxcclxuICBjb21wb25lbnRzOiB7XHJcbiAgICAnbWRjLXBlcm1hbmVudC1kcmF3ZXInOiBtZGNQZXJtYW5lbnREcmF3ZXIsXHJcbiAgICAnbWRjLXBlcnNpc3RlbnQtZHJhd2VyJzogbWRjUGVyc2lzdGVudERyYXdlcixcclxuICAgICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic6IG1kY1RlbXBvcmFyeURyYXdlcixcclxuICB9LFxyXG4gIGNvbXB1dGVkOiB7XHJcbiAgICB0eXBlKCkge1xyXG4gICAgICBpZiAodGhpcy5wZXJtYW5lbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJtYW5lbnQtZHJhd2VyJztcclxuICAgICAgfSBlbHNlIGlmICh0aGlzLnBlcnNpc3RlbnQpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic7XHJcbiAgICAgIH0gZWxzZSBpZiAodGhpcy50ZW1wb3JhcnkpIHtcclxuICAgICAgICByZXR1cm4gJ21kYy10ZW1wb3JhcnktZHJhd2VyJztcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMuZHJhd2VyVHlwZSkge1xyXG4gICAgICAgICAgY2FzZSAncGVybWFuZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVybWFuZW50LWRyYXdlcic7XHJcbiAgICAgICAgICBjYXNlICdwZXJzaXN0ZW50JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtcGVyc2lzdGVudC1kcmF3ZXInO1xyXG4gICAgICAgICAgY2FzZSAndGVtcG9yYXJ5JzpcclxuICAgICAgICAgICAgcmV0dXJuICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic7XHJcbiAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5zbWFsbFxyXG4gICAgICAgICAgICAgID8gJ21kYy10ZW1wb3JhcnktZHJhd2VyJ1xyXG4gICAgICAgICAgICAgIDogJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gICAgaXNQZXJtYW5lbnQoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBlcm1hbmVudCB8fCB0aGlzLnR5cGUgPT09ICdtZGMtcGVybWFuZW50LWRyYXdlcic7XHJcbiAgICB9LFxyXG4gICAgaXNQZXJzaXN0ZW50KCkge1xyXG4gICAgICByZXR1cm4gdGhpcy5wZXJzaXN0ZW50IHx8IHRoaXMudHlwZSA9PT0gJ21kYy1wZXJzaXN0ZW50LWRyYXdlcic7XHJcbiAgICB9LFxyXG4gICAgaXNUZW1wb3JhcnkoKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnR5cGUgPT09ICdtZGMtdGVtcG9yYXJ5LWRyYXdlcic7XHJcbiAgICB9LFxyXG4gICAgaXNSZXNwb25zaXZlKCkge1xyXG4gICAgICByZXR1cm4gIShcclxuICAgICAgICB0aGlzLnBlcm1hbmVudCB8fFxyXG4gICAgICAgIHRoaXMucGVyc2lzdGVudCB8fFxyXG4gICAgICAgIHRoaXMudGVtcG9yYXJ5IHx8XHJcbiAgICAgICAgdGhpcy5kcmF3ZXJUeXBlXHJcbiAgICAgICk7XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgbWV0aG9kczoge1xyXG4gICAgYnVzZW1pdChldmVudCkge1xyXG4gICAgICBldmVudEJ1cy4kZW1pdChldmVudCk7XHJcbiAgICB9LFxyXG4gICAgb3BlbigpIHtcclxuICAgICAgdGhpcy5vcGVuXyA9IHRydWU7XHJcbiAgICB9LFxyXG4gICAgY2xvc2UoKSB7XHJcbiAgICAgIHRoaXMuaXNQZXJtYW5lbnQgfHwgKHRoaXMub3Blbl8gPSBmYWxzZSk7XHJcbiAgICB9LFxyXG4gICAgdG9nZ2xlKCkge1xyXG4gICAgICB0aGlzLmlzUGVybWFuZW50IHx8ICh0aGlzLmlzT3BlbigpID8gdGhpcy5jbG9zZSgpIDogdGhpcy5vcGVuKCkpO1xyXG4gICAgfSxcclxuICAgIGlzT3BlbigpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuaXNQZXJtYW5lbnQgfHwgdGhpcy5vcGVuXztcclxuICAgIH0sXHJcbiAgICByZWZyZXNoTWVkaWEoKSB7XHJcbiAgICAgIHRoaXMuc21hbGwgPSBtZWRpYS5zbWFsbC5tYXRjaGVzO1xyXG4gICAgICB0aGlzLmxhcmdlID0gbWVkaWEubGFyZ2UubWF0Y2hlcztcclxuICAgICAgaWYgKHRoaXMuaXNSZXNwb25zaXZlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMubGFyZ2UpIHtcclxuICAgICAgICAgIHRoaXMub3BlbigpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICB0aGlzLmNsb3NlKCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgY3JlYXRlZCgpIHtcclxuICAgIGlmICh3aW5kb3cgJiYgd2luZG93Lm1hdGNoTWVkaWEpIHtcclxuICAgICAgdGhpcy5zbWFsbCA9IG1lZGlhLnNtYWxsLm1hdGNoZXM7XHJcbiAgICAgIHRoaXMubGFyZ2UgPSBtZWRpYS5sYXJnZS5tYXRjaGVzO1xyXG4gICAgfVxyXG4gIH0sXHJcbiAgbW91bnRlZCgpIHtcclxuICAgIGlmICh0aGlzLnRvZ2dsZU9uKSB7XHJcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZSA9IHRoaXMudG9nZ2xlT25Tb3VyY2UgfHwgdGhpcy4kcm9vdDtcclxuICAgICAgdGhpcy50b2dnbGVPbkV2ZW50U291cmNlLiRvbih0aGlzLnRvZ2dsZU9uLCB0aGlzLnRvZ2dsZSk7XHJcbiAgICB9XHJcbiAgICBpZiAodGhpcy5vcGVuT24pIHtcclxuICAgICAgdGhpcy5vcGVuT25FdmVudFNvdXJjZSA9IHRoaXMub3Blbk9uU291cmNlIHx8IHRoaXMuJHJvb3Q7XHJcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9uKHRoaXMub3Blbk9uLCB0aGlzLm9wZW4pO1xyXG4gICAgfVxyXG4gICAgaWYgKHRoaXMuY2xvc2VPbikge1xyXG4gICAgICB0aGlzLmNsb3NlT25FdmVudFNvdXJjZSA9IHRoaXMuY2xvc2VPblNvdXJjZSB8fCB0aGlzLiRyb290O1xyXG4gICAgICB0aGlzLmNsb3NlT25FdmVudFNvdXJjZS4kb24odGhpcy5jbG9zZU9uLCB0aGlzLmNsb3NlKTtcclxuICAgIH1cclxuICAgIG1lZGlhLnNtYWxsLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKTtcclxuICAgIG1lZGlhLmxhcmdlLmFkZExpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKTtcclxuICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHRoaXMucmVmcmVzaE1lZGlhKCkpO1xyXG4gIH0sXHJcbiAgYmVmb3JlRGVzdHJveSgpIHtcclxuICAgIG1lZGlhLnNtYWxsLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKTtcclxuICAgIG1lZGlhLmxhcmdlLnJlbW92ZUxpc3RlbmVyKHRoaXMucmVmcmVzaE1lZGlhKTtcclxuXHJcbiAgICBpZiAodGhpcy50b2dnbGVPbkV2ZW50U291cmNlKSB7XHJcbiAgICAgIHRoaXMudG9nZ2xlT25FdmVudFNvdXJjZS4kb2ZmKHRoaXMudG9nZ2xlT24sIHRoaXMudG9nZ2xlKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLm9wZW5PbkV2ZW50U291cmNlKSB7XHJcbiAgICAgIHRoaXMub3Blbk9uRXZlbnRTb3VyY2UuJG9mZih0aGlzLm9wZW5PbiwgdGhpcy5vcGVuKTtcclxuICAgIH1cclxuICAgIGlmICh0aGlzLmNsb3NlT25FdmVudFNvdXJjZSkge1xyXG4gICAgICB0aGlzLmNsb3NlT25FdmVudFNvdXJjZS4kb2ZmKHRoaXMuY2xvc2VPbiwgdGhpcy5jbG9zZSk7XHJcbiAgICB9XHJcbiAgfSxcclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXItbGF5b3V0XCI+XG4gICAgICA8c2xvdCAvPlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWxheW91dCcsXG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPGhlYWRlciBjbGFzcz1cIm1kYy1kcmF3ZXItaGVhZGVyIG1kYy1kcmF3ZXJfX2hlYWRlclwiIHYtaWY9XCJzaG93XCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1kcmF3ZXJfX2hlYWRlci1jb250ZW50XCI+XG4gICAgICA8c2xvdCAvPlxuICAgIDwvZGl2PlxuICA8L2hlYWRlcj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5leHBvcnQgZGVmYXVsdCB7XG4gIG5hbWU6ICdtZGMtZHJhd2VyLWhlYWRlcicsXG4gIHByb3BzOiB7XG4gICAgJ3Blcm1hbmVudCc6IEJvb2xlYW4sXG4gICAgJ3BlcnNpc3RlbnQnOiBCb29sZWFuLFxuICAgICd0ZW1wb3JhcnknOiBCb29sZWFuXG4gIH0sXG4gIGluamVjdDogWydtZGNEcmF3ZXInXSxcbiAgY29tcHV0ZWQ6IHtcbiAgICBzaG93ICgpIHtcbiAgICAgIGlmICh0aGlzLnRlbXBvcmFyeSB8fCB0aGlzLnBlcnNpc3RlbnQgfHwgdGhpcy5wZXJtYW5lbnQpIHtcbiAgICAgICAgcmV0dXJuICh0aGlzLnRlbXBvcmFyeSAmJiB0aGlzLm1kY0RyYXdlci5pc1RlbXBvcmFyeSkgfHxcbiAgICAgICAgICAodGhpcy5wZXJzaXN0ZW50ICYmIHRoaXMubWRjRHJhd2VyLmlzUGVyc2lzdGVudCkgfHxcbiAgICAgICAgICAgICh0aGlzLnBlcm1hbmVudCAmJiB0aGlzLm1kY0RyYXdlci5pc1Blcm1hbmVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG59XG48L3NjcmlwdD5cbiIsIjx0ZW1wbGF0ZT5cbiAgPG5hdiBjbGFzcz1cIm1kYy1kcmF3ZXItbGlzdCBtZGMtbGlzdFwiIDpjbGFzcz1cImNsYXNzZXNcIj5cbiAgICA8c2xvdD48L3Nsb3Q+XG4gIDwvbmF2PlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItbGlzdCcsXG4gIHByb3BzOiB7XG4gICAgJ2RlbnNlJzogQm9vbGVhbixcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHtcbiAgICAgICAgJ21kYy1saXN0LS1kZW5zZSc6IHRoaXMuZGVuc2VcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgXG59XG48L3NjcmlwdD4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNiBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiAgICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50IG5vLXVudXNlZC12YXJzOiBbMiwge1wiYXJnc1wiOiBcIm5vbmVcIn1dICovXG5cbi8qKlxuICogQWRhcHRlciBmb3IgTURDIFJpcHBsZS4gUHJvdmlkZXMgYW4gaW50ZXJmYWNlIGZvciBtYW5hZ2luZ1xuICogLSBjbGFzc2VzXG4gKiAtIGRvbVxuICogLSBDU1MgdmFyaWFibGVzXG4gKiAtIHBvc2l0aW9uXG4gKiAtIGRpbWVuc2lvbnNcbiAqIC0gc2Nyb2xsIHBvc2l0aW9uXG4gKiAtIGV2ZW50IGhhbmRsZXJzXG4gKiAtIHVuYm91bmRlZCwgYWN0aXZlIGFuZCBkaXNhYmxlZCBzdGF0ZXNcbiAqXG4gKiBBZGRpdGlvbmFsbHksIHByb3ZpZGVzIHR5cGUgaW5mb3JtYXRpb24gZm9yIHRoZSBhZGFwdGVyIHRvIHRoZSBDbG9zdXJlXG4gKiBjb21waWxlci5cbiAqXG4gKiBJbXBsZW1lbnQgdGhpcyBhZGFwdGVyIGZvciB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UgdG8gZGVsZWdhdGUgdXBkYXRlcyB0b1xuICogdGhlIGNvbXBvbmVudCBpbiB5b3VyIGZyYW1ld29yayBvZiBjaG9pY2UuIFNlZSBhcmNoaXRlY3R1cmUgZG9jdW1lbnRhdGlvblxuICogZm9yIG1vcmUgZGV0YWlscy5cbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvY29kZS9hcmNoaXRlY3R1cmUubWRcbiAqXG4gKiBAcmVjb3JkXG4gKi9cbmNsYXNzIE1EQ1JpcHBsZUFkYXB0ZXIge1xuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpIHt9XG5cbiAgLyoqIEByZXR1cm4ge2Jvb2xlYW59ICovXG4gIGlzVW5ib3VuZGVkKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlQWN0aXZlKCkge31cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNTdXJmYWNlRGlzYWJsZWQoKSB7fVxuXG4gIC8qKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lICovXG4gIGFkZENsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKiogQHBhcmFtIHtzdHJpbmd9IGNsYXNzTmFtZSAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqIEBwYXJhbSB7IUV2ZW50VGFyZ2V0fSB0YXJnZXQgKi9cbiAgY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBldnRUeXBlXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcihldnRUeXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gZXZ0VHlwZVxuICAgKiBAcGFyYW0geyFGdW5jdGlvbn0gaGFuZGxlclxuICAgKi9cbiAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyKGV2dFR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7IUZ1bmN0aW9ufSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlclJlc2l6ZUhhbmRsZXIoaGFuZGxlcikge31cblxuICAvKipcbiAgICogQHBhcmFtIHshRnVuY3Rpb259IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YXJOYW1lXG4gICAqIEBwYXJhbSB7P251bWJlcnxzdHJpbmd9IHZhbHVlXG4gICAqL1xuICB1cGRhdGVDc3NWYXJpYWJsZSh2YXJOYW1lLCB2YWx1ZSkge31cblxuICAvKiogQHJldHVybiB7IUNsaWVudFJlY3R9ICovXG4gIGNvbXB1dGVCb3VuZGluZ1JlY3QoKSB7fVxuXG4gIC8qKiBAcmV0dXJuIHt7eDogbnVtYmVyLCB5OiBudW1iZXJ9fSAqL1xuICBnZXRXaW5kb3dQYWdlT2Zmc2V0KCkge31cbn1cblxuZXhwb3J0IGRlZmF1bHQgTURDUmlwcGxlQWRhcHRlcjtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5jb25zdCBjc3NDbGFzc2VzID0ge1xuICAvLyBSaXBwbGUgaXMgYSBzcGVjaWFsIGNhc2Ugd2hlcmUgdGhlIFwicm9vdFwiIGNvbXBvbmVudCBpcyByZWFsbHkgYSBcIm1peGluXCIgb2Ygc29ydHMsXG4gIC8vIGdpdmVuIHRoYXQgaXQncyBhbiAndXBncmFkZScgdG8gYW4gZXhpc3RpbmcgY29tcG9uZW50LiBUaGF0IGJlaW5nIHNhaWQgaXQgaXMgdGhlIHJvb3RcbiAgLy8gQ1NTIGNsYXNzIHRoYXQgYWxsIG90aGVyIENTUyBjbGFzc2VzIGRlcml2ZSBmcm9tLlxuICBST09UOiAnbWRjLXJpcHBsZS11cGdyYWRlZCcsXG4gIFVOQk9VTkRFRDogJ21kYy1yaXBwbGUtdXBncmFkZWQtLXVuYm91bmRlZCcsXG4gIEJHX0ZPQ1VTRUQ6ICdtZGMtcmlwcGxlLXVwZ3JhZGVkLS1iYWNrZ3JvdW5kLWZvY3VzZWQnLFxuICBGR19BQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1hY3RpdmF0aW9uJyxcbiAgRkdfREVBQ1RJVkFUSU9OOiAnbWRjLXJpcHBsZS11cGdyYWRlZC0tZm9yZWdyb3VuZC1kZWFjdGl2YXRpb24nLFxufTtcblxuY29uc3Qgc3RyaW5ncyA9IHtcbiAgVkFSX0xFRlQ6ICctLW1kYy1yaXBwbGUtbGVmdCcsXG4gIFZBUl9UT1A6ICctLW1kYy1yaXBwbGUtdG9wJyxcbiAgVkFSX0ZHX1NJWkU6ICctLW1kYy1yaXBwbGUtZmctc2l6ZScsXG4gIFZBUl9GR19TQ0FMRTogJy0tbWRjLXJpcHBsZS1mZy1zY2FsZScsXG4gIFZBUl9GR19UUkFOU0xBVEVfU1RBUlQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLXN0YXJ0JyxcbiAgVkFSX0ZHX1RSQU5TTEFURV9FTkQ6ICctLW1kYy1yaXBwbGUtZmctdHJhbnNsYXRlLWVuZCcsXG59O1xuXG5jb25zdCBudW1iZXJzID0ge1xuICBQQURESU5HOiAxMCxcbiAgSU5JVElBTF9PUklHSU5fU0NBTEU6IDAuNixcbiAgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVM6IDIyNSwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtdHJhbnNsYXRlLWR1cmF0aW9uIChpLmUuIGFjdGl2YXRpb24gYW5pbWF0aW9uIGR1cmF0aW9uKVxuICBGR19ERUFDVElWQVRJT05fTVM6IDE1MCwgLy8gQ29ycmVzcG9uZHMgdG8gJG1kYy1yaXBwbGUtZmFkZS1vdXQtZHVyYXRpb24gKGkuZS4gZGVhY3RpdmF0aW9uIGFuaW1hdGlvbiBkdXJhdGlvbilcbiAgVEFQX0RFTEFZX01TOiAzMDAsIC8vIERlbGF5IGJldHdlZW4gdG91Y2ggYW5kIHNpbXVsYXRlZCBtb3VzZSBldmVudHMgb24gdG91Y2ggZGV2aWNlc1xufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyB0byBhdm9pZCByZWR1bmRhbnQgcHJvY2Vzc2luZyB0byBkZXRlY3QgQ1NTIGN1c3RvbSB2YXJpYWJsZSBzdXBwb3J0LlxuICogQHByaXZhdGUge2Jvb2xlYW58dW5kZWZpbmVkfVxuICovXG5sZXQgc3VwcG9ydHNDc3NWYXJpYWJsZXNfO1xuXG4vKipcbiAqIFN0b3JlcyByZXN1bHQgZnJvbSBhcHBseVBhc3NpdmUgdG8gYXZvaWQgcmVkdW5kYW50IHByb2Nlc3NpbmcgdG8gZGV0ZWN0IHBhc3NpdmUgZXZlbnQgbGlzdGVuZXIgc3VwcG9ydC5cbiAqIEBwcml2YXRlIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xubGV0IHN1cHBvcnRzUGFzc2l2ZV87XG5cbi8qKlxuICogQHBhcmFtIHshV2luZG93fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGRldGVjdEVkZ2VQc2V1ZG9WYXJCdWcod2luZG93T2JqKSB7XG4gIC8vIERldGVjdCB2ZXJzaW9ucyBvZiBFZGdlIHdpdGggYnVnZ3kgdmFyKCkgc3VwcG9ydFxuICAvLyBTZWU6IGh0dHBzOi8vZGV2ZWxvcGVyLm1pY3Jvc29mdC5jb20vZW4tdXMvbWljcm9zb2Z0LWVkZ2UvcGxhdGZvcm0vaXNzdWVzLzExNDk1NDQ4L1xuICBjb25zdCBkb2N1bWVudCA9IHdpbmRvd09iai5kb2N1bWVudDtcbiAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBub2RlLmNsYXNzTmFtZSA9ICdtZGMtcmlwcGxlLXN1cmZhY2UtLXRlc3QtZWRnZS12YXItYnVnJztcbiAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChub2RlKTtcblxuICAvLyBUaGUgYnVnIGV4aXN0cyBpZiA6OmJlZm9yZSBzdHlsZSBlbmRzIHVwIHByb3BhZ2F0aW5nIHRvIHRoZSBwYXJlbnQgZWxlbWVudC5cbiAgLy8gQWRkaXRpb25hbGx5LCBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgbnVsbCBpbiBpZnJhbWVzIHdpdGggZGlzcGxheTogXCJub25lXCIgaW4gRmlyZWZveCxcbiAgLy8gYnV0IEZpcmVmb3ggaXMga25vd24gdG8gc3VwcG9ydCBDU1MgY3VzdG9tIHByb3BlcnRpZXMgY29ycmVjdGx5LlxuICAvLyBTZWU6IGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTU0ODM5N1xuICBjb25zdCBjb21wdXRlZFN0eWxlID0gd2luZG93T2JqLmdldENvbXB1dGVkU3R5bGUobm9kZSk7XG4gIGNvbnN0IGhhc1BzZXVkb1ZhckJ1ZyA9IGNvbXB1dGVkU3R5bGUgIT09IG51bGwgJiYgY29tcHV0ZWRTdHlsZS5ib3JkZXJUb3BTdHlsZSA9PT0gJ3NvbGlkJztcbiAgbm9kZS5yZW1vdmUoKTtcbiAgcmV0dXJuIGhhc1BzZXVkb1ZhckJ1Zztcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFXaW5kb3d9IHdpbmRvd09ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHVuZGVmaW5lZH1cbiAqL1xuXG5mdW5jdGlvbiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyh3aW5kb3dPYmosIGZvcmNlUmVmcmVzaCA9IGZhbHNlKSB7XG4gIGxldCBzdXBwb3J0c0Nzc1ZhcmlhYmxlcyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzXztcbiAgaWYgKHR5cGVvZiBzdXBwb3J0c0Nzc1ZhcmlhYmxlc18gPT09ICdib29sZWFuJyAmJiAhZm9yY2VSZWZyZXNoKSB7XG4gICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG5cbiAgY29uc3Qgc3VwcG9ydHNGdW5jdGlvblByZXNlbnQgPSB3aW5kb3dPYmouQ1NTICYmIHR5cGVvZiB3aW5kb3dPYmouQ1NTLnN1cHBvcnRzID09PSAnZnVuY3Rpb24nO1xuICBpZiAoIXN1cHBvcnRzRnVuY3Rpb25QcmVzZW50KSB7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgY29uc3QgZXhwbGljaXRseVN1cHBvcnRzQ3NzVmFycyA9IHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJy0tY3NzLXZhcnMnLCAneWVzJyk7XG4gIC8vIFNlZTogaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTE1NDY2OVxuICAvLyBTZWU6IFJFQURNRSBzZWN0aW9uIG9uIFNhZmFyaVxuICBjb25zdCB3ZUFyZUZlYXR1cmVEZXRlY3RpbmdTYWZhcmkxMHBsdXMgPSAoXG4gICAgd2luZG93T2JqLkNTUy5zdXBwb3J0cygnKC0tY3NzLXZhcnM6IHllcyknKSAmJlxuICAgIHdpbmRvd09iai5DU1Muc3VwcG9ydHMoJ2NvbG9yJywgJyMwMDAwMDAwMCcpXG4gICk7XG5cbiAgaWYgKGV4cGxpY2l0bHlTdXBwb3J0c0Nzc1ZhcnMgfHwgd2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzKSB7XG4gICAgc3VwcG9ydHNDc3NWYXJpYWJsZXMgPSAhZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1Zyh3aW5kb3dPYmopO1xuICB9IGVsc2Uge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzID0gZmFsc2U7XG4gIH1cblxuICBpZiAoIWZvcmNlUmVmcmVzaCkge1xuICAgIHN1cHBvcnRzQ3NzVmFyaWFibGVzXyA9IHN1cHBvcnRzQ3NzVmFyaWFibGVzO1xuICB9XG4gIHJldHVybiBzdXBwb3J0c0Nzc1ZhcmlhYmxlcztcbn1cblxuLy9cbi8qKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGN1cnJlbnQgYnJvd3NlciBzdXBwb3J0cyBwYXNzaXZlIGV2ZW50IGxpc3RlbmVycywgYW5kIGlmIHNvLCB1c2UgdGhlbS5cbiAqIEBwYXJhbSB7IVdpbmRvdz19IGdsb2JhbE9ialxuICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VSZWZyZXNoXG4gKiBAcmV0dXJuIHtib29sZWFufHtwYXNzaXZlOiBib29sZWFufX1cbiAqL1xuZnVuY3Rpb24gYXBwbHlQYXNzaXZlKGdsb2JhbE9iaiA9IHdpbmRvdywgZm9yY2VSZWZyZXNoID0gZmFsc2UpIHtcbiAgaWYgKHN1cHBvcnRzUGFzc2l2ZV8gPT09IHVuZGVmaW5lZCB8fCBmb3JjZVJlZnJlc2gpIHtcbiAgICBsZXQgaXNTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0cnkge1xuICAgICAgZ2xvYmFsT2JqLmRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QnLCBudWxsLCB7Z2V0IHBhc3NpdmUoKSB7XG4gICAgICAgIGlzU3VwcG9ydGVkID0gdHJ1ZTtcbiAgICAgIH19KTtcbiAgICB9IGNhdGNoIChlKSB7IH1cblxuICAgIHN1cHBvcnRzUGFzc2l2ZV8gPSBpc1N1cHBvcnRlZDtcbiAgfVxuXG4gIHJldHVybiBzdXBwb3J0c1Bhc3NpdmVfID8ge3Bhc3NpdmU6IHRydWV9IDogZmFsc2U7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSBIVE1MRWxlbWVudFByb3RvdHlwZVxuICogQHJldHVybiB7IUFycmF5PHN0cmluZz59XG4gKi9cbmZ1bmN0aW9uIGdldE1hdGNoZXNQcm9wZXJ0eShIVE1MRWxlbWVudFByb3RvdHlwZSkge1xuICByZXR1cm4gW1xuICAgICd3ZWJraXRNYXRjaGVzU2VsZWN0b3InLCAnbXNNYXRjaGVzU2VsZWN0b3InLCAnbWF0Y2hlcycsXG4gIF0uZmlsdGVyKChwKSA9PiBwIGluIEhUTUxFbGVtZW50UHJvdG90eXBlKS5wb3AoKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0geyFFdmVudH0gZXZcbiAqIEBwYXJhbSB7IXt4OiBudW1iZXIsIHk6IG51bWJlcn19IHBhZ2VPZmZzZXRcbiAqIEBwYXJhbSB7IUNsaWVudFJlY3R9IGNsaWVudFJlY3RcbiAqIEByZXR1cm4geyF7eDogbnVtYmVyLCB5OiBudW1iZXJ9fVxuICovXG5mdW5jdGlvbiBnZXROb3JtYWxpemVkRXZlbnRDb29yZHMoZXYsIHBhZ2VPZmZzZXQsIGNsaWVudFJlY3QpIHtcbiAgY29uc3Qge3gsIHl9ID0gcGFnZU9mZnNldDtcbiAgY29uc3QgZG9jdW1lbnRYID0geCArIGNsaWVudFJlY3QubGVmdDtcbiAgY29uc3QgZG9jdW1lbnRZID0geSArIGNsaWVudFJlY3QudG9wO1xuXG4gIGxldCBub3JtYWxpemVkWDtcbiAgbGV0IG5vcm1hbGl6ZWRZO1xuICAvLyBEZXRlcm1pbmUgdG91Y2ggcG9pbnQgcmVsYXRpdmUgdG8gdGhlIHJpcHBsZSBjb250YWluZXIuXG4gIGlmIChldi50eXBlID09PSAndG91Y2hzdGFydCcpIHtcbiAgICBub3JtYWxpemVkWCA9IGV2LmNoYW5nZWRUb3VjaGVzWzBdLnBhZ2VYIC0gZG9jdW1lbnRYO1xuICAgIG5vcm1hbGl6ZWRZID0gZXYuY2hhbmdlZFRvdWNoZXNbMF0ucGFnZVkgLSBkb2N1bWVudFk7XG4gIH0gZWxzZSB7XG4gICAgbm9ybWFsaXplZFggPSBldi5wYWdlWCAtIGRvY3VtZW50WDtcbiAgICBub3JtYWxpemVkWSA9IGV2LnBhZ2VZIC0gZG9jdW1lbnRZO1xuICB9XG5cbiAgcmV0dXJuIHt4OiBub3JtYWxpemVkWCwgeTogbm9ybWFsaXplZFl9O1xufVxuXG5leHBvcnQge3N1cHBvcnRzQ3NzVmFyaWFibGVzLCBhcHBseVBhc3NpdmUsIGdldE1hdGNoZXNQcm9wZXJ0eSwgZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG5pbXBvcnQgTURDRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uJztcbmltcG9ydCBNRENSaXBwbGVBZGFwdGVyIGZyb20gJy4vYWRhcHRlcic7XG5pbXBvcnQge2Nzc0NsYXNzZXMsIHN0cmluZ3MsIG51bWJlcnN9IGZyb20gJy4vY29uc3RhbnRzJztcbmltcG9ydCB7Z2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzfSBmcm9tICcuL3V0aWwnO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBpc0FjdGl2YXRlZDogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgaGFzRGVhY3RpdmF0aW9uVVhSdW46IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogKGJvb2xlYW58dW5kZWZpbmVkKSxcbiAqICAgd2FzRWxlbWVudE1hZGVBY3RpdmU6IChib29sZWFufHVuZGVmaW5lZCksXG4gKiAgIGFjdGl2YXRpb25FdmVudDogRXZlbnQsXG4gKiAgIGlzUHJvZ3JhbW1hdGljOiAoYm9vbGVhbnx1bmRlZmluZWQpXG4gKiB9fVxuICovXG5sZXQgQWN0aXZhdGlvblN0YXRlVHlwZTtcblxuLyoqXG4gKiBAdHlwZWRlZiB7IXtcbiAqICAgYWN0aXZhdGU6IChzdHJpbmd8dW5kZWZpbmVkKSxcbiAqICAgZGVhY3RpdmF0ZTogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBmb2N1czogKHN0cmluZ3x1bmRlZmluZWQpLFxuICogICBibHVyOiAoc3RyaW5nfHVuZGVmaW5lZClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lckluZm9UeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICBhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZGVhY3RpdmF0ZTogZnVuY3Rpb24oIUV2ZW50KSxcbiAqICAgZm9jdXM6IGZ1bmN0aW9uKCksXG4gKiAgIGJsdXI6IGZ1bmN0aW9uKClcbiAqIH19XG4gKi9cbmxldCBMaXN0ZW5lcnNUeXBlO1xuXG4vKipcbiAqIEB0eXBlZGVmIHshe1xuICogICB4OiBudW1iZXIsXG4gKiAgIHk6IG51bWJlclxuICogfX1cbiAqL1xubGV0IFBvaW50VHlwZTtcblxuLy8gQWN0aXZhdGlvbiBldmVudHMgcmVnaXN0ZXJlZCBvbiB0aGUgcm9vdCBlbGVtZW50IG9mIGVhY2ggaW5zdGFuY2UgZm9yIGFjdGl2YXRpb25cbmNvbnN0IEFDVElWQVRJT05fRVZFTlRfVFlQRVMgPSBbJ3RvdWNoc3RhcnQnLCAncG9pbnRlcmRvd24nLCAnbW91c2Vkb3duJywgJ2tleWRvd24nXTtcblxuLy8gRGVhY3RpdmF0aW9uIGV2ZW50cyByZWdpc3RlcmVkIG9uIGRvY3VtZW50RWxlbWVudCB3aGVuIGEgcG9pbnRlci1yZWxhdGVkIGRvd24gZXZlbnQgb2NjdXJzXG5jb25zdCBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUyA9IFsndG91Y2hlbmQnLCAncG9pbnRlcnVwJywgJ21vdXNldXAnXTtcblxuLy8gVHJhY2tzIGFjdGl2YXRpb25zIHRoYXQgaGF2ZSBvY2N1cnJlZCBvbiB0aGUgY3VycmVudCBmcmFtZSwgdG8gYXZvaWQgc2ltdWx0YW5lb3VzIG5lc3RlZCBhY3RpdmF0aW9uc1xuLyoqIEB0eXBlIHshQXJyYXk8IUV2ZW50VGFyZ2V0Pn0gKi9cbmxldCBhY3RpdmF0ZWRUYXJnZXRzID0gW107XG5cbi8qKlxuICogQGV4dGVuZHMge01EQ0ZvdW5kYXRpb248IU1EQ1JpcHBsZUFkYXB0ZXI+fVxuICovXG5jbGFzcyBNRENSaXBwbGVGb3VuZGF0aW9uIGV4dGVuZHMgTURDRm91bmRhdGlvbiB7XG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICByZXR1cm4gY3NzQ2xhc3NlcztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgc3RyaW5ncygpIHtcbiAgICByZXR1cm4gc3RyaW5ncztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgbnVtYmVycygpIHtcbiAgICByZXR1cm4gbnVtYmVycztcbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdEFkYXB0ZXIoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IC8qIGJvb2xlYW4gLSBjYWNoZWQgKi8ge30sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZUFjdGl2ZTogKCkgPT4gLyogYm9vbGVhbiAqLyB7fSxcbiAgICAgIGlzU3VyZmFjZURpc2FibGVkOiAoKSA9PiAvKiBib29sZWFuICovIHt9LFxuICAgICAgYWRkQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICByZW1vdmVDbGFzczogKC8qIGNsYXNzTmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbnRhaW5zRXZlbnRUYXJnZXQ6ICgvKiB0YXJnZXQ6ICFFdmVudFRhcmdldCAqLykgPT4ge30sXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIGV2dFR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiBldnRUeXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogZXZ0VHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKC8qIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHVwZGF0ZUNzc1ZhcmlhYmxlOiAoLyogdmFyTmFtZTogc3RyaW5nLCB2YWx1ZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8ge30sXG4gICAgICBnZXRXaW5kb3dQYWdlT2Zmc2V0OiAoKSA9PiAvKiB7eDogbnVtYmVyLCB5OiBudW1iZXJ9ICovIHt9LFxuICAgIH07XG4gIH1cblxuICBjb25zdHJ1Y3RvcihhZGFwdGVyKSB7XG4gICAgc3VwZXIoT2JqZWN0LmFzc2lnbihNRENSaXBwbGVGb3VuZGF0aW9uLmRlZmF1bHRBZGFwdGVyLCBhZGFwdGVyKSk7XG5cbiAgICAvKiogQHByaXZhdGUge251bWJlcn0gKi9cbiAgICB0aGlzLmxheW91dEZyYW1lXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUgeyFDbGllbnRSZWN0fSAqL1xuICAgIHRoaXMuZnJhbWVfID0gLyoqIEB0eXBlIHshQ2xpZW50UmVjdH0gKi8gKHt3aWR0aDogMCwgaGVpZ2h0OiAwfSk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFBY3RpdmF0aW9uU3RhdGVUeXBlfSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuaW5pdGlhbFNpemVfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMubWF4UmFkaXVzXyA9IDA7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKCFFdmVudCl9ICovXG4gICAgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuYWN0aXZhdGVfKGUpO1xuXG4gICAgLyoqIEBwcml2YXRlIHtmdW5jdGlvbighRXZlbnQpfSAqL1xuICAgIHRoaXMuZGVhY3RpdmF0ZUhhbmRsZXJfID0gKGUpID0+IHRoaXMuZGVhY3RpdmF0ZV8oZSk7XG5cbiAgICAvKiogQHByaXZhdGUge2Z1bmN0aW9uKD9FdmVudD0pfSAqL1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHJlcXVlc3RBbmltYXRpb25GcmFtZShcbiAgICAgICgpID0+IHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzLkJHX0ZPQ1VTRUQpXG4gICAgKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7ZnVuY3Rpb24oP0V2ZW50PSl9ICovXG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoXG4gICAgICAoKSA9PiB0aGlzLmFkYXB0ZXJfLnJlbW92ZUNsYXNzKE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3Nlcy5CR19GT0NVU0VEKVxuICAgICk7XG5cbiAgICAvKiogQHByaXZhdGUgeyFGdW5jdGlvbn0gKi9cbiAgICB0aGlzLnJlc2l6ZUhhbmRsZXJfID0gKCkgPT4gdGhpcy5sYXlvdXQoKTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IXtsZWZ0OiBudW1iZXIsIHRvcDpudW1iZXJ9fSAqL1xuICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgIGxlZnQ6IDAsXG4gICAgICB0b3A6IDAsXG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdTY2FsZV8gPSAwO1xuXG4gICAgLyoqIEBwcml2YXRlIHtudW1iZXJ9ICovXG4gICAgdGhpcy5hY3RpdmF0aW9uVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7bnVtYmVyfSAqL1xuICAgIHRoaXMuZmdEZWFjdGl2YXRpb25SZW1vdmFsVGltZXJfID0gMDtcblxuICAgIC8qKiBAcHJpdmF0ZSB7Ym9vbGVhbn0gKi9cbiAgICB0aGlzLmFjdGl2YXRpb25BbmltYXRpb25IYXNFbmRlZF8gPSBmYWxzZTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7IUZ1bmN0aW9ufSAqL1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfID0gKCkgPT4ge1xuICAgICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gdHJ1ZTtcbiAgICAgIHRoaXMucnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCk7XG4gICAgfTtcblxuICAgIC8qKiBAcHJpdmF0ZSB7P0V2ZW50fSAqL1xuICAgIHRoaXMucHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfID0gbnVsbDtcbiAgfVxuXG4gIC8qKlxuICAgKiBXZSBjb21wdXRlIHRoaXMgcHJvcGVydHkgc28gdGhhdCB3ZSBhcmUgbm90IHF1ZXJ5aW5nIGluZm9ybWF0aW9uIGFib3V0IHRoZSBjbGllbnRcbiAgICogdW50aWwgdGhlIHBvaW50IGluIHRpbWUgd2hlcmUgdGhlIGZvdW5kYXRpb24gcmVxdWVzdHMgaXQuIFRoaXMgcHJldmVudHMgc2NlbmFyaW9zIHdoZXJlXG4gICAqIGNsaWVudC1zaWRlIGZlYXR1cmUtZGV0ZWN0aW9uIG1heSBoYXBwZW4gdG9vIGVhcmx5LCBzdWNoIGFzIHdoZW4gY29tcG9uZW50cyBhcmUgcmVuZGVyZWQgb24gdGhlIHNlcnZlclxuICAgKiBhbmQgdGhlbiBpbml0aWFsaXplZCBhdCBtb3VudCB0aW1lIG9uIHRoZSBjbGllbnQuXG4gICAqIEByZXR1cm4ge2Jvb2xlYW59XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBpc1N1cHBvcnRlZF8oKSB7XG4gICAgcmV0dXJuIHRoaXMuYWRhcHRlcl8uYnJvd3NlclN1cHBvcnRzQ3NzVmFycygpO1xuICB9XG5cbiAgLyoqXG4gICAqIEByZXR1cm4geyFBY3RpdmF0aW9uU3RhdGVUeXBlfVxuICAgKi9cbiAgZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGlzQWN0aXZhdGVkOiBmYWxzZSxcbiAgICAgIGhhc0RlYWN0aXZhdGlvblVYUnVuOiBmYWxzZSxcbiAgICAgIHdhc0FjdGl2YXRlZEJ5UG9pbnRlcjogZmFsc2UsXG4gICAgICB3YXNFbGVtZW50TWFkZUFjdGl2ZTogZmFsc2UsXG4gICAgICBhY3RpdmF0aW9uRXZlbnQ6IG51bGwsXG4gICAgICBpc1Byb2dyYW1tYXRpYzogZmFsc2UsXG4gICAgfTtcbiAgfVxuXG4gIGluaXQoKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhST09UKTtcbiAgICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhVTkJPVU5ERUQpO1xuICAgICAgfVxuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICB9KTtcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgaWYgKCF0aGlzLmlzU3VwcG9ydGVkXygpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYWN0aXZhdGlvblRpbWVyXykge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuYWN0aXZhdGlvblRpbWVyXyk7XG4gICAgICB0aGlzLmFjdGl2YXRpb25UaW1lcl8gPSAwO1xuICAgICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19BQ1RJVkFUSU9OKTtcbiAgICB9XG5cbiAgICB0aGlzLmRlcmVnaXN0ZXJSb290SGFuZGxlcnNfKCk7XG4gICAgdGhpcy5kZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCk7XG5cbiAgICBjb25zdCB7Uk9PVCwgVU5CT1VOREVEfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhST09UKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoVU5CT1VOREVEKTtcbiAgICAgIHRoaXMucmVtb3ZlQ3NzVmFyc18oKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICByZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIHRoaXMuYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlclJlc2l6ZUhhbmRsZXIodGhpcy5yZXNpemVIYW5kbGVyXyk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHshRXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIHJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKGUpIHtcbiAgICBpZiAoZS50eXBlID09PSAna2V5ZG93bicpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2tleXVwJywgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0gZWxzZSB7XG4gICAgICBQT0lOVEVSX0RFQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcih0eXBlLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgICB9KTtcbiAgICB9XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgZGVyZWdpc3RlclJvb3RIYW5kbGVyc18oKSB7XG4gICAgQUNUSVZBVElPTl9FVkVOVF9UWVBFUy5mb3JFYWNoKCh0eXBlKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5hY3RpdmF0ZUhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2JsdXInLCB0aGlzLmJsdXJIYW5kbGVyXyk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBkZXJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfKCkge1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcigna2V5dXAnLCB0aGlzLmRlYWN0aXZhdGVIYW5kbGVyXyk7XG4gICAgUE9JTlRFUl9ERUFDVElWQVRJT05fRVZFTlRfVFlQRVMuZm9yRWFjaCgodHlwZSkgPT4ge1xuICAgICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyRG9jdW1lbnRJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgdGhpcy5kZWFjdGl2YXRlSGFuZGxlcl8pO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHJlbW92ZUNzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtzdHJpbmdzfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb247XG4gICAgT2JqZWN0LmtleXMoc3RyaW5ncykuZm9yRWFjaCgoaykgPT4ge1xuICAgICAgaWYgKGsuaW5kZXhPZignVkFSXycpID09PSAwKSB7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoc3RyaW5nc1trXSwgbnVsbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHs/RXZlbnR9IGVcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGFjdGl2YXRlXyhlKSB7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNTdXJmYWNlRGlzYWJsZWQoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICBpZiAoYWN0aXZhdGlvblN0YXRlLmlzQWN0aXZhdGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gQXZvaWQgcmVhY3RpbmcgdG8gZm9sbG93LW9uIGV2ZW50cyBmaXJlZCBieSB0b3VjaCBkZXZpY2UgYWZ0ZXIgYW4gYWxyZWFkeS1wcm9jZXNzZWQgdXNlciBpbnRlcmFjdGlvblxuICAgIGNvbnN0IHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50ID0gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF87XG4gICAgY29uc3QgaXNTYW1lSW50ZXJhY3Rpb24gPSBwcmV2aW91c0FjdGl2YXRpb25FdmVudCAmJiBlICYmIHByZXZpb3VzQWN0aXZhdGlvbkV2ZW50LnR5cGUgIT09IGUudHlwZTtcbiAgICBpZiAoaXNTYW1lSW50ZXJhY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQgPSB0cnVlO1xuICAgIGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA9IGUgPT09IG51bGw7XG4gICAgYWN0aXZhdGlvblN0YXRlLmFjdGl2YXRpb25FdmVudCA9IGU7XG4gICAgYWN0aXZhdGlvblN0YXRlLndhc0FjdGl2YXRlZEJ5UG9pbnRlciA9IGFjdGl2YXRpb25TdGF0ZS5pc1Byb2dyYW1tYXRpYyA/IGZhbHNlIDogKFxuICAgICAgZS50eXBlID09PSAnbW91c2Vkb3duJyB8fCBlLnR5cGUgPT09ICd0b3VjaHN0YXJ0JyB8fCBlLnR5cGUgPT09ICdwb2ludGVyZG93bidcbiAgICApO1xuXG4gICAgY29uc3QgaGFzQWN0aXZhdGVkQ2hpbGQgPVxuICAgICAgZSAmJiBhY3RpdmF0ZWRUYXJnZXRzLmxlbmd0aCA+IDAgJiYgYWN0aXZhdGVkVGFyZ2V0cy5zb21lKCh0YXJnZXQpID0+IHRoaXMuYWRhcHRlcl8uY29udGFpbnNFdmVudFRhcmdldCh0YXJnZXQpKTtcbiAgICBpZiAoaGFzQWN0aXZhdGVkQ2hpbGQpIHtcbiAgICAgIC8vIEltbWVkaWF0ZWx5IHJlc2V0IGFjdGl2YXRpb24gc3RhdGUsIHdoaWxlIHByZXNlcnZpbmcgbG9naWMgdGhhdCBwcmV2ZW50cyB0b3VjaCBmb2xsb3ctb24gZXZlbnRzXG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChlKSB7XG4gICAgICBhY3RpdmF0ZWRUYXJnZXRzLnB1c2goLyoqIEB0eXBlIHshRXZlbnRUYXJnZXR9ICovIChlLnRhcmdldCkpO1xuICAgICAgdGhpcy5yZWdpc3RlckRlYWN0aXZhdGlvbkhhbmRsZXJzXyhlKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgLy8gVGhpcyBuZWVkcyB0byBiZSB3cmFwcGVkIGluIGFuIHJBRiBjYWxsIGIvYyB3ZWIgYnJvd3NlcnNcbiAgICAgIC8vIHJlcG9ydCBhY3RpdmUgc3RhdGVzIGluY29uc2lzdGVudGx5IHdoZW4gdGhleSdyZSBjYWxsZWQgd2l0aGluXG4gICAgICAvLyBldmVudCBoYW5kbGluZyBjb2RlOlxuICAgICAgLy8gLSBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD02MzU5NzFcbiAgICAgIC8vIC0gaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTI5Mzc0MVxuICAgICAgYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlID0gKGUgJiYgZS50eXBlID09PSAna2V5ZG93bicpID8gdGhpcy5hZGFwdGVyXy5pc1N1cmZhY2VBY3RpdmUoKSA6IHRydWU7XG4gICAgICBpZiAoYWN0aXZhdGlvblN0YXRlLndhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICAgIHRoaXMuYW5pbWF0ZUFjdGl2YXRpb25fKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBSZXNldCBhY3RpdmF0aW9uIHN0YXRlIGltbWVkaWF0ZWx5IGlmIGVsZW1lbnQgd2FzIG5vdCBtYWRlIGFjdGl2ZS5cbiAgICAgICAgdGhpcy5hY3RpdmF0aW9uU3RhdGVfID0gdGhpcy5kZWZhdWx0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXNldCBhcnJheSBvbiBuZXh0IGZyYW1lIGFmdGVyIHRoZSBjdXJyZW50IGV2ZW50IGhhcyBoYWQgYSBjaGFuY2UgdG8gYnViYmxlIHRvIHByZXZlbnQgYW5jZXN0b3IgcmlwcGxlc1xuICAgICAgYWN0aXZhdGVkVGFyZ2V0cyA9IFtdO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGFjdGl2YXRlKGV2ZW50ID0gbnVsbCkge1xuICAgIHRoaXMuYWN0aXZhdGVfKGV2ZW50KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBhbmltYXRlQWN0aXZhdGlvbl8oKSB7XG4gICAgY29uc3Qge1ZBUl9GR19UUkFOU0xBVEVfU1RBUlQsIFZBUl9GR19UUkFOU0xBVEVfRU5EfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uc3RyaW5ncztcbiAgICBjb25zdCB7RkdfREVBQ1RJVkFUSU9OLCBGR19BQ1RJVkFUSU9OfSA9IE1EQ1JpcHBsZUZvdW5kYXRpb24uY3NzQ2xhc3NlcztcbiAgICBjb25zdCB7REVBQ1RJVkFUSU9OX1RJTUVPVVRfTVN9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzO1xuXG4gICAgbGV0IHRyYW5zbGF0ZVN0YXJ0ID0gJyc7XG4gICAgbGV0IHRyYW5zbGF0ZUVuZCA9ICcnO1xuXG4gICAgaWYgKCF0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIGNvbnN0IHtzdGFydFBvaW50LCBlbmRQb2ludH0gPSB0aGlzLmdldEZnVHJhbnNsYXRpb25Db29yZGluYXRlc18oKTtcbiAgICAgIHRyYW5zbGF0ZVN0YXJ0ID0gYCR7c3RhcnRQb2ludC54fXB4LCAke3N0YXJ0UG9pbnQueX1weGA7XG4gICAgICB0cmFuc2xhdGVFbmQgPSBgJHtlbmRQb2ludC54fXB4LCAke2VuZFBvaW50Lnl9cHhgO1xuICAgIH1cblxuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCwgdHJhbnNsYXRlU3RhcnQpO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1RSQU5TTEFURV9FTkQsIHRyYW5zbGF0ZUVuZCk7XG4gICAgLy8gQ2FuY2VsIGFueSBvbmdvaW5nIGFjdGl2YXRpb24vZGVhY3RpdmF0aW9uIGFuaW1hdGlvbnNcbiAgICBjbGVhclRpbWVvdXQodGhpcy5hY3RpdmF0aW9uVGltZXJfKTtcbiAgICBjbGVhclRpbWVvdXQodGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8pO1xuICAgIHRoaXMucm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfKCk7XG4gICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuXG4gICAgLy8gRm9yY2UgbGF5b3V0IGluIG9yZGVyIHRvIHJlLXRyaWdnZXIgdGhlIGFuaW1hdGlvbi5cbiAgICB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICB0aGlzLmFkYXB0ZXJfLmFkZENsYXNzKEZHX0FDVElWQVRJT04pO1xuICAgIHRoaXMuYWN0aXZhdGlvblRpbWVyXyA9IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5hY3RpdmF0aW9uVGltZXJDYWxsYmFja18oKSwgREVBQ1RJVkFUSU9OX1RJTUVPVVRfTVMpO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwcml2YXRlXG4gICAqIEByZXR1cm4ge3tzdGFydFBvaW50OiBQb2ludFR5cGUsIGVuZFBvaW50OiBQb2ludFR5cGV9fVxuICAgKi9cbiAgZ2V0RmdUcmFuc2xhdGlvbkNvb3JkaW5hdGVzXygpIHtcbiAgICBjb25zdCB7YWN0aXZhdGlvbkV2ZW50LCB3YXNBY3RpdmF0ZWRCeVBvaW50ZXJ9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuXG4gICAgbGV0IHN0YXJ0UG9pbnQ7XG4gICAgaWYgKHdhc0FjdGl2YXRlZEJ5UG9pbnRlcikge1xuICAgICAgc3RhcnRQb2ludCA9IGdldE5vcm1hbGl6ZWRFdmVudENvb3JkcyhcbiAgICAgICAgLyoqIEB0eXBlIHshRXZlbnR9ICovIChhY3RpdmF0aW9uRXZlbnQpLFxuICAgICAgICB0aGlzLmFkYXB0ZXJfLmdldFdpbmRvd1BhZ2VPZmZzZXQoKSwgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KClcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICAgIHg6IHRoaXMuZnJhbWVfLndpZHRoIC8gMixcbiAgICAgICAgeTogdGhpcy5mcmFtZV8uaGVpZ2h0IC8gMixcbiAgICAgIH07XG4gICAgfVxuICAgIC8vIENlbnRlciB0aGUgZWxlbWVudCBhcm91bmQgdGhlIHN0YXJ0IHBvaW50LlxuICAgIHN0YXJ0UG9pbnQgPSB7XG4gICAgICB4OiBzdGFydFBvaW50LnggLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICAgIHk6IHN0YXJ0UG9pbnQueSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpLFxuICAgIH07XG5cbiAgICBjb25zdCBlbmRQb2ludCA9IHtcbiAgICAgIHg6ICh0aGlzLmZyYW1lXy53aWR0aCAvIDIpIC0gKHRoaXMuaW5pdGlhbFNpemVfIC8gMiksXG4gICAgICB5OiAodGhpcy5mcmFtZV8uaGVpZ2h0IC8gMikgLSAodGhpcy5pbml0aWFsU2l6ZV8gLyAyKSxcbiAgICB9O1xuXG4gICAgcmV0dXJuIHtzdGFydFBvaW50LCBlbmRQb2ludH07XG4gIH1cblxuICAvKiogQHByaXZhdGUgKi9cbiAgcnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfKCkge1xuICAgIC8vIFRoaXMgbWV0aG9kIGlzIGNhbGxlZCBib3RoIHdoZW4gYSBwb2ludGluZyBkZXZpY2UgaXMgcmVsZWFzZWQsIGFuZCB3aGVuIHRoZSBhY3RpdmF0aW9uIGFuaW1hdGlvbiBlbmRzLlxuICAgIC8vIFRoZSBkZWFjdGl2YXRpb24gYW5pbWF0aW9uIHNob3VsZCBvbmx5IHJ1biBhZnRlciBib3RoIG9mIHRob3NlIG9jY3VyLlxuICAgIGNvbnN0IHtGR19ERUFDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGNvbnN0IHtoYXNEZWFjdGl2YXRpb25VWFJ1biwgaXNBY3RpdmF0ZWR9ID0gdGhpcy5hY3RpdmF0aW9uU3RhdGVfO1xuICAgIGNvbnN0IGFjdGl2YXRpb25IYXNFbmRlZCA9IGhhc0RlYWN0aXZhdGlvblVYUnVuIHx8ICFpc0FjdGl2YXRlZDtcblxuICAgIGlmIChhY3RpdmF0aW9uSGFzRW5kZWQgJiYgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfKSB7XG4gICAgICB0aGlzLnJtQm91bmRlZEFjdGl2YXRpb25DbGFzc2VzXygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hZGRDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgdGhpcy5mZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhGR19ERUFDVElWQVRJT04pO1xuICAgICAgfSwgbnVtYmVycy5GR19ERUFDVElWQVRJT05fTVMpO1xuICAgIH1cbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBybUJvdW5kZWRBY3RpdmF0aW9uQ2xhc3Nlc18oKSB7XG4gICAgY29uc3Qge0ZHX0FDVElWQVRJT059ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoRkdfQUNUSVZBVElPTik7XG4gICAgdGhpcy5hY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfID0gZmFsc2U7XG4gICAgdGhpcy5hZGFwdGVyXy5jb21wdXRlQm91bmRpbmdSZWN0KCk7XG4gIH1cblxuICByZXNldEFjdGl2YXRpb25TdGF0ZV8oKSB7XG4gICAgdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSB0aGlzLmFjdGl2YXRpb25TdGF0ZV8uYWN0aXZhdGlvbkV2ZW50O1xuICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXyA9IHRoaXMuZGVmYXVsdEFjdGl2YXRpb25TdGF0ZV8oKTtcbiAgICAvLyBUb3VjaCBkZXZpY2VzIG1heSBmaXJlIGFkZGl0aW9uYWwgZXZlbnRzIGZvciB0aGUgc2FtZSBpbnRlcmFjdGlvbiB3aXRoaW4gYSBzaG9ydCB0aW1lLlxuICAgIC8vIFN0b3JlIHRoZSBwcmV2aW91cyBldmVudCB1bnRpbCBpdCdzIHNhZmUgdG8gYXNzdW1lIHRoYXQgc3Vic2VxdWVudCBldmVudHMgYXJlIGZvciBuZXcgaW50ZXJhY3Rpb25zLlxuICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5wcmV2aW91c0FjdGl2YXRpb25FdmVudF8gPSBudWxsLCBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuVEFQX0RFTEFZX01TKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0gez9FdmVudH0gZVxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZGVhY3RpdmF0ZV8oZSkge1xuICAgIGNvbnN0IGFjdGl2YXRpb25TdGF0ZSA9IHRoaXMuYWN0aXZhdGlvblN0YXRlXztcbiAgICAvLyBUaGlzIGNhbiBoYXBwZW4gaW4gc2NlbmFyaW9zIHN1Y2ggYXMgd2hlbiB5b3UgaGF2ZSBhIGtleXVwIGV2ZW50IHRoYXQgYmx1cnMgdGhlIGVsZW1lbnQuXG4gICAgaWYgKCFhY3RpdmF0aW9uU3RhdGUuaXNBY3RpdmF0ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCBzdGF0ZSA9IC8qKiBAdHlwZSB7IUFjdGl2YXRpb25TdGF0ZVR5cGV9ICovIChPYmplY3QuYXNzaWduKHt9LCBhY3RpdmF0aW9uU3RhdGUpKTtcblxuICAgIGlmIChhY3RpdmF0aW9uU3RhdGUuaXNQcm9ncmFtbWF0aWMpIHtcbiAgICAgIGNvbnN0IGV2dE9iamVjdCA9IG51bGw7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4gdGhpcy5hbmltYXRlRGVhY3RpdmF0aW9uXyhldnRPYmplY3QsIHN0YXRlKSk7XG4gICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18oKTtcbiAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgIHRoaXMuYWN0aXZhdGlvblN0YXRlXy5oYXNEZWFjdGl2YXRpb25VWFJ1biA9IHRydWU7XG4gICAgICAgIHRoaXMuYW5pbWF0ZURlYWN0aXZhdGlvbl8oZSwgc3RhdGUpO1xuICAgICAgICB0aGlzLnJlc2V0QWN0aXZhdGlvblN0YXRlXygpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7P0V2ZW50PX0gZXZlbnQgT3B0aW9uYWwgZXZlbnQgY29udGFpbmluZyBwb3NpdGlvbiBpbmZvcm1hdGlvbi5cbiAgICovXG4gIGRlYWN0aXZhdGUoZXZlbnQgPSBudWxsKSB7XG4gICAgdGhpcy5kZWFjdGl2YXRlXyhldmVudCk7XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtFdmVudH0gZVxuICAgKiBAcGFyYW0geyFBY3RpdmF0aW9uU3RhdGVUeXBlfSBvcHRpb25zXG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBhbmltYXRlRGVhY3RpdmF0aW9uXyhlLCB7d2FzQWN0aXZhdGVkQnlQb2ludGVyLCB3YXNFbGVtZW50TWFkZUFjdGl2ZX0pIHtcbiAgICBpZiAod2FzQWN0aXZhdGVkQnlQb2ludGVyIHx8IHdhc0VsZW1lbnRNYWRlQWN0aXZlKSB7XG4gICAgICB0aGlzLnJ1bkRlYWN0aXZhdGlvblVYTG9naWNJZlJlYWR5XygpO1xuICAgIH1cbiAgfVxuXG4gIGxheW91dCgpIHtcbiAgICBpZiAodGhpcy5sYXlvdXRGcmFtZV8pIHtcbiAgICAgIGNhbmNlbEFuaW1hdGlvbkZyYW1lKHRoaXMubGF5b3V0RnJhbWVfKTtcbiAgICB9XG4gICAgdGhpcy5sYXlvdXRGcmFtZV8gPSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoKCkgPT4ge1xuICAgICAgdGhpcy5sYXlvdXRJbnRlcm5hbF8oKTtcbiAgICAgIHRoaXMubGF5b3V0RnJhbWVfID0gMDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKiBAcHJpdmF0ZSAqL1xuICBsYXlvdXRJbnRlcm5hbF8oKSB7XG4gICAgdGhpcy5mcmFtZV8gPSB0aGlzLmFkYXB0ZXJfLmNvbXB1dGVCb3VuZGluZ1JlY3QoKTtcbiAgICBjb25zdCBtYXhEaW0gPSBNYXRoLm1heCh0aGlzLmZyYW1lXy5oZWlnaHQsIHRoaXMuZnJhbWVfLndpZHRoKTtcblxuICAgIC8vIFN1cmZhY2UgZGlhbWV0ZXIgaXMgdHJlYXRlZCBkaWZmZXJlbnRseSBmb3IgdW5ib3VuZGVkIHZzLiBib3VuZGVkIHJpcHBsZXMuXG4gICAgLy8gVW5ib3VuZGVkIHJpcHBsZSBkaWFtZXRlciBpcyBjYWxjdWxhdGVkIHNtYWxsZXIgc2luY2UgdGhlIHN1cmZhY2UgaXMgZXhwZWN0ZWQgdG8gYWxyZWFkeSBiZSBwYWRkZWQgYXBwcm9wcmlhdGVseVxuICAgIC8vIHRvIGV4dGVuZCB0aGUgaGl0Ym94LCBhbmQgdGhlIHJpcHBsZSBpcyBleHBlY3RlZCB0byBtZWV0IHRoZSBlZGdlcyBvZiB0aGUgcGFkZGVkIGhpdGJveCAod2hpY2ggaXMgdHlwaWNhbGx5XG4gICAgLy8gc3F1YXJlKS4gQm91bmRlZCByaXBwbGVzLCBvbiB0aGUgb3RoZXIgaGFuZCwgYXJlIGZ1bGx5IGV4cGVjdGVkIHRvIGV4cGFuZCBiZXlvbmQgdGhlIHN1cmZhY2UncyBsb25nZXN0IGRpYW1ldGVyXG4gICAgLy8gKGNhbGN1bGF0ZWQgYmFzZWQgb24gdGhlIGRpYWdvbmFsIHBsdXMgYSBjb25zdGFudCBwYWRkaW5nKSwgYW5kIGFyZSBjbGlwcGVkIGF0IHRoZSBzdXJmYWNlJ3MgYm9yZGVyIHZpYVxuICAgIC8vIGBvdmVyZmxvdzogaGlkZGVuYC5cbiAgICBjb25zdCBnZXRCb3VuZGVkUmFkaXVzID0gKCkgPT4ge1xuICAgICAgY29uc3QgaHlwb3RlbnVzZSA9IE1hdGguc3FydChNYXRoLnBvdyh0aGlzLmZyYW1lXy53aWR0aCwgMikgKyBNYXRoLnBvdyh0aGlzLmZyYW1lXy5oZWlnaHQsIDIpKTtcbiAgICAgIHJldHVybiBoeXBvdGVudXNlICsgTURDUmlwcGxlRm91bmRhdGlvbi5udW1iZXJzLlBBRERJTkc7XG4gICAgfTtcblxuICAgIHRoaXMubWF4UmFkaXVzXyA9IHRoaXMuYWRhcHRlcl8uaXNVbmJvdW5kZWQoKSA/IG1heERpbSA6IGdldEJvdW5kZWRSYWRpdXMoKTtcblxuICAgIC8vIFJpcHBsZSBpcyBzaXplZCBhcyBhIGZyYWN0aW9uIG9mIHRoZSBsYXJnZXN0IGRpbWVuc2lvbiBvZiB0aGUgc3VyZmFjZSwgdGhlbiBzY2FsZXMgdXAgdXNpbmcgYSBDU1Mgc2NhbGUgdHJhbnNmb3JtXG4gICAgdGhpcy5pbml0aWFsU2l6ZV8gPSBtYXhEaW0gKiBNRENSaXBwbGVGb3VuZGF0aW9uLm51bWJlcnMuSU5JVElBTF9PUklHSU5fU0NBTEU7XG4gICAgdGhpcy5mZ1NjYWxlXyA9IHRoaXMubWF4UmFkaXVzXyAvIHRoaXMuaW5pdGlhbFNpemVfO1xuXG4gICAgdGhpcy51cGRhdGVMYXlvdXRDc3NWYXJzXygpO1xuICB9XG5cbiAgLyoqIEBwcml2YXRlICovXG4gIHVwZGF0ZUxheW91dENzc1ZhcnNfKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIFZBUl9GR19TSVpFLCBWQVJfTEVGVCwgVkFSX1RPUCwgVkFSX0ZHX1NDQUxFLFxuICAgIH0gPSBNRENSaXBwbGVGb3VuZGF0aW9uLnN0cmluZ3M7XG5cbiAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9GR19TSVpFLCBgJHt0aGlzLmluaXRpYWxTaXplX31weGApO1xuICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0ZHX1NDQUxFLCB0aGlzLmZnU2NhbGVfKTtcblxuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzVW5ib3VuZGVkKCkpIHtcbiAgICAgIHRoaXMudW5ib3VuZGVkQ29vcmRzXyA9IHtcbiAgICAgICAgbGVmdDogTWF0aC5yb3VuZCgodGhpcy5mcmFtZV8ud2lkdGggLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgICAgdG9wOiBNYXRoLnJvdW5kKCh0aGlzLmZyYW1lXy5oZWlnaHQgLyAyKSAtICh0aGlzLmluaXRpYWxTaXplXyAvIDIpKSxcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYWRhcHRlcl8udXBkYXRlQ3NzVmFyaWFibGUoVkFSX0xFRlQsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy5sZWZ0fXB4YCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnVwZGF0ZUNzc1ZhcmlhYmxlKFZBUl9UT1AsIGAke3RoaXMudW5ib3VuZGVkQ29vcmRzXy50b3B9cHhgKTtcbiAgICB9XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSB1bmJvdW5kZWQgKi9cbiAgc2V0VW5ib3VuZGVkKHVuYm91bmRlZCkge1xuICAgIGNvbnN0IHtVTkJPVU5ERUR9ID0gTURDUmlwcGxlRm91bmRhdGlvbi5jc3NDbGFzc2VzO1xuICAgIGlmICh1bmJvdW5kZWQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoVU5CT1VOREVEKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhVTkJPVU5ERUQpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENSaXBwbGVGb3VuZGF0aW9uO1xuIiwiaW1wb3J0IE1EQ1JpcHBsZUZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL3JpcHBsZS9mb3VuZGF0aW9uLmpzJ1xuaW1wb3J0IHtzdXBwb3J0c0Nzc1ZhcmlhYmxlcywgZ2V0TWF0Y2hlc1Byb3BlcnR5LCBhcHBseVBhc3NpdmV9IGZyb20gJ0BtYXRlcmlhbC9yaXBwbGUvdXRpbCdcblxuZXhwb3J0IGNsYXNzIFJpcHBsZUJhc2UgZXh0ZW5kcyBNRENSaXBwbGVGb3VuZGF0aW9uIHtcblxuICBzdGF0aWMgZ2V0IE1BVENIRVMgKCkge1xuICAgIC8qIGdsb2JhbCBIVE1MRWxlbWVudCAqL1xuICAgIHJldHVybiBSaXBwbGVCYXNlLl9tYXRjaGVzIHx8XG4gICAgICAoIFJpcHBsZUJhc2UuX21hdGNoZXMgPSBnZXRNYXRjaGVzUHJvcGVydHkoSFRNTEVsZW1lbnQucHJvdG90eXBlKSlcbiAgfVxuXG4gIHN0YXRpYyBpc1N1cmZhY2VBY3RpdmUgKHJlZikge1xuICAgIHJldHVybiByZWZbUmlwcGxlQmFzZS5NQVRDSEVTXSgnOmFjdGl2ZScpXG4gIH1cblxuICBjb25zdHJ1Y3RvciAodm0sIG9wdGlvbnMpIHtcbiAgICBzdXBlcihPYmplY3QuYXNzaWduKHtcbiAgICAgIGJyb3dzZXJTdXBwb3J0c0Nzc1ZhcnM6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHN1cHBvcnRzQ3NzVmFyaWFibGVzKHdpbmRvdylcbiAgICAgIH0sXG4gICAgICBpc1VuYm91bmRlZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH0sXG4gICAgICBpc1N1cmZhY2VBY3RpdmU6ICgpID0+IHtcbiAgICAgICAgcmV0dXJuIHZtLiRlbFtSaXBwbGVCYXNlLk1BVENIRVNdKCc6YWN0aXZlJylcbiAgICAgIH0sXG4gICAgICBpc1N1cmZhY2VEaXNhYmxlZDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdm0uZGlzYWJsZWRcbiAgICAgIH0sXG4gICAgICBhZGRDbGFzcyAoY2xhc3NOYW1lKSB7XG4gICAgICAgIHZtLiRzZXQodm0uY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKVxuICAgICAgfSxcbiAgICAgIHJlbW92ZUNsYXNzIChjbGFzc05hbWUpIHtcbiAgICAgICAgdm0uJGRlbGV0ZSh2bS5jbGFzc2VzLCBjbGFzc05hbWUpXG4gICAgICB9LFxuICAgICAgY29udGFpbnNFdmVudFRhcmdldDogKHRhcmdldCkgPT4gdm0uJGVsLmNvbnRhaW5zKHRhcmdldCksXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB2bS4kZWwuYWRkRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKGV2dCwgaGFuZGxlcikgPT4ge1xuICAgICAgICB2bS4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldnQsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIGRlcmVnaXN0ZXJEb2N1bWVudEludGVyYWN0aW9uSGFuZGxlcjogKGV2dFR5cGUsIGhhbmRsZXIpID0+XG4gICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5yZW1vdmVFdmVudExpc3RlbmVyKGV2dFR5cGUsIGhhbmRsZXIsIGFwcGx5UGFzc2l2ZSgpKSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogKGhhbmRsZXIpID0+IHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKVxuICAgICAgfSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoaGFuZGxlcikgPT4ge1xuICAgICAgICByZXR1cm4gd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Jlc2l6ZScsIGhhbmRsZXIpXG4gICAgICB9LFxuICAgICAgdXBkYXRlQ3NzVmFyaWFibGU6ICh2YXJOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB2bS4kc2V0KHZtLnN0eWxlcywgdmFyTmFtZSwgdmFsdWUpXG4gICAgICB9LFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gdm0uJGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgICB9LFxuICAgICAgZ2V0V2luZG93UGFnZU9mZnNldDogKCkgPT4ge1xuICAgICAgICByZXR1cm4gKHt4OiB3aW5kb3cucGFnZVhPZmZzZXQsIHk6IHdpbmRvdy5wYWdlWU9mZnNldH0pXG4gICAgICB9LFxuICAgIH0sIG9wdGlvbnMpKVxuICB9XG59XG5cbmV4cG9ydCBjb25zdCBSaXBwbGVNaXhpbiA9IHtcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIGNsYXNzZXM6IHt9LFxuICAgICAgc3R5bGVzOiB7fVxuICAgIH1cbiAgfSxcbiAgbW91bnRlZCAoKSB7XG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKVxuICAgIHRoaXMucmlwcGxlLmluaXQoKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLnJpcHBsZS5kZXN0cm95KClcbiAgfVxufSAgIiwiPHRlbXBsYXRlPlxyXG4gIDxjdXN0b20tbGluayA6bGluaz1cImxpbmtcIlxyXG4gICAgY2xhc3M9XCJtZGMtZHJhd2VyLWl0ZW0gbWRjLWxpc3QtaXRlbVwiXHJcbiAgICA6Y2xhc3M9XCJbY2xhc3NlcywgaXRlbUNsYXNzZXNdXCIgOnN0eWxlPVwic3R5bGVzXCJcclxuICAgIHYtb249XCJteWxpc3RlbmVyc1wiPlxyXG4gICAgPHNwYW4gY2xhc3M9XCJtZGMtbGlzdC1pdGVtX19ncmFwaGljXCIgdi1pZj1cImhhc1N0YXJ0RGV0YWlsXCI+XHJcbiAgICAgIDxzbG90IG5hbWU9XCJzdGFydC1kZXRhaWxcIj5cclxuICAgICAgICA8aSBjbGFzcz1cIm1hdGVyaWFsLWljb25zXCIgYXJpYS1oaWRkZW49XCJ0cnVlXCI+e3tzdGFydEljb259fTwvaT5cclxuICAgICAgPC9zbG90PlxyXG4gICAgPC9zcGFuPlxyXG4gICAgPHNsb3Q+PC9zbG90PlxyXG4gIDwvY3VzdG9tLWxpbms+XHJcbjwvdGVtcGxhdGU+XHJcblxyXG48c2NyaXB0PlxyXG5pbXBvcnQgeyBEaXNwYXRjaEV2ZW50TWl4aW4sIEN1c3RvbUxpbmtNaXhpbiB9IGZyb20gJy4uL2Jhc2UnO1xyXG5pbXBvcnQgeyBSaXBwbGVCYXNlIH0gZnJvbSAnLi4vcmlwcGxlJztcclxuXHJcbmV4cG9ydCBkZWZhdWx0IHtcclxuICBuYW1lOiAnbWRjLWRyYXdlci1pdGVtJyxcclxuICBpbmplY3Q6IFsnbWRjRHJhd2VyJ10sXHJcbiAgbWl4aW5zOiBbRGlzcGF0Y2hFdmVudE1peGluLCBDdXN0b21MaW5rTWl4aW5dLFxyXG4gIHByb3BzOiB7XHJcbiAgICBzdGFydEljb246IFN0cmluZyxcclxuICAgIHRlbXBvcmFyeUNsb3NlOiB7XHJcbiAgICAgIHR5cGU6IEJvb2xlYW4sXHJcbiAgICAgIGRlZmF1bHQ6IHRydWUsXHJcbiAgICB9LFxyXG4gICAgYWN0aXZhdGVkOiBCb29sZWFuLFxyXG4gICAgZXhhY3RBY3RpdmVDbGFzczoge1xyXG4gICAgICB0eXBlOiBTdHJpbmcsXHJcbiAgICAgIGRlZmF1bHQ6ICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnLFxyXG4gICAgfSxcclxuICB9LFxyXG4gIGRhdGEoKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBjbGFzc2VzOiB7fSxcclxuICAgICAgc3R5bGVzOiB7fSxcclxuICAgIH07XHJcbiAgfSxcclxuICBjb21wdXRlZDoge1xyXG4gICAgbXlsaXN0ZW5lcnMoKSB7XHJcbiAgICAgIHJldHVybiB7XHJcbiAgICAgICAgLi4udGhpcy4kbGlzdGVuZXJzLFxyXG4gICAgICAgIGNsaWNrOiBlID0+IHtcclxuICAgICAgICAgIHRoaXMubWRjRHJhd2VyLmlzVGVtcG9yYXJ5ICYmXHJcbiAgICAgICAgICAgIHRoaXMudGVtcG9yYXJ5Q2xvc2UgJiZcclxuICAgICAgICAgICAgdGhpcy5tZGNEcmF3ZXIuY2xvc2UoKTtcclxuICAgICAgICAgIHRoaXMuZGlzcGF0Y2hFdmVudChlKTtcclxuICAgICAgICB9LFxyXG4gICAgICB9O1xyXG4gICAgfSxcclxuICAgIGl0ZW1DbGFzc2VzKCkge1xyXG4gICAgICByZXR1cm4ge1xyXG4gICAgICAgICdtZGMtbGlzdC1pdGVtLS1hY3RpdmF0ZWQnOiB0aGlzLmFjdGl2YXRlZCxcclxuICAgICAgfTtcclxuICAgIH0sXHJcbiAgICBoYXNTdGFydERldGFpbCgpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuc3RhcnRJY29uIHx8IHRoaXMuJHNsb3RzWydzdGFydC1kZXRhaWwnXTtcclxuICAgIH0sXHJcbiAgfSxcclxuICBtb3VudGVkKCkge1xyXG4gICAgdGhpcy5yaXBwbGUgPSBuZXcgUmlwcGxlQmFzZSh0aGlzKTtcclxuICAgIHRoaXMucmlwcGxlLmluaXQoKTtcclxuICB9LFxyXG4gIGJlZm9yZURlc3Ryb3koKSB7XHJcbiAgICB0aGlzLnJpcHBsZSAmJiB0aGlzLnJpcHBsZS5kZXN0cm95KCk7XHJcbiAgICB0aGlzLnJpcHBsZSA9IG51bGw7XHJcbiAgfSxcclxufTtcclxuPC9zY3JpcHQ+XHJcbiIsIjx0ZW1wbGF0ZT5cbiAgPGhyIGNsYXNzPVwibWRjLWxpc3QtZGl2aWRlclwiPlxuPC90ZW1wbGF0ZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1kcmF3ZXItZGl2aWRlcicsXG59XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNEcmF3ZXIgZnJvbSAnLi9tZGMtZHJhd2VyLnZ1ZSdcbmltcG9ydCBtZGNEcmF3ZXJMYXlvdXQgZnJvbSAnLi9tZGMtZHJhd2VyLWxheW91dC52dWUnXG5pbXBvcnQgbWRjRHJhd2VySGVhZGVyIGZyb20gJy4vbWRjLWRyYXdlci1oZWFkZXIudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckxpc3QgZnJvbSAnLi9tZGMtZHJhd2VyLWxpc3QudnVlJ1xuaW1wb3J0IG1kY0RyYXdlckl0ZW0gZnJvbSAnLi9tZGMtZHJhd2VyLWl0ZW0udnVlJ1xuaW1wb3J0IG1kY0RyYXdlckRpdmlkZXIgZnJvbSAnLi9tZGMtZHJhd2VyLWRpdmlkZXIudnVlJ1xuXG5leHBvcnQge1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNEcmF3ZXIsXG4gIG1kY0RyYXdlckxheW91dCxcbiAgbWRjRHJhd2VySGVhZGVyLFxuICBtZGNEcmF3ZXJMaXN0LFxuICBtZGNEcmF3ZXJJdGVtLFxuICBtZGNEcmF3ZXJEaXZpZGVyXG59KSIsImltcG9ydCAnLi9zdHlsZXMuc2NzcydcbmltcG9ydCB7YXV0b0luaXR9IGZyb20gJy4uL2Jhc2UnXG5pbXBvcnQgcGx1Z2luIGZyb20gJy4vaW5kZXguanMnXG5leHBvcnQgZGVmYXVsdCBwbHVnaW5cblxuYXV0b0luaXQocGx1Z2luKVxuIl0sIm5hbWVzIjpbImF1dG9Jbml0IiwicGx1Z2luIiwiX1Z1ZSIsIndpbmRvdyIsIlZ1ZSIsImdsb2JhbCIsInVzZSIsIkJhc2VQbHVnaW4iLCJjb21wb25lbnRzIiwidmVyc2lvbiIsImluc3RhbGwiLCJ2bSIsImtleSIsImNvbXBvbmVudCIsIm5hbWUiLCJDdXN0b21MaW5rIiwiZnVuY3Rpb25hbCIsInByb3BzIiwidGFnIiwidHlwZSIsIlN0cmluZyIsImRlZmF1bHQiLCJsaW5rIiwiT2JqZWN0IiwicmVuZGVyIiwiaCIsImNvbnRleHQiLCJlbGVtZW50IiwiZGF0YSIsImJhYmVsSGVscGVycy5leHRlbmRzIiwicGFyZW50IiwiJHJvdXRlciIsIiRyb290IiwiJG9wdGlvbnMiLCJvbiIsImNsaWNrIiwibmF0aXZlT24iLCJjaGlsZHJlbiIsIkN1c3RvbUxpbmtNaXhpbiIsInRvIiwiZXhhY3QiLCJCb29sZWFuIiwiYXBwZW5kIiwicmVwbGFjZSIsImFjdGl2ZUNsYXNzIiwiZXhhY3RBY3RpdmVDbGFzcyIsImNvbXB1dGVkIiwiRGlzcGF0Y2hFdmVudE1peGluIiwiZXZlbnQiLCJBcnJheSIsIm1ldGhvZHMiLCJkaXNwYXRjaEV2ZW50IiwiZXZ0IiwiJGVtaXQiLCJ0YXJnZXQiLCJldmVudFRhcmdldCIsImFyZ3MiLCJldmVudEFyZ3MiLCJsaXN0ZW5lcnMiLCIkbGlzdGVuZXJzIiwiZSIsIkZPQ1VTQUJMRV9FTEVNRU5UUyIsIk1EQ0ZvdW5kYXRpb24iLCJhZGFwdGVyIiwiYWRhcHRlcl8iLCJNRENDb21wb25lbnQiLCJyb290IiwiZm91bmRhdGlvbiIsInVuZGVmaW5lZCIsInJvb3RfIiwiaW5pdGlhbGl6ZSIsImZvdW5kYXRpb25fIiwiZ2V0RGVmYXVsdEZvdW5kYXRpb24iLCJpbml0IiwiaW5pdGlhbFN5bmNXaXRoRE9NIiwiRXJyb3IiLCJkZXN0cm95IiwiZXZ0VHlwZSIsImhhbmRsZXIiLCJhZGRFdmVudExpc3RlbmVyIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsImV2dERhdGEiLCJzaG91bGRCdWJibGUiLCJDdXN0b21FdmVudCIsImRldGFpbCIsImJ1YmJsZXMiLCJkb2N1bWVudCIsImNyZWF0ZUV2ZW50IiwiaW5pdEN1c3RvbUV2ZW50IiwiTURDU2xpZGFibGVEcmF3ZXJGb3VuZGF0aW9uIiwiYWRkQ2xhc3MiLCJyZW1vdmVDbGFzcyIsImhhc0NsYXNzIiwiaGFzTmVjZXNzYXJ5RG9tIiwicmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJEcmF3ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJkZXJlZ2lzdGVyRHJhd2VySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsImRlcmVnaXN0ZXJUcmFuc2l0aW9uRW5kSGFuZGxlciIsInJlZ2lzdGVyRG9jdW1lbnRLZXlkb3duSGFuZGxlciIsImRlcmVnaXN0ZXJEb2N1bWVudEtleWRvd25IYW5kbGVyIiwic2V0VHJhbnNsYXRlWCIsImdldEZvY3VzYWJsZUVsZW1lbnRzIiwic2F2ZUVsZW1lbnRUYWJTdGF0ZSIsInJlc3RvcmVFbGVtZW50VGFiU3RhdGUiLCJtYWtlRWxlbWVudFVudGFiYmFibGUiLCJub3RpZnlPcGVuIiwibm90aWZ5Q2xvc2UiLCJpc1J0bCIsImdldERyYXdlcldpZHRoIiwicm9vdENzc0NsYXNzIiwiYW5pbWF0aW5nQ3NzQ2xhc3MiLCJvcGVuQ3NzQ2xhc3MiLCJkZWZhdWx0QWRhcHRlciIsInJvb3RDc3NDbGFzc18iLCJhbmltYXRpbmdDc3NDbGFzc18iLCJvcGVuQ3NzQ2xhc3NfIiwidHJhbnNpdGlvbkVuZEhhbmRsZXJfIiwiaGFuZGxlVHJhbnNpdGlvbkVuZF8iLCJpbmVydF8iLCJjb21wb25lbnRUb3VjaFN0YXJ0SGFuZGxlcl8iLCJoYW5kbGVUb3VjaFN0YXJ0XyIsImNvbXBvbmVudFRvdWNoTW92ZUhhbmRsZXJfIiwiaGFuZGxlVG91Y2hNb3ZlXyIsImNvbXBvbmVudFRvdWNoRW5kSGFuZGxlcl8iLCJoYW5kbGVUb3VjaEVuZF8iLCJkb2N1bWVudEtleWRvd25IYW5kbGVyXyIsImtleUNvZGUiLCJjbG9zZSIsIlJPT1QiLCJPUEVOIiwiaXNPcGVuXyIsImRldGFiaW5hdGVfIiwicmV0YWJpbmF0ZV8iLCJlbGVtZW50cyIsImkiLCJsZW5ndGgiLCJwb2ludGVyVHlwZSIsImRpcmVjdGlvbl8iLCJkcmF3ZXJXaWR0aF8iLCJzdGFydFhfIiwidG91Y2hlcyIsInBhZ2VYIiwiY3VycmVudFhfIiwidXBkYXRlUmFmXyIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsInVwZGF0ZURyYXdlcl8iLCJiaW5kIiwicHJlcGFyZUZvclRvdWNoRW5kXyIsIk1hdGgiLCJhYnMiLCJuZXdQb3NpdGlvbl8iLCJvcGVuIiwiY2FuY2VsQW5pbWF0aW9uRnJhbWUiLCJpc1Jvb3RUcmFuc2l0aW9uaW5nRXZlbnRUYXJnZXRfIiwibmV3UG9zIiwibWluIiwibWF4IiwiY3NzQ2xhc3NlcyIsIkFOSU1BVElORyIsInN0cmluZ3MiLCJEUkFXRVJfU0VMRUNUT1IiLCJPUEVOX0VWRU5UIiwiQ0xPU0VfRVZFTlQiLCJNRENQZXJzaXN0ZW50RHJhd2VyRm91bmRhdGlvbiIsImlzRHJhd2VyIiwiZWwiLCJUQUJfREFUQSIsIlRBQl9EQVRBX0hBTkRMRUQiLCJzdG9yZWRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWVfIiwic3VwcG9ydHNQYXNzaXZlXyIsInJlbWFwRXZlbnQiLCJldmVudE5hbWUiLCJnbG9iYWxPYmoiLCJnZXRUcmFuc2Zvcm1Qcm9wZXJ0eU5hbWUiLCJmb3JjZVJlZnJlc2giLCJjcmVhdGVFbGVtZW50IiwidHJhbnNmb3JtUHJvcGVydHlOYW1lIiwic3R5bGUiLCJzdXBwb3J0c0Nzc0N1c3RvbVByb3BlcnRpZXMiLCJDU1MiLCJzdXBwb3J0cyIsImFwcGx5UGFzc2l2ZSIsImlzU3VwcG9ydGVkIiwicGFzc2l2ZSIsImhhc0F0dHJpYnV0ZSIsInNldEF0dHJpYnV0ZSIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUF0dHJpYnV0ZSIsIm1vZGVsIiwicHJvcCIsImNsYXNzZXMiLCJ3YXRjaCIsIl9yZWZyZXNoIiwibW91bnRlZCIsImNsYXNzTmFtZSIsIiRzZXQiLCIkZGVsZXRlIiwiJGVsIiwiY2xhc3NMaXN0IiwiY29udGFpbnMiLCIkcmVmcyIsImRyYXdlciIsInV0aWwiLCJvZmZzZXRXaWR0aCIsInZhbHVlIiwic2V0UHJvcGVydHkiLCJxdWVyeVNlbGVjdG9yQWxsIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsImdldFByb3BlcnR5VmFsdWUiLCJiZWZvcmVEZXN0cm95IiwiU0NST0xMX0xPQ0siLCJPUEFDSVRZX1ZBUl9OQU1FIiwiTURDVGVtcG9yYXJ5RHJhd2VyRm91bmRhdGlvbiIsImFkZEJvZHlDbGFzcyIsInJlbW92ZUJvZHlDbGFzcyIsInVwZGF0ZUNzc1ZhcmlhYmxlIiwiZXZlbnRUYXJnZXRIYXNDbGFzcyIsImNvbXBvbmVudENsaWNrSGFuZGxlcl8iLCJlbmFibGVTY3JvbGxfIiwiZGlzYWJsZVNjcm9sbF8iLCJuZXdPcGFjaXR5IiwiYm9keSIsImFkZCIsInJlbW92ZSIsImJ1c18iLCJldmVudEJ1cyIsInZ1ZSIsIiRvbiIsImNhbGxiYWNrIiwiJG9uY2UiLCIkb2ZmIiwibWVkaWEiLCJfc21hbGwiLCJtYXRjaE1lZGlhIiwiX2xhcmdlIiwicGVybWFuZW50IiwicGVyc2lzdGVudCIsInRlbXBvcmFyeSIsImRyYXdlclR5cGUiLCJ2YWxpZGF0b3IiLCJ2YWwiLCJ0b29sYmFyU3BhY2VyIiwidG9nZ2xlT24iLCJ0b2dnbGVPblNvdXJjZSIsInJlcXVpcmVkIiwib3Blbk9uIiwib3Blbk9uU291cmNlIiwiY2xvc2VPbiIsImNsb3NlT25Tb3VyY2UiLCJwcm92aWRlIiwibWRjRHJhd2VyIiwic21hbGwiLCJsYXJnZSIsIm9wZW5fIiwibWRjUGVybWFuZW50RHJhd2VyIiwibWRjUGVyc2lzdGVudERyYXdlciIsIm1kY1RlbXBvcmFyeURyYXdlciIsImlzUGVybWFuZW50IiwiaXNQZXJzaXN0ZW50IiwiaXNUZW1wb3JhcnkiLCJpc1Jlc3BvbnNpdmUiLCJidXNlbWl0IiwidG9nZ2xlIiwiaXNPcGVuIiwicmVmcmVzaE1lZGlhIiwibWF0Y2hlcyIsImNyZWF0ZWQiLCJ0b2dnbGVPbkV2ZW50U291cmNlIiwib3Blbk9uRXZlbnRTb3VyY2UiLCJjbG9zZU9uRXZlbnRTb3VyY2UiLCJhZGRMaXN0ZW5lciIsIiRuZXh0VGljayIsInJlbW92ZUxpc3RlbmVyIiwiaW5qZWN0Iiwic2hvdyIsImRlbnNlIiwiTURDUmlwcGxlQWRhcHRlciIsInZhck5hbWUiLCJVTkJPVU5ERUQiLCJCR19GT0NVU0VEIiwiRkdfQUNUSVZBVElPTiIsIkZHX0RFQUNUSVZBVElPTiIsIlZBUl9MRUZUIiwiVkFSX1RPUCIsIlZBUl9GR19TSVpFIiwiVkFSX0ZHX1NDQUxFIiwiVkFSX0ZHX1RSQU5TTEFURV9TVEFSVCIsIlZBUl9GR19UUkFOU0xBVEVfRU5EIiwibnVtYmVycyIsIlBBRERJTkciLCJJTklUSUFMX09SSUdJTl9TQ0FMRSIsIkRFQUNUSVZBVElPTl9USU1FT1VUX01TIiwiRkdfREVBQ1RJVkFUSU9OX01TIiwiVEFQX0RFTEFZX01TIiwic3VwcG9ydHNDc3NWYXJpYWJsZXNfIiwiZGV0ZWN0RWRnZVBzZXVkb1ZhckJ1ZyIsIndpbmRvd09iaiIsIm5vZGUiLCJhcHBlbmRDaGlsZCIsImNvbXB1dGVkU3R5bGUiLCJoYXNQc2V1ZG9WYXJCdWciLCJib3JkZXJUb3BTdHlsZSIsInN1cHBvcnRzQ3NzVmFyaWFibGVzIiwic3VwcG9ydHNGdW5jdGlvblByZXNlbnQiLCJleHBsaWNpdGx5U3VwcG9ydHNDc3NWYXJzIiwid2VBcmVGZWF0dXJlRGV0ZWN0aW5nU2FmYXJpMTBwbHVzIiwiZ2V0TWF0Y2hlc1Byb3BlcnR5IiwiSFRNTEVsZW1lbnRQcm90b3R5cGUiLCJmaWx0ZXIiLCJwIiwicG9wIiwiZ2V0Tm9ybWFsaXplZEV2ZW50Q29vcmRzIiwiZXYiLCJwYWdlT2Zmc2V0IiwiY2xpZW50UmVjdCIsIngiLCJ5IiwiZG9jdW1lbnRYIiwibGVmdCIsImRvY3VtZW50WSIsInRvcCIsIm5vcm1hbGl6ZWRYIiwibm9ybWFsaXplZFkiLCJjaGFuZ2VkVG91Y2hlcyIsInBhZ2VZIiwiQUNUSVZBVElPTl9FVkVOVF9UWVBFUyIsIlBPSU5URVJfREVBQ1RJVkFUSU9OX0VWRU5UX1RZUEVTIiwiYWN0aXZhdGVkVGFyZ2V0cyIsIk1EQ1JpcHBsZUZvdW5kYXRpb24iLCJicm93c2VyU3VwcG9ydHNDc3NWYXJzIiwiaXNVbmJvdW5kZWQiLCJpc1N1cmZhY2VBY3RpdmUiLCJpc1N1cmZhY2VEaXNhYmxlZCIsImNvbnRhaW5zRXZlbnRUYXJnZXQiLCJyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckRvY3VtZW50SW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJSZXNpemVIYW5kbGVyIiwiZGVyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJjb21wdXRlQm91bmRpbmdSZWN0IiwiZ2V0V2luZG93UGFnZU9mZnNldCIsImxheW91dEZyYW1lXyIsImZyYW1lXyIsIndpZHRoIiwiaGVpZ2h0IiwiYWN0aXZhdGlvblN0YXRlXyIsImRlZmF1bHRBY3RpdmF0aW9uU3RhdGVfIiwiaW5pdGlhbFNpemVfIiwibWF4UmFkaXVzXyIsImFjdGl2YXRlSGFuZGxlcl8iLCJhY3RpdmF0ZV8iLCJkZWFjdGl2YXRlSGFuZGxlcl8iLCJkZWFjdGl2YXRlXyIsImZvY3VzSGFuZGxlcl8iLCJibHVySGFuZGxlcl8iLCJyZXNpemVIYW5kbGVyXyIsImxheW91dCIsInVuYm91bmRlZENvb3Jkc18iLCJmZ1NjYWxlXyIsImFjdGl2YXRpb25UaW1lcl8iLCJmZ0RlYWN0aXZhdGlvblJlbW92YWxUaW1lcl8iLCJhY3RpdmF0aW9uQW5pbWF0aW9uSGFzRW5kZWRfIiwiYWN0aXZhdGlvblRpbWVyQ2FsbGJhY2tfIiwicnVuRGVhY3RpdmF0aW9uVVhMb2dpY0lmUmVhZHlfIiwicHJldmlvdXNBY3RpdmF0aW9uRXZlbnRfIiwiaXNBY3RpdmF0ZWQiLCJoYXNEZWFjdGl2YXRpb25VWFJ1biIsIndhc0FjdGl2YXRlZEJ5UG9pbnRlciIsIndhc0VsZW1lbnRNYWRlQWN0aXZlIiwiYWN0aXZhdGlvbkV2ZW50IiwiaXNQcm9ncmFtbWF0aWMiLCJpc1N1cHBvcnRlZF8iLCJyZWdpc3RlclJvb3RIYW5kbGVyc18iLCJsYXlvdXRJbnRlcm5hbF8iLCJjbGVhclRpbWVvdXQiLCJkZXJlZ2lzdGVyUm9vdEhhbmRsZXJzXyIsImRlcmVnaXN0ZXJEZWFjdGl2YXRpb25IYW5kbGVyc18iLCJyZW1vdmVDc3NWYXJzXyIsImZvckVhY2giLCJrZXlzIiwiayIsImluZGV4T2YiLCJhY3RpdmF0aW9uU3RhdGUiLCJwcmV2aW91c0FjdGl2YXRpb25FdmVudCIsImlzU2FtZUludGVyYWN0aW9uIiwiaGFzQWN0aXZhdGVkQ2hpbGQiLCJzb21lIiwicmVzZXRBY3RpdmF0aW9uU3RhdGVfIiwicHVzaCIsInJlZ2lzdGVyRGVhY3RpdmF0aW9uSGFuZGxlcnNfIiwiYW5pbWF0ZUFjdGl2YXRpb25fIiwidHJhbnNsYXRlU3RhcnQiLCJ0cmFuc2xhdGVFbmQiLCJnZXRGZ1RyYW5zbGF0aW9uQ29vcmRpbmF0ZXNfIiwic3RhcnRQb2ludCIsImVuZFBvaW50Iiwicm1Cb3VuZGVkQWN0aXZhdGlvbkNsYXNzZXNfIiwic2V0VGltZW91dCIsImFjdGl2YXRpb25IYXNFbmRlZCIsInN0YXRlIiwiZXZ0T2JqZWN0IiwiYW5pbWF0ZURlYWN0aXZhdGlvbl8iLCJtYXhEaW0iLCJnZXRCb3VuZGVkUmFkaXVzIiwiaHlwb3RlbnVzZSIsInNxcnQiLCJwb3ciLCJ1cGRhdGVMYXlvdXRDc3NWYXJzXyIsInJvdW5kIiwidW5ib3VuZGVkIiwiUmlwcGxlQmFzZSIsInJlZiIsIk1BVENIRVMiLCJfbWF0Y2hlcyIsIkhUTUxFbGVtZW50IiwicHJvdG90eXBlIiwib3B0aW9ucyIsImRpc2FibGVkIiwiZG9jdW1lbnRFbGVtZW50Iiwic3R5bGVzIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicGFnZVhPZmZzZXQiLCJwYWdlWU9mZnNldCIsIm1peGlucyIsInN0YXJ0SWNvbiIsInRlbXBvcmFyeUNsb3NlIiwiYWN0aXZhdGVkIiwibXlsaXN0ZW5lcnMiLCJpdGVtQ2xhc3NlcyIsImhhc1N0YXJ0RGV0YWlsIiwiJHNsb3RzIiwicmlwcGxlIiwibWRjRHJhd2VyTGF5b3V0IiwibWRjRHJhd2VySGVhZGVyIiwibWRjRHJhd2VyTGlzdCIsIm1kY0RyYXdlckl0ZW0iLCJtZGNEcmF3ZXJEaXZpZGVyIl0sIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7O0VBQU8sU0FBU0EsUUFBVCxDQUFtQkMsTUFBbkIsRUFBMkI7RUFDaEM7RUFDQSxNQUFJQyxPQUFPLElBQVg7RUFDQSxNQUFJLE9BQU9DLE1BQVAsS0FBa0IsV0FBdEIsRUFBbUM7RUFDakNELFdBQU9DLE9BQU9DLEdBQWQ7RUFDRCxHQUZELE1BRU8sSUFBSSxPQUFPQyxNQUFQLEtBQWtCLFdBQXRCLEVBQW1DO0VBQ3hDO0VBQ0FILFdBQU9HLE9BQU9ELEdBQWQ7RUFDRDtFQUNELE1BQUlGLElBQUosRUFBVTtFQUNSQSxTQUFLSSxHQUFMLENBQVNMLE1BQVQ7RUFDRDtFQUNGOztFQ1pNLFNBQVNNLFVBQVQsQ0FBcUJDLFVBQXJCLEVBQWlDO0VBQ3RDLFNBQU87RUFDTEMsYUFBUyxRQURKO0VBRUxDLGFBQVMsaUJBQUNDLEVBQUQsRUFBUTtFQUNmLFdBQUssSUFBSUMsR0FBVCxJQUFnQkosVUFBaEIsRUFBNEI7RUFDMUIsWUFBSUssWUFBWUwsV0FBV0ksR0FBWCxDQUFoQjtFQUNFRCxXQUFHRSxTQUFILENBQWFBLFVBQVVDLElBQXZCLEVBQTRCRCxTQUE1QjtFQUNIO0VBQ0YsS0FQSTtFQVFMTDtFQVJLLEdBQVA7RUFVRDs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7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
