/**
* @module vue-mdc-adapterslider 0.14.0
* @exports VueMDCSlider
* @copyright (c) 2017-present, Sebastien Tasson
* @license https://opensource.org/licenses/MIT
* @implements {"material-components-web":"^0.34.1"}
* @requires {"vue":"^2.5.6"}
* @see https://github.com/stasson/vue-mdc-adapter
*/

(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
  typeof define === 'function' && define.amd ? define(factory) :
  (global.VueMDCSlider = factory());
}(this, (function () { 'use strict';

  function autoInit(plugin) {
    // Auto-install
    var _Vue = null;
    if (typeof window !== 'undefined') {
      _Vue = window.Vue;
    } else if (typeof global !== 'undefined') {
      /*global global*/
      _Vue = global.Vue;
    }
    if (_Vue) {
      _Vue.use(plugin);
    }
  }

  function BasePlugin(components) {
    return {
      version: '0.14.0',
      install: function install(vm) {
        for (var key in components) {
          var component = components[key];
          vm.component(component.name, component);
        }
      },
      components: components
    };
  }

  var classCallCheck = function (instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var inherits = function (subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
      throw new TypeError("Super expression must either be null or a function, not " + typeof superClass);
    }

    subClass.prototype = Object.create(superClass && superClass.prototype, {
      constructor: {
        value: subClass,
        enumerable: false,
        writable: true,
        configurable: true
      }
    });
    if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
  };

  var possibleConstructorReturn = function (self, call) {
    if (!self) {
      throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }

    return call && (typeof call === "object" || typeof call === "function") ? call : self;
  };

  var toConsumableArray = function (arr) {
    if (Array.isArray(arr)) {
      for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];

      return arr2;
    } else {
      return Array.from(arr);
    }
  };

  /* global CustomEvent */

  var DispatchFocusMixin = {
    data: function data() {
      return { hasFocus: false };
    },

    methods: {
      onMouseDown: function onMouseDown() {
        this._active = true;
      },
      onMouseUp: function onMouseUp() {
        this._active = false;
      },
      onFocusEvent: function onFocusEvent() {
        var _this = this;

        // dispatch async to let time to other focus event to propagate
        setTimeout(function () {
          return _this.dispatchFocusEvent();
        }, 0);
      },
      onBlurEvent: function onBlurEvent() {
        var _this2 = this;

        // dispatch async to let time to other focus event to propagate
        // also filtur blur if mousedown
        this._active || setTimeout(function () {
          return _this2.dispatchFocusEvent();
        }, 0);
      },
      dispatchFocusEvent: function dispatchFocusEvent() {
        var hasFocus = this.$el === document.activeElement || this.$el.contains(document.activeElement);
        if (hasFocus != this.hasFocus) {
          this.$emit(hasFocus ? 'focus' : 'blur');
          this.hasFocus = hasFocus;
        }
      }
    },
    mounted: function mounted() {
      this.$el.addEventListener('focusin', this.onFocusEvent);
      this.$el.addEventListener('focusout', this.onBlurEvent);
      this.$el.addEventListener('mousedown', this.onMouseDown);
      this.$el.addEventListener('mouseup', this.onMouseUp);
    },
    beforeDestroy: function beforeDestroy() {
      this.$el.removeEventListener('focusin', this.onFocusEvent);
      this.$el.removeEventListener('focusout', this.onBlurEvent);
      this.$el.removeEventListener('mousedown', this.onMouseDown);
      this.$el.removeEventListener('mouseup', this.onMouseUp);
    }
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var cssClasses = {
    ACTIVE: 'mdc-slider--active',
    DISABLED: 'mdc-slider--disabled',
    DISCRETE: 'mdc-slider--discrete',
    FOCUS: 'mdc-slider--focus',
    IN_TRANSIT: 'mdc-slider--in-transit',
    IS_DISCRETE: 'mdc-slider--discrete',
    HAS_TRACK_MARKER: 'mdc-slider--display-markers'
  };

  /** @enum {string} */
  var strings = {
    TRACK_SELECTOR: '.mdc-slider__track',
    TRACK_MARKER_CONTAINER_SELECTOR: '.mdc-slider__track-marker-container',
    LAST_TRACK_MARKER_SELECTOR: '.mdc-slider__track-marker:last-child',
    THUMB_CONTAINER_SELECTOR: '.mdc-slider__thumb-container',
    PIN_VALUE_MARKER_SELECTOR: '.mdc-slider__pin-value-marker',
    ARIA_VALUEMIN: 'aria-valuemin',
    ARIA_VALUEMAX: 'aria-valuemax',
    ARIA_VALUENOW: 'aria-valuenow',
    ARIA_DISABLED: 'aria-disabled',
    STEP_DATA_ATTR: 'data-step',
    CHANGE_EVENT: 'MDCSlider:change',
    INPUT_EVENT: 'MDCSlider:input'
  };

  /** @enum {number} */
  var numbers = {
    PAGE_FACTOR: 4
  };

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /* eslint-disable no-unused-vars */

  /**
   * Adapter for MDC Slider.
   *
   * Defines the shape of the adapter expected by the foundation. Implement this
   * adapter to integrate the Slider into your framework. See
   * https://github.com/material-components/material-components-web/blob/master/docs/authoring-components.md
   * for more information.
   *
   * @record
   */
  var MDCSliderAdapter = function () {
    function MDCSliderAdapter() {
      classCallCheck(this, MDCSliderAdapter);
    }

    createClass(MDCSliderAdapter, [{
      key: "hasClass",

      /**
       * Returns true if className exists for the slider Element
       * @param {string} className
       * @return {boolean}
       */
      value: function hasClass(className) {}

      /**
       * Adds a class to the slider Element
       * @param {string} className
       */

    }, {
      key: "addClass",
      value: function addClass(className) {}

      /**
       * Removes a class from the slider Element
       * @param {string} className
       */

    }, {
      key: "removeClass",
      value: function removeClass(className) {}

      /**
       * Returns a string if attribute name exists on the slider Element,
       * otherwise returns null
       * @param {string} name
       * @return {?string}
       */

    }, {
      key: "getAttribute",
      value: function getAttribute(name) {}

      /**
       * Sets attribute name on slider Element to value
       * @param {string} name
       * @param {string} value
       */

    }, {
      key: "setAttribute",
      value: function setAttribute(name, value) {}

      /**
       * Removes attribute name from slider Element
       * @param {string} name
       */

    }, {
      key: "removeAttribute",
      value: function removeAttribute(name) {}

      /**
       * Returns the bounding client rect for the slider Element
       * @return {?ClientRect}
       */

    }, {
      key: "computeBoundingRect",
      value: function computeBoundingRect() {}

      /**
       * Returns the tab index of the slider Element
       * @return {number}
       */

    }, {
      key: "getTabIndex",
      value: function getTabIndex() {}

      /**
       * Registers an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerInteractionHandler",
      value: function registerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the root element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterInteractionHandler",
      value: function deregisterInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerThumbContainerInteractionHandler",
      value: function registerThumbContainerInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the thumb container element for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterThumbContainerInteractionHandler",
      value: function deregisterThumbContainerInteractionHandler(type, handler) {}

      /**
       * Registers an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerBodyInteractionHandler",
      value: function registerBodyInteractionHandler(type, handler) {}

      /**
       * Deregisters an event handler on the body for a given event.
       * @param {string} type
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterBodyInteractionHandler",
      value: function deregisterBodyInteractionHandler(type, handler) {}

      /**
       * Registers an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "registerResizeHandler",
      value: function registerResizeHandler(handler) {}

      /**
       * Deregisters an event handler for the window resize event
       * @param {function(!Event): undefined} handler
       */

    }, {
      key: "deregisterResizeHandler",
      value: function deregisterResizeHandler(handler) {}

      /**
       * Emits a custom event MDCSlider:input from the root
       */

    }, {
      key: "notifyInput",
      value: function notifyInput() {}

      /**
       * Emits a custom event MDCSlider:change from the root
       */

    }, {
      key: "notifyChange",
      value: function notifyChange() {}

      /**
       * Sets a style property of the thumb container element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setThumbContainerStyleProperty",
      value: function setThumbContainerStyleProperty(propertyName, value) {}

      /**
       * Sets a style property of the track element to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setTrackStyleProperty",
      value: function setTrackStyleProperty(propertyName, value) {}

      /**
       * Sets the inner text of the pin marker to the passed value
       * @param {number} value
       */

    }, {
      key: "setMarkerValue",
      value: function setMarkerValue(value) {}

      /**
       * Appends the passed number of track markers to the track mark container element
       * @param {number} numMarkers
       */

    }, {
      key: "appendTrackMarkers",
      value: function appendTrackMarkers(numMarkers) {}

      /**
       * Removes all track markers fromt he track mark container element
       */

    }, {
      key: "removeTrackMarkers",
      value: function removeTrackMarkers() {}

      /**
       * Sets a style property of the last track marker to the passed value
       * @param {string} propertyName
       * @param {string} value
       */

    }, {
      key: "setLastTrackMarkersStyleProperty",
      value: function setLastTrackMarkersStyleProperty(propertyName, value) {}

      /**
       * Returns true if the root element is RTL, otherwise false
       * @return {boolean}
       */

    }, {
      key: "isRTL",
      value: function isRTL() {}
    }]);
    return MDCSliderAdapter;
  }();

  /**
   * @license
   * Copyright 2016 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *      http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @const {Object<string, !VendorPropertyMapType>} */
  var eventTypeMap = {
    'animationstart': {
      noPrefix: 'animationstart',
      webkitPrefix: 'webkitAnimationStart',
      styleProperty: 'animation'
    },
    'animationend': {
      noPrefix: 'animationend',
      webkitPrefix: 'webkitAnimationEnd',
      styleProperty: 'animation'
    },
    'animationiteration': {
      noPrefix: 'animationiteration',
      webkitPrefix: 'webkitAnimationIteration',
      styleProperty: 'animation'
    },
    'transitionend': {
      noPrefix: 'transitionend',
      webkitPrefix: 'webkitTransitionEnd',
      styleProperty: 'transition'
    }
  };

  /** @const {Object<string, !VendorPropertyMapType>} */
  var cssPropertyMap = {
    'animation': {
      noPrefix: 'animation',
      webkitPrefix: '-webkit-animation'
    },
    'transform': {
      noPrefix: 'transform',
      webkitPrefix: '-webkit-transform'
    },
    'transition': {
      noPrefix: 'transition',
      webkitPrefix: '-webkit-transition'
    }
  };

  /**
   * @param {!Object} windowObj
   * @return {boolean}
   */
  function hasProperShape(windowObj) {
    return windowObj['document'] !== undefined && typeof windowObj['document']['createElement'] === 'function';
  }

  /**
   * @param {string} eventType
   * @return {boolean}
   */
  function eventFoundInMaps(eventType) {
    return eventType in eventTypeMap || eventType in cssPropertyMap;
  }

  /**
   * @param {string} eventType
   * @param {!Object<string, !VendorPropertyMapType>} map
   * @param {!Element} el
   * @return {string}
   */
  function getJavaScriptEventName(eventType, map, el) {
    return map[eventType].styleProperty in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
  }

  /**
   * Helper function to determine browser prefix for CSS3 animation events
   * and property names.
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getAnimationName(windowObj, eventType) {
    if (!hasProperShape(windowObj) || !eventFoundInMaps(eventType)) {
      return eventType;
    }

    var map = /** @type {!Object<string, !VendorPropertyMapType>} */eventType in eventTypeMap ? eventTypeMap : cssPropertyMap;
    var el = windowObj['document']['createElement']('div');
    var eventName = '';

    if (map === eventTypeMap) {
      eventName = getJavaScriptEventName(eventType, map, el);
    } else {
      eventName = map[eventType].noPrefix in el.style ? map[eventType].noPrefix : map[eventType].webkitPrefix;
    }

    return eventName;
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectEventName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @param {!Object} windowObj
   * @param {string} eventType
   * @return {string}
   */
  function getCorrectPropertyName(windowObj, eventType) {
    return getAnimationName(windowObj, eventType);
  }

  /**
   * @license
   * Copyright 2016 Google Inc.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   * you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   *   http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /**
   * @template A
   */
  var MDCFoundation = function () {
    createClass(MDCFoundation, null, [{
      key: "cssClasses",

      /** @return enum{cssClasses} */
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports every
        // CSS class the foundation class needs as a property. e.g. {ACTIVE: 'mdc-component--active'}
        return {};
      }

      /** @return enum{strings} */

    }, {
      key: "strings",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // semantic strings as constants. e.g. {ARIA_ROLE: 'tablist'}
        return {};
      }

      /** @return enum{numbers} */

    }, {
      key: "numbers",
      get: function get$$1() {
        // Classes extending MDCFoundation should implement this method to return an object which exports all
        // of its semantic numbers as constants. e.g. {ANIMATION_DELAY_MS: 350}
        return {};
      }

      /** @return {!Object} */

    }, {
      key: "defaultAdapter",
      get: function get$$1() {
        // Classes extending MDCFoundation may choose to implement this getter in order to provide a convenient
        // way of viewing the necessary methods of an adapter. In the future, this could also be used for adapter
        // validation.
        return {};
      }

      /**
       * @param {A=} adapter
       */

    }]);

    function MDCFoundation() {
      var adapter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
      classCallCheck(this, MDCFoundation);

      /** @protected {!A} */
      this.adapter_ = adapter;
    }

    createClass(MDCFoundation, [{
      key: "init",
      value: function init() {
        // Subclasses should override this method to perform initialization routines (registering events, etc.)
      }
    }, {
      key: "destroy",
      value: function destroy() {
        // Subclasses should override this method to perform de-initialization routines (de-registering events, etc.)
      }
    }]);
    return MDCFoundation;
  }();

  /**
   * @license
   * Copyright 2017 Google Inc. All Rights Reserved.
   *
   * Licensed under the Apache License, Version 2.0 (the "License");
   *you may not use this file except in compliance with the License.
   * You may obtain a copy of the License at
   *
   * http://www.apache.org/licenses/LICENSE-2.0
   *
   * Unless required by applicable law or agreed to in writing, software
   * distributed under the License is distributed on an "AS IS" BASIS,
   * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   * See the License for the specific language governing permissions and
   * limitations under the License.
   */

  /** @enum {string} */
  var KEY_IDS = {
    ARROW_LEFT: 'ArrowLeft',
    ARROW_RIGHT: 'ArrowRight',
    ARROW_UP: 'ArrowUp',
    ARROW_DOWN: 'ArrowDown',
    HOME: 'Home',
    END: 'End',
    PAGE_UP: 'PageUp',
    PAGE_DOWN: 'PageDown'
  };

  /** @enum {string} */
  var MOVE_EVENT_MAP = {
    'mousedown': 'mousemove',
    'touchstart': 'touchmove',
    'pointerdown': 'pointermove'
  };

  var DOWN_EVENTS = ['mousedown', 'pointerdown', 'touchstart'];
  var UP_EVENTS = ['mouseup', 'pointerup', 'touchend'];

  /**
   * @extends {MDCFoundation<!MDCSliderAdapter>}
   */

  var MDCSliderFoundation = function (_MDCFoundation) {
    inherits(MDCSliderFoundation, _MDCFoundation);
    createClass(MDCSliderFoundation, null, [{
      key: 'cssClasses',

      /** @return enum {cssClasses} */
      get: function get$$1() {
        return cssClasses;
      }

      /** @return enum {strings} */

    }, {
      key: 'strings',
      get: function get$$1() {
        return strings;
      }

      /** @return enum {numbers} */

    }, {
      key: 'numbers',
      get: function get$$1() {
        return numbers;
      }

      /** @return {!MDCSliderAdapter} */

    }, {
      key: 'defaultAdapter',
      get: function get$$1() {
        return (/** @type {!MDCSliderAdapter} */{
            hasClass: function hasClass() {
              return (/* className: string */ /* boolean */false
              );
            },
            addClass: function addClass() /* className: string */{},
            removeClass: function removeClass() /* className: string */{},
            getAttribute: function getAttribute() {
              return (/* name: string */ /* string|null */null
              );
            },
            setAttribute: function setAttribute() /* name: string, value: string */{},
            removeAttribute: function removeAttribute() /* name: string */{},
            computeBoundingRect: function computeBoundingRect() {
              return (/* ClientRect */{
                  top: 0, right: 0, bottom: 0, left: 0, width: 0, height: 0
                }
              );
            },
            getTabIndex: function getTabIndex() {
              return (/* number */0
              );
            },
            registerInteractionHandler: function registerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterInteractionHandler: function deregisterInteractionHandler() /* type: string, handler: EventListener */{},
            registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler() /* type: string, handler: EventListener */{},
            registerBodyInteractionHandler: function registerBodyInteractionHandler() /* type: string, handler: EventListener */{},
            deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler() /* type: string, handler: EventListener */{},
            registerResizeHandler: function registerResizeHandler() /* handler: EventListener */{},
            deregisterResizeHandler: function deregisterResizeHandler() /* handler: EventListener */{},
            notifyInput: function notifyInput() {},
            notifyChange: function notifyChange() {},
            setThumbContainerStyleProperty: function setThumbContainerStyleProperty() /* propertyName: string, value: string */{},
            setTrackStyleProperty: function setTrackStyleProperty() /* propertyName: string, value: string */{},
            setMarkerValue: function setMarkerValue() /* value: number */{},
            appendTrackMarkers: function appendTrackMarkers() /* numMarkers: number */{},
            removeTrackMarkers: function removeTrackMarkers() {},
            setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty() /* propertyName: string, value: string */{},
            isRTL: function isRTL() {
              return (/* boolean */false
              );
            }
          }
        );
      }

      /**
       * Creates a new instance of MDCSliderFoundation
       * @param {?MDCSliderAdapter} adapter
       */

    }]);

    function MDCSliderFoundation(adapter) {
      classCallCheck(this, MDCSliderFoundation);

      /** @private {?ClientRect} */
      var _this = possibleConstructorReturn(this, (MDCSliderFoundation.__proto__ || Object.getPrototypeOf(MDCSliderFoundation)).call(this, _extends(MDCSliderFoundation.defaultAdapter, adapter)));

      _this.rect_ = null;
      // We set this to NaN since we want it to be a number, but we can't use '0' or '-1'
      // because those could be valid tabindices set by the client code.
      _this.savedTabIndex_ = NaN;
      _this.active_ = false;
      _this.inTransit_ = false;
      _this.isDiscrete_ = false;
      _this.hasTrackMarker_ = false;
      _this.handlingThumbTargetEvt_ = false;
      _this.min_ = 0;
      _this.max_ = 100;
      _this.step_ = 0;
      _this.value_ = 0;
      _this.disabled_ = false;
      _this.preventFocusState_ = false;
      _this.updateUIFrame_ = 0;
      _this.thumbContainerPointerHandler_ = function () {
        _this.handlingThumbTargetEvt_ = true;
      };
      _this.interactionStartHandler_ = function (evt) {
        return _this.handleDown_(evt);
      };
      _this.keydownHandler_ = function (evt) {
        return _this.handleKeydown_(evt);
      };
      _this.focusHandler_ = function () {
        return _this.handleFocus_();
      };
      _this.blurHandler_ = function () {
        return _this.handleBlur_();
      };
      _this.resizeHandler_ = function () {
        return _this.layout();
      };
      return _this;
    }

    createClass(MDCSliderFoundation, [{
      key: 'init',
      value: function init() {
        var _this2 = this;

        this.isDiscrete_ = this.adapter_.hasClass(cssClasses.IS_DISCRETE);
        this.hasTrackMarker_ = this.adapter_.hasClass(cssClasses.HAS_TRACK_MARKER);
        DOWN_EVENTS.forEach(function (evtName) {
          return _this2.adapter_.registerInteractionHandler(evtName, _this2.interactionStartHandler_);
        });
        this.adapter_.registerInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.registerInteractionHandler('focus', this.focusHandler_);
        this.adapter_.registerInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this2.adapter_.registerThumbContainerInteractionHandler(evtName, _this2.thumbContainerPointerHandler_);
        });
        this.adapter_.registerResizeHandler(this.resizeHandler_);
        this.layout();
        // At last step, provide a reasonable default value to discrete slider
        if (this.isDiscrete_ && this.getStep() == 0) {
          this.step_ = 1;
        }
      }
    }, {
      key: 'destroy',
      value: function destroy() {
        var _this3 = this;

        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterInteractionHandler(evtName, _this3.interactionStartHandler_);
        });
        this.adapter_.deregisterInteractionHandler('keydown', this.keydownHandler_);
        this.adapter_.deregisterInteractionHandler('focus', this.focusHandler_);
        this.adapter_.deregisterInteractionHandler('blur', this.blurHandler_);
        DOWN_EVENTS.forEach(function (evtName) {
          _this3.adapter_.deregisterThumbContainerInteractionHandler(evtName, _this3.thumbContainerPointerHandler_);
        });
        this.adapter_.deregisterResizeHandler(this.resizeHandler_);
      }
    }, {
      key: 'setupTrackMarker',
      value: function setupTrackMarker() {
        if (this.isDiscrete_ && this.hasTrackMarker_ && this.getStep() != 0) {
          var min = this.getMin();
          var max = this.getMax();
          var step = this.getStep();
          var numMarkers = (max - min) / step;

          // In case distance between max & min is indivisible to step,
          // we place the secondary to last marker proportionally at where thumb
          // could reach and place the last marker at max value
          var indivisible = Math.ceil(numMarkers) !== numMarkers;
          if (indivisible) {
            numMarkers = Math.ceil(numMarkers);
          }

          this.adapter_.removeTrackMarkers();
          this.adapter_.appendTrackMarkers(numMarkers);

          if (indivisible) {
            var lastStepRatio = (max - numMarkers * step) / step + 1;
            var flex = getCorrectPropertyName(window, 'flex');
            this.adapter_.setLastTrackMarkersStyleProperty(flex, String(lastStepRatio));
          }
        }
      }
    }, {
      key: 'layout',
      value: function layout() {
        this.rect_ = this.adapter_.computeBoundingRect();
        this.updateUIForCurrentValue_();
      }

      /** @return {number} */

    }, {
      key: 'getValue',
      value: function getValue() {
        return this.value_;
      }

      /** @param {number} value */

    }, {
      key: 'setValue',
      value: function setValue(value) {
        this.setValue_(value, false);
      }

      /** @return {number} */

    }, {
      key: 'getMax',
      value: function getMax() {
        return this.max_;
      }

      /** @param {number} max */

    }, {
      key: 'setMax',
      value: function setMax(max) {
        if (max < this.min_) {
          throw new Error('Cannot set max to be less than the slider\'s minimum value');
        }
        this.max_ = max;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings.ARIA_VALUEMAX, String(this.max_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getMin',
      value: function getMin() {
        return this.min_;
      }

      /** @param {number} min */

    }, {
      key: 'setMin',
      value: function setMin(min) {
        if (min > this.max_) {
          throw new Error('Cannot set min to be greater than the slider\'s maximum value');
        }
        this.min_ = min;
        this.setValue_(this.value_, false, true);
        this.adapter_.setAttribute(strings.ARIA_VALUEMIN, String(this.min_));
        this.setupTrackMarker();
      }

      /** @return {number} */

    }, {
      key: 'getStep',
      value: function getStep() {
        return this.step_;
      }

      /** @param {number} step */

    }, {
      key: 'setStep',
      value: function setStep(step) {
        if (step < 0) {
          throw new Error('Step cannot be set to a negative number');
        }
        if (this.isDiscrete_ && (typeof step !== 'number' || step < 1)) {
          step = 1;
        }
        this.step_ = step;
        this.setValue_(this.value_, false, true);
        this.setupTrackMarker();
      }

      /** @return {boolean} */

    }, {
      key: 'isDisabled',
      value: function isDisabled() {
        return this.disabled_;
      }

      /** @param {boolean} disabled */

    }, {
      key: 'setDisabled',
      value: function setDisabled(disabled) {
        this.disabled_ = disabled;
        this.toggleClass_(cssClasses.DISABLED, this.disabled_);
        if (this.disabled_) {
          this.savedTabIndex_ = this.adapter_.getTabIndex();
          this.adapter_.setAttribute(strings.ARIA_DISABLED, 'true');
          this.adapter_.removeAttribute('tabindex');
        } else {
          this.adapter_.removeAttribute(strings.ARIA_DISABLED);
          if (!isNaN(this.savedTabIndex_)) {
            this.adapter_.setAttribute('tabindex', String(this.savedTabIndex_));
          }
        }
      }

      /**
       * Called when the user starts interacting with the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleDown_',
      value: function handleDown_(evt) {
        var _this4 = this;

        if (this.disabled_) {
          return;
        }

        this.preventFocusState_ = true;
        this.setInTransit_(!this.handlingThumbTargetEvt_);
        this.handlingThumbTargetEvt_ = false;
        this.setActive_(true);

        var moveHandler = function moveHandler(evt) {
          _this4.handleMove_(evt);
        };

        // Note: upHandler is [de]registered on ALL potential pointer-related release event types, since some browsers
        // do not always fire these consistently in pairs.
        // (See https://github.com/material-components/material-components-web/issues/1192)
        var upHandler = function upHandler() {
          _this4.handleUp_();
          _this4.adapter_.deregisterBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
          UP_EVENTS.forEach(function (evtName) {
            return _this4.adapter_.deregisterBodyInteractionHandler(evtName, upHandler);
          });
        };

        this.adapter_.registerBodyInteractionHandler(MOVE_EVENT_MAP[evt.type], moveHandler);
        UP_EVENTS.forEach(function (evtName) {
          return _this4.adapter_.registerBodyInteractionHandler(evtName, upHandler);
        });
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user moves the slider
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'handleMove_',
      value: function handleMove_(evt) {
        evt.preventDefault();
        this.setValueFromEvt_(evt);
      }

      /**
       * Called when the user's interaction with the slider ends
       * @private
       */

    }, {
      key: 'handleUp_',
      value: function handleUp_() {
        this.setActive_(false);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the pageX of the event
       * @param {!Event} evt
       * @return {number}
       * @private
       */

    }, {
      key: 'getPageX_',
      value: function getPageX_(evt) {
        if (evt.targetTouches && evt.targetTouches.length > 0) {
          return evt.targetTouches[0].pageX;
        }
        return evt.pageX;
      }

      /**
       * Sets the slider value from an event
       * @param {!Event} evt
       * @private
       */

    }, {
      key: 'setValueFromEvt_',
      value: function setValueFromEvt_(evt) {
        var pageX = this.getPageX_(evt);
        var value = this.computeValueFromPageX_(pageX);
        this.setValue_(value, true);
      }

      /**
       * Computes the new value from the pageX position
       * @param {number} pageX
       * @return {number}
       */

    }, {
      key: 'computeValueFromPageX_',
      value: function computeValueFromPageX_(pageX) {
        var max = this.max_,
            min = this.min_;

        var xPos = pageX - this.rect_.left;
        var pctComplete = xPos / this.rect_.width;
        if (this.adapter_.isRTL()) {
          pctComplete = 1 - pctComplete;
        }
        // Fit the percentage complete between the range [min,max]
        // by remapping from [0, 1] to [min, min+(max-min)].
        return min + pctComplete * (max - min);
      }

      /**
       * Handles keydown events
       * @param {!Event} evt
       */

    }, {
      key: 'handleKeydown_',
      value: function handleKeydown_(evt) {
        var keyId = this.getKeyId_(evt);
        var value = this.getValueForKeyId_(keyId);
        if (isNaN(value)) {
          return;
        }

        // Prevent page from scrolling due to key presses that would normally scroll the page
        evt.preventDefault();
        this.adapter_.addClass(cssClasses.FOCUS);
        this.setValue_(value, true);
        this.adapter_.notifyChange();
      }

      /**
       * Returns the computed name of the event
       * @param {!Event} kbdEvt
       * @return {string}
       */

    }, {
      key: 'getKeyId_',
      value: function getKeyId_(kbdEvt) {
        if (kbdEvt.key === KEY_IDS.ARROW_LEFT || kbdEvt.keyCode === 37) {
          return KEY_IDS.ARROW_LEFT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_RIGHT || kbdEvt.keyCode === 39) {
          return KEY_IDS.ARROW_RIGHT;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_UP || kbdEvt.keyCode === 38) {
          return KEY_IDS.ARROW_UP;
        }
        if (kbdEvt.key === KEY_IDS.ARROW_DOWN || kbdEvt.keyCode === 40) {
          return KEY_IDS.ARROW_DOWN;
        }
        if (kbdEvt.key === KEY_IDS.HOME || kbdEvt.keyCode === 36) {
          return KEY_IDS.HOME;
        }
        if (kbdEvt.key === KEY_IDS.END || kbdEvt.keyCode === 35) {
          return KEY_IDS.END;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_UP || kbdEvt.keyCode === 33) {
          return KEY_IDS.PAGE_UP;
        }
        if (kbdEvt.key === KEY_IDS.PAGE_DOWN || kbdEvt.keyCode === 34) {
          return KEY_IDS.PAGE_DOWN;
        }

        return '';
      }

      /**
       * Computes the value given a keyboard key ID
       * @param {string} keyId
       * @return {number}
       */

    }, {
      key: 'getValueForKeyId_',
      value: function getValueForKeyId_(keyId) {
        var max = this.max_,
            min = this.min_,
            step = this.step_;

        var delta = step || (max - min) / 100;
        var valueNeedsToBeFlipped = this.adapter_.isRTL() && (keyId === KEY_IDS.ARROW_LEFT || keyId === KEY_IDS.ARROW_RIGHT);
        if (valueNeedsToBeFlipped) {
          delta = -delta;
        }

        switch (keyId) {
          case KEY_IDS.ARROW_LEFT:
          case KEY_IDS.ARROW_DOWN:
            return this.value_ - delta;
          case KEY_IDS.ARROW_RIGHT:
          case KEY_IDS.ARROW_UP:
            return this.value_ + delta;
          case KEY_IDS.HOME:
            return this.min_;
          case KEY_IDS.END:
            return this.max_;
          case KEY_IDS.PAGE_UP:
            return this.value_ + delta * numbers.PAGE_FACTOR;
          case KEY_IDS.PAGE_DOWN:
            return this.value_ - delta * numbers.PAGE_FACTOR;
          default:
            return NaN;
        }
      }
    }, {
      key: 'handleFocus_',
      value: function handleFocus_() {
        if (this.preventFocusState_) {
          return;
        }
        this.adapter_.addClass(cssClasses.FOCUS);
      }
    }, {
      key: 'handleBlur_',
      value: function handleBlur_() {
        this.preventFocusState_ = false;
        this.adapter_.removeClass(cssClasses.FOCUS);
      }

      /**
       * Sets the value of the slider
       * @param {number} value
       * @param {boolean} shouldFireInput
       * @param {boolean=} force
       */

    }, {
      key: 'setValue_',
      value: function setValue_(value, shouldFireInput) {
        var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

        if (value === this.value_ && !force) {
          return;
        }

        var min = this.min_,
            max = this.max_;

        var valueSetToBoundary = value === min || value === max;
        if (this.step_ && !valueSetToBoundary) {
          value = this.quantize_(value);
        }
        if (value < min) {
          value = min;
        } else if (value > max) {
          value = max;
        }
        this.value_ = value;
        this.adapter_.setAttribute(strings.ARIA_VALUENOW, String(this.value_));
        this.updateUIForCurrentValue_();

        if (shouldFireInput) {
          this.adapter_.notifyInput();
          if (this.isDiscrete_) {
            this.adapter_.setMarkerValue(value);
          }
        }
      }

      /**
       * Calculates the quantized value
       * @param {number} value
       * @return {number}
       */

    }, {
      key: 'quantize_',
      value: function quantize_(value) {
        var numSteps = Math.round(value / this.step_);
        var quantizedVal = numSteps * this.step_;
        return quantizedVal;
      }
    }, {
      key: 'updateUIForCurrentValue_',
      value: function updateUIForCurrentValue_() {
        var _this5 = this;

        var max = this.max_,
            min = this.min_,
            value = this.value_;

        var pctComplete = (value - min) / (max - min);
        var translatePx = pctComplete * this.rect_.width;
        if (this.adapter_.isRTL()) {
          translatePx = this.rect_.width - translatePx;
        }

        var transformProp = getCorrectPropertyName(window, 'transform');
        var transitionendEvtName = getCorrectEventName(window, 'transitionend');

        if (this.inTransit_) {
          var onTransitionEnd = function onTransitionEnd() {
            _this5.setInTransit_(false);
            _this5.adapter_.deregisterThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
          };
          this.adapter_.registerThumbContainerInteractionHandler(transitionendEvtName, onTransitionEnd);
        }

        this.updateUIFrame_ = requestAnimationFrame(function () {
          // NOTE(traviskaufman): It would be nice to use calc() here,
          // but IE cannot handle calcs in transforms correctly.
          // See: https://goo.gl/NC2itk
          // Also note that the -50% offset is used to center the slider thumb.
          _this5.adapter_.setThumbContainerStyleProperty(transformProp, 'translateX(' + translatePx + 'px) translateX(-50%)');
          _this5.adapter_.setTrackStyleProperty(transformProp, 'scaleX(' + pctComplete + ')');
        });
      }

      /**
       * Toggles the active state of the slider
       * @param {boolean} active
       */

    }, {
      key: 'setActive_',
      value: function setActive_(active) {
        this.active_ = active;
        this.toggleClass_(cssClasses.ACTIVE, this.active_);
      }

      /**
       * Toggles the inTransit state of the slider
       * @param {boolean} inTransit
       */

    }, {
      key: 'setInTransit_',
      value: function setInTransit_(inTransit) {
        this.inTransit_ = inTransit;
        this.toggleClass_(cssClasses.IN_TRANSIT, this.inTransit_);
      }

      /**
       * Conditionally adds or removes a class based on shouldBePresent
       * @param {string} className
       * @param {boolean} shouldBePresent
       */

    }, {
      key: 'toggleClass_',
      value: function toggleClass_(className, shouldBePresent) {
        if (shouldBePresent) {
          this.adapter_.addClass(className);
        } else {
          this.adapter_.removeClass(className);
        }
      }
    }]);
    return MDCSliderFoundation;
  }(MDCFoundation);

  var bus_ = void 0;

  var eventBus = {
    install: function install(vue) {
      bus_ = new vue();
    },
    $emit: function $emit(event) {
      var _bus_;

      for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
        args[_key - 1] = arguments[_key];
      }

      bus_ && (_bus_ = bus_).$emit.apply(_bus_, [event].concat(toConsumableArray(args)));
    },
    $on: function $on(event, callback) {
      bus_ && bus_.$on(event, callback);
    },
    $once: function $once(event, callback) {
      bus_ && bus_.$once(event, callback);
    },
    $off: function $off(event, callback) {
      bus_ && bus_.$off(event, callback);
    }
  };

  var mdcSlider = { render: function render() {
      var _vm = this;var _h = _vm.$createElement;var _c = _vm._self._c || _h;return _c('div', { staticClass: "mdc-slider", class: _vm.classes, attrs: { "tabindex": "0", "role": "slider" } }, [_c('div', { staticClass: "mdc-slider__track-container" }, [_c('div', { staticClass: "mdc-slider__track", style: _vm.trackStyles }), _vm._v(" "), _vm.hasMarkers ? _c('div', { staticClass: "mdc-slider__track-marker-container" }, _vm._l(_vm.numMarkers, function (markerNum) {
        return _c('div', { key: markerNum, staticClass: "mdc-slider__track-marker", style: markerNum == _vm.numMarkers ? _vm.lastTrackMarkersStyles : {} });
      })) : _vm._e()]), _vm._v(" "), _c('div', { ref: "thumbContainer", staticClass: "mdc-slider__thumb-container", style: _vm.thumbStyles }, [_vm.isDiscrete ? _c('div', { staticClass: "mdc-slider__pin" }, [_c('span', { staticClass: "mdc-slider__pin-value-marker" }, [_vm._v(_vm._s(_vm.markerValue))])]) : _vm._e(), _vm._v(" "), _c('svg', { staticClass: "mdc-slider__thumb", attrs: { "width": "21", "height": "21" } }, [_c('circle', { attrs: { "cx": "10.5", "cy": "10.5", "r": "7.875" } })]), _vm._v(" "), _c('div', { staticClass: "mdc-slider__focus-ring" })])]);
    }, staticRenderFns: [],
    name: 'mdc-slider',
    mixins: [DispatchFocusMixin],
    model: {
      prop: 'value',
      event: 'change'
    },
    props: {
      value: [Number, String],
      min: { type: [Number, String], default: 0 },
      max: { type: [Number, String], default: 100 },
      step: { type: [Number, String], default: 0 },
      displayMarkers: Boolean,
      disabled: Boolean,
      layoutOn: String,
      layoutOnSource: { type: Object, required: false }
    },
    data: function data() {
      return {
        classes: {
          'mdc-slider--discrete': !!this.step,
          'mdc-slider--display-markers': this.displayMarkers
        },
        trackStyles: {},
        lastTrackMarkersStyles: {},
        thumbStyles: {},
        markerValue: '',
        numMarkers: 0
      };
    },

    computed: {
      isDiscrete: function isDiscrete() {
        return !!this.step;
      },
      hasMarkers: function hasMarkers() {
        return !!this.step && this.displayMarkers && this.numMarkers;
      }
    },
    watch: {
      value: function value() {
        if (this.foundation.getValue() !== Number(this.value)) {
          this.foundation.setValue(this.value);
        }
      },
      min: function min() {
        this.foundation.setMin(Number(this.min));
      },
      max: function max() {
        this.foundation.setMax(Number(this.max));
      },
      step: function step() {
        this.foundation.setStep(Number(this.step));
      },
      disabled: function disabled() {
        this.foundation.setDisabled(this.disabled);
      }
    },
    methods: {
      layout: function layout() {
        var _this = this;

        this.$nextTick(function () {
          _this.foundation && _this.foundation.layout();
        });
      }
    },
    mounted: function mounted() {
      var _this2 = this;

      this.foundation = new MDCSliderFoundation({
        hasClass: function hasClass(className) {
          return _this2.$el.classList.contains(className);
        },
        addClass: function addClass(className) {
          _this2.$set(_this2.classes, className, true);
        },
        removeClass: function removeClass(className) {
          _this2.$delete(_this2.classes, className, true);
        },
        getAttribute: function getAttribute(name) {
          return _this2.$el.getAttribute(name);
        },
        setAttribute: function setAttribute(name, value) {
          return _this2.$el.setAttribute(name, value);
        },
        removeAttribute: function removeAttribute(name) {
          return _this2.$el.removeAttribute(name);
        },
        computeBoundingRect: function computeBoundingRect() {
          return _this2.$el.getBoundingClientRect();
        },
        getTabIndex: function getTabIndex() {
          return _this2.$el.tabIndex;
        },
        registerInteractionHandler: function registerInteractionHandler(type, handler) {
          _this2.$el.addEventListener(type, handler);
        },
        deregisterInteractionHandler: function deregisterInteractionHandler(type, handler) {
          _this2.$el.removeEventListener(type, handler);
        },
        registerThumbContainerInteractionHandler: function registerThumbContainerInteractionHandler(type, handler) {
          _this2.$refs.thumbContainer.addEventListener(type, handler);
        },
        deregisterThumbContainerInteractionHandler: function deregisterThumbContainerInteractionHandler(type, handler) {
          _this2.$refs.thumbContainer.removeEventListener(type, handler);
        },
        registerBodyInteractionHandler: function registerBodyInteractionHandler(type, handler) {
          document.body.addEventListener(type, handler);
        },
        deregisterBodyInteractionHandler: function deregisterBodyInteractionHandler(type, handler) {
          document.body.removeEventListener(type, handler);
        },
        registerResizeHandler: function registerResizeHandler(handler) {
          window.addEventListener('resize', handler);
        },
        deregisterResizeHandler: function deregisterResizeHandler(handler) {
          window.removeEventListener('resize', handler);
        },
        notifyInput: function notifyInput() {
          _this2.$emit('input', _this2.foundation.getValue());
        },
        notifyChange: function notifyChange() {
          _this2.$emit('change', _this2.foundation.getValue());
        },
        setThumbContainerStyleProperty: function setThumbContainerStyleProperty(propertyName, value) {
          _this2.$set(_this2.thumbStyles, propertyName, value);
        },
        setTrackStyleProperty: function setTrackStyleProperty(propertyName, value) {
          _this2.$set(_this2.trackStyles, propertyName, value);
        },
        setMarkerValue: function setMarkerValue(value) {
          _this2.markerValue = value;
        },
        appendTrackMarkers: function appendTrackMarkers(numMarkers) {
          _this2.numMarkers = numMarkers;
        },
        removeTrackMarkers: function removeTrackMarkers() {
          _this2.numMarkers = 0;
        },
        setLastTrackMarkersStyleProperty: function setLastTrackMarkersStyleProperty(propertyName, value) {
          _this2.$set(_this2.lastTrackMarkersStyles, propertyName, value);
        },
        isRTL: function isRTL() {
          return false;
        }
      });

      this.foundation.init();
      this.foundation.setDisabled(this.disabled);
      if (Number(this.min) <= this.foundation.getMax()) {
        this.foundation.setMin(Number(this.min));
        this.foundation.setMax(Number(this.max));
      } else {
        this.foundation.setMax(Number(this.max));
        this.foundation.setMin(Number(this.min));
      }
      this.foundation.setStep(Number(this.step));
      this.foundation.setValue(Number(this.value));
      if (this.hasMarkers) {
        this.foundation.setupTrackMarker();
      }

      eventBus.$on('mdc:layout', this.layout);

      if (this.layoutOn) {
        this.layoutOnEventSource = this.layoutOnSource || this.$root;
        this.layoutOnEventSource.$on(this.layoutOn, this.layout);
      }
    },
    beforeDestroy: function beforeDestroy() {
      eventBus.$off('mdc:layout', this.layout);
      if (this.layoutOnEventSource) {
        this.layoutOnEventSource.$off(this.layoutOn, this.layout);
      }
      this.foundation.destroy();
    }
  };

  var plugin = BasePlugin({
    mdcSlider: mdcSlider
  });

  autoInit(plugin);

  return plugin;

})));
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2xpZGVyLmpzIiwic291cmNlcyI6WyIuLi8uLi9jb21wb25lbnRzL2Jhc2UvYXV0by1pbml0LmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2Jhc2UtcGx1Z2luLmpzIiwiLi4vLi4vY29tcG9uZW50cy9iYXNlL2N1c3RvbS1ldmVudC5qcyIsIi4uLy4uL2NvbXBvbmVudHMvYmFzZS9kaXNwYXRjaC1mb2N1cy1taXhpbi5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2NvbnN0YW50cy5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvc2xpZGVyL2FkYXB0ZXIuanMiLCIuLi8uLi9ub2RlX21vZHVsZXMvQG1hdGVyaWFsL2FuaW1hdGlvbi9pbmRleC5qcyIsIi4uLy4uL25vZGVfbW9kdWxlcy9AbWF0ZXJpYWwvYmFzZS9mb3VuZGF0aW9uLmpzIiwiLi4vLi4vbm9kZV9tb2R1bGVzL0BtYXRlcmlhbC9zbGlkZXIvZm91bmRhdGlvbi5qcyIsIi4uLy4uL2NvbXBvbmVudHMvY29tbW9uL2V2ZW50LWJ1cy5qcyIsIi4uLy4uL2NvbXBvbmVudHMvc2xpZGVyL21kYy1zbGlkZXIudnVlIiwiLi4vLi4vY29tcG9uZW50cy9zbGlkZXIvaW5kZXguanMiLCIuLi8uLi9jb21wb25lbnRzL3NsaWRlci9lbnRyeS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gYXV0b0luaXQgKHBsdWdpbikge1xuICAvLyBBdXRvLWluc3RhbGxcbiAgbGV0IF9WdWUgPSBudWxsXG4gIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykge1xuICAgIF9WdWUgPSB3aW5kb3cuVnVlXG4gIH0gZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvKmdsb2JhbCBnbG9iYWwqL1xuICAgIF9WdWUgPSBnbG9iYWwuVnVlXG4gIH1cbiAgaWYgKF9WdWUpIHtcbiAgICBfVnVlLnVzZShwbHVnaW4pXG4gIH1cbn1cbiAgIiwiZXhwb3J0IGZ1bmN0aW9uIEJhc2VQbHVnaW4gKGNvbXBvbmVudHMpIHsgXG4gIHJldHVybiB7XG4gICAgdmVyc2lvbjogJ19fVkVSU0lPTl9fJyxcbiAgICBpbnN0YWxsOiAodm0pID0+IHtcbiAgICAgIGZvciAobGV0IGtleSBpbiBjb21wb25lbnRzKSB7XG4gICAgICAgIGxldCBjb21wb25lbnQgPSBjb21wb25lbnRzW2tleV1cbiAgICAgICAgICB2bS5jb21wb25lbnQoY29tcG9uZW50Lm5hbWUsY29tcG9uZW50KVxuICAgICAgfVxuICAgIH0sXG4gICAgY29tcG9uZW50c1xuICB9IFxufVxuXG4iLCIvKiBnbG9iYWwgQ3VzdG9tRXZlbnQgKi9cblxuZXhwb3J0IGZ1bmN0aW9uIGVtaXRDdXN0b21FdmVudCAoZWwsIGV2dFR5cGUsIGV2dERhdGEsIHNob3VsZEJ1YmJsZSA9IGZhbHNlKSB7XG4gIGxldCBldnRcbiAgaWYgKHR5cGVvZiBDdXN0b21FdmVudCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGV2dCA9IG5ldyBDdXN0b21FdmVudChldnRUeXBlLCB7XG4gICAgICBkZXRhaWw6IGV2dERhdGEsXG4gICAgICBidWJibGVzOiBzaG91bGRCdWJibGVcbiAgICB9KVxuICB9IGVsc2Uge1xuICAgIGV2dCA9IGRvY3VtZW50LmNyZWF0ZUV2ZW50KCdDdXN0b21FdmVudCcpXG4gICAgZXZ0LmluaXRDdXN0b21FdmVudChldnRUeXBlLCBzaG91bGRCdWJibGUsIGZhbHNlLCBldnREYXRhKVxuICB9XG4gIGVsLmRpc3BhdGNoRXZlbnQoZXZ0KVxufVxuIiwiZXhwb3J0IGNvbnN0IERpc3BhdGNoRm9jdXNNaXhpbiA9IHtcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuICB7aGFzRm9jdXM6IGZhbHNlfVxuICB9LFxuICBtZXRob2RzOiB7XG4gICAgb25Nb3VzZURvd24oKSB7XG4gICAgICB0aGlzLl9hY3RpdmUgPSB0cnVlXG4gICAgfSxcbiAgICBvbk1vdXNlVXAgKCkge1xuICAgICAgdGhpcy5fYWN0aXZlID0gZmFsc2VcbiAgICB9LFxuICAgIG9uRm9jdXNFdmVudCAoKSB7XG4gICAgICAvLyBkaXNwYXRjaCBhc3luYyB0byBsZXQgdGltZSB0byBvdGhlciBmb2N1cyBldmVudCB0byBwcm9wYWdhdGVcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgb25CbHVyRXZlbnQgKCkge1xuICAgICAgLy8gZGlzcGF0Y2ggYXN5bmMgdG8gbGV0IHRpbWUgdG8gb3RoZXIgZm9jdXMgZXZlbnQgdG8gcHJvcGFnYXRlXG4gICAgICAvLyBhbHNvIGZpbHR1ciBibHVyIGlmIG1vdXNlZG93blxuICAgICAgdGhpcy5fYWN0aXZlIHx8IHNldFRpbWVvdXQoKCkgPT4gdGhpcy5kaXNwYXRjaEZvY3VzRXZlbnQoKSwwKVxuICAgIH0sXG4gICAgZGlzcGF0Y2hGb2N1c0V2ZW50KCkge1xuICAgICAgbGV0IGhhc0ZvY3VzID0gdGhpcy4kZWwgPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgfHwgdGhpcy4kZWwuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCk7XG4gICAgICBpZiAoaGFzRm9jdXMgIT0gdGhpcy5oYXNGb2N1cykge1xuICAgICAgICB0aGlzLiRlbWl0KGhhc0ZvY3VzID8gJ2ZvY3VzJyA6ICdibHVyJylcbiAgICAgICAgdGhpcy5oYXNGb2N1cyA9IGhhc0ZvY3VzXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBtb3VudGVkICgpIHtcbiAgICB0aGlzLiRlbC5hZGRFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9LFxuICBiZWZvcmVEZXN0cm95ICgpIHtcbiAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKCdmb2N1c2luJywgdGhpcy5vbkZvY3VzRXZlbnQpXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignZm9jdXNvdXQnLCB0aGlzLm9uQmx1ckV2ZW50KVxuICAgIHRoaXMuJGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlZG93bicsIHRoaXMub25Nb3VzZURvd24pXG4gICAgdGhpcy4kZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsIHRoaXMub25Nb3VzZVVwKVxuICB9XG59XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKiB5b3UgbWF5IG5vdCB1c2UgdGhpcyBmaWxlIGV4Y2VwdCBpbiBjb21wbGlhbmNlIHdpdGggdGhlIExpY2Vuc2UuXG4gKiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlIExpY2Vuc2UgYXRcbiAqXG4gKiBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgY3NzQ2xhc3NlcyA9IHtcbiAgQUNUSVZFOiAnbWRjLXNsaWRlci0tYWN0aXZlJyxcbiAgRElTQUJMRUQ6ICdtZGMtc2xpZGVyLS1kaXNhYmxlZCcsXG4gIERJU0NSRVRFOiAnbWRjLXNsaWRlci0tZGlzY3JldGUnLFxuICBGT0NVUzogJ21kYy1zbGlkZXItLWZvY3VzJyxcbiAgSU5fVFJBTlNJVDogJ21kYy1zbGlkZXItLWluLXRyYW5zaXQnLFxuICBJU19ESVNDUkVURTogJ21kYy1zbGlkZXItLWRpc2NyZXRlJyxcbiAgSEFTX1RSQUNLX01BUktFUjogJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2VycycsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IHN0cmluZ3MgPSB7XG4gIFRSQUNLX1NFTEVDVE9SOiAnLm1kYy1zbGlkZXJfX3RyYWNrJyxcbiAgVFJBQ0tfTUFSS0VSX0NPTlRBSU5FUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyJyxcbiAgTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdHJhY2stbWFya2VyOmxhc3QtY2hpbGQnLFxuICBUSFVNQl9DT05UQUlORVJfU0VMRUNUT1I6ICcubWRjLXNsaWRlcl9fdGh1bWItY29udGFpbmVyJyxcbiAgUElOX1ZBTFVFX01BUktFUl9TRUxFQ1RPUjogJy5tZGMtc2xpZGVyX19waW4tdmFsdWUtbWFya2VyJyxcbiAgQVJJQV9WQUxVRU1JTjogJ2FyaWEtdmFsdWVtaW4nLFxuICBBUklBX1ZBTFVFTUFYOiAnYXJpYS12YWx1ZW1heCcsXG4gIEFSSUFfVkFMVUVOT1c6ICdhcmlhLXZhbHVlbm93JyxcbiAgQVJJQV9ESVNBQkxFRDogJ2FyaWEtZGlzYWJsZWQnLFxuICBTVEVQX0RBVEFfQVRUUjogJ2RhdGEtc3RlcCcsXG4gIENIQU5HRV9FVkVOVDogJ01EQ1NsaWRlcjpjaGFuZ2UnLFxuICBJTlBVVF9FVkVOVDogJ01EQ1NsaWRlcjppbnB1dCcsXG59O1xuXG4vKiogQGVudW0ge251bWJlcn0gKi9cbmNvbnN0IG51bWJlcnMgPSB7XG4gIFBBR0VfRkFDVE9SOiA0LFxufTtcblxuZXhwb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE3IEdvb2dsZSBJbmMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cblxuLyoqXG4gKiBBZGFwdGVyIGZvciBNREMgU2xpZGVyLlxuICpcbiAqIERlZmluZXMgdGhlIHNoYXBlIG9mIHRoZSBhZGFwdGVyIGV4cGVjdGVkIGJ5IHRoZSBmb3VuZGF0aW9uLiBJbXBsZW1lbnQgdGhpc1xuICogYWRhcHRlciB0byBpbnRlZ3JhdGUgdGhlIFNsaWRlciBpbnRvIHlvdXIgZnJhbWV3b3JrLiBTZWVcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9tYXRlcmlhbC1jb21wb25lbnRzL21hdGVyaWFsLWNvbXBvbmVudHMtd2ViL2Jsb2IvbWFzdGVyL2RvY3MvYXV0aG9yaW5nLWNvbXBvbmVudHMubWRcbiAqIGZvciBtb3JlIGluZm9ybWF0aW9uLlxuICpcbiAqIEByZWNvcmRcbiAqL1xuY2xhc3MgTURDU2xpZGVyQWRhcHRlciB7XG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgY2xhc3NOYW1lIGV4aXN0cyBmb3IgdGhlIHNsaWRlciBFbGVtZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHJldHVybiB7Ym9vbGVhbn1cbiAgICovXG4gIGhhc0NsYXNzKGNsYXNzTmFtZSkge31cblxuICAvKipcbiAgICogQWRkcyBhIGNsYXNzIHRvIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICBhZGRDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYSBjbGFzcyBmcm9tIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gY2xhc3NOYW1lXG4gICAqL1xuICByZW1vdmVDbGFzcyhjbGFzc05hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgYSBzdHJpbmcgaWYgYXR0cmlidXRlIG5hbWUgZXhpc3RzIG9uIHRoZSBzbGlkZXIgRWxlbWVudCxcbiAgICogb3RoZXJ3aXNlIHJldHVybnMgbnVsbFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJuIHs/c3RyaW5nfVxuICAgKi9cbiAgZ2V0QXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYXR0cmlidXRlIG5hbWUgb24gc2xpZGVyIEVsZW1lbnQgdG8gdmFsdWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRBdHRyaWJ1dGUobmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYXR0cmlidXRlIG5hbWUgZnJvbSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKi9cbiAgcmVtb3ZlQXR0cmlidXRlKG5hbWUpIHt9XG5cbiAgLyoqXG4gICAqIFJldHVybnMgdGhlIGJvdW5kaW5nIGNsaWVudCByZWN0IGZvciB0aGUgc2xpZGVyIEVsZW1lbnRcbiAgICogQHJldHVybiB7P0NsaWVudFJlY3R9XG4gICAqL1xuICBjb21wdXRlQm91bmRpbmdSZWN0KCkge31cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgdGFiIGluZGV4IG9mIHRoZSBzbGlkZXIgRWxlbWVudFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqL1xuICBnZXRUYWJJbmRleCgpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcih0eXBlLCBoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBEZXJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSByb290IGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIG9uIHRoZSB0aHVtYiBjb250YWluZXIgZWxlbWVudCBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogUmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgb24gdGhlIGJvZHkgZm9yIGEgZ2l2ZW4gZXZlbnQuXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlXG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIodHlwZSwgaGFuZGxlcikge31cblxuICAvKipcbiAgICogRGVyZWdpc3RlcnMgYW4gZXZlbnQgaGFuZGxlciBvbiB0aGUgYm9keSBmb3IgYSBnaXZlbiBldmVudC5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVcbiAgICogQHBhcmFtIHtmdW5jdGlvbighRXZlbnQpOiB1bmRlZmluZWR9IGhhbmRsZXJcbiAgICovXG4gIGRlcmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKHR5cGUsIGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIFJlZ2lzdGVycyBhbiBldmVudCBoYW5kbGVyIGZvciB0aGUgd2luZG93IHJlc2l6ZSBldmVudFxuICAgKiBAcGFyYW0ge2Z1bmN0aW9uKCFFdmVudCk6IHVuZGVmaW5lZH0gaGFuZGxlclxuICAgKi9cbiAgcmVnaXN0ZXJSZXNpemVIYW5kbGVyKGhhbmRsZXIpIHt9XG5cbiAgLyoqXG4gICAqIERlcmVnaXN0ZXJzIGFuIGV2ZW50IGhhbmRsZXIgZm9yIHRoZSB3aW5kb3cgcmVzaXplIGV2ZW50XG4gICAqIEBwYXJhbSB7ZnVuY3Rpb24oIUV2ZW50KTogdW5kZWZpbmVkfSBoYW5kbGVyXG4gICAqL1xuICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcihoYW5kbGVyKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6aW5wdXQgZnJvbSB0aGUgcm9vdFxuICAgKi9cbiAgbm90aWZ5SW5wdXQoKSB7fVxuXG4gIC8qKlxuICAgKiBFbWl0cyBhIGN1c3RvbSBldmVudCBNRENTbGlkZXI6Y2hhbmdlIGZyb20gdGhlIHJvb3RcbiAgICovXG4gIG5vdGlmeUNoYW5nZSgpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdGh1bWIgY29udGFpbmVyIGVsZW1lbnQgdG8gdGhlIHBhc3NlZCB2YWx1ZVxuICAgKiBAcGFyYW0ge3N0cmluZ30gcHJvcGVydHlOYW1lXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2YWx1ZVxuICAgKi9cbiAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5KHByb3BlcnR5TmFtZSwgdmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIFNldHMgYSBzdHlsZSBwcm9wZXJ0eSBvZiB0aGUgdHJhY2sgZWxlbWVudCB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRUcmFja1N0eWxlUHJvcGVydHkocHJvcGVydHlOYW1lLCB2YWx1ZSkge31cblxuICAvKipcbiAgICogU2V0cyB0aGUgaW5uZXIgdGV4dCBvZiB0aGUgcGluIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZVxuICAgKi9cbiAgc2V0TWFya2VyVmFsdWUodmFsdWUpIHt9XG5cbiAgLyoqXG4gICAqIEFwcGVuZHMgdGhlIHBhc3NlZCBudW1iZXIgb2YgdHJhY2sgbWFya2VycyB0byB0aGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtTWFya2Vyc1xuICAgKi9cbiAgYXBwZW5kVHJhY2tNYXJrZXJzKG51bU1hcmtlcnMpIHt9XG5cbiAgLyoqXG4gICAqIFJlbW92ZXMgYWxsIHRyYWNrIG1hcmtlcnMgZnJvbXQgaGUgdHJhY2sgbWFyayBjb250YWluZXIgZWxlbWVudFxuICAgKi9cbiAgcmVtb3ZlVHJhY2tNYXJrZXJzKCkge31cblxuICAvKipcbiAgICogU2V0cyBhIHN0eWxlIHByb3BlcnR5IG9mIHRoZSBsYXN0IHRyYWNrIG1hcmtlciB0byB0aGUgcGFzc2VkIHZhbHVlXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWVcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZhbHVlXG4gICAqL1xuICBzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eShwcm9wZXJ0eU5hbWUsIHZhbHVlKSB7fVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRydWUgaWYgdGhlIHJvb3QgZWxlbWVudCBpcyBSVEwsIG90aGVyd2lzZSBmYWxzZVxuICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgKi9cbiAgaXNSVEwoKSB7fVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJBZGFwdGVyO1xuIiwiLyoqXG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IDIwMTYgR29vZ2xlIEluYy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgICBodHRwOi8vd3d3LmFwYWNoZS5vcmcvbGljZW5zZXMvTElDRU5TRS0yLjBcbiAqXG4gKiBVbmxlc3MgcmVxdWlyZWQgYnkgYXBwbGljYWJsZSBsYXcgb3IgYWdyZWVkIHRvIGluIHdyaXRpbmcsIHNvZnR3YXJlXG4gKiBkaXN0cmlidXRlZCB1bmRlciB0aGUgTGljZW5zZSBpcyBkaXN0cmlidXRlZCBvbiBhbiBcIkFTIElTXCIgQkFTSVMsXG4gKiBXSVRIT1VUIFdBUlJBTlRJRVMgT1IgQ09ORElUSU9OUyBPRiBBTlkgS0lORCwgZWl0aGVyIGV4cHJlc3Mgb3IgaW1wbGllZC5cbiAqIFNlZSB0aGUgTGljZW5zZSBmb3IgdGhlIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9ucyBhbmRcbiAqIGxpbWl0YXRpb25zIHVuZGVyIHRoZSBMaWNlbnNlLlxuICovXG5cbi8qKlxuICogQHR5cGVkZWYge3tcbiAqICAgbm9QcmVmaXg6IHN0cmluZyxcbiAqICAgd2Via2l0UHJlZml4OiBzdHJpbmcsXG4gKiAgIHN0eWxlUHJvcGVydHk6IHN0cmluZ1xuICogfX1cbiAqL1xubGV0IFZlbmRvclByb3BlcnR5TWFwVHlwZTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBldmVudFR5cGVNYXAgPSB7XG4gICdhbmltYXRpb25zdGFydCc6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbnN0YXJ0JyxcbiAgICB3ZWJraXRQcmVmaXg6ICd3ZWJraXRBbmltYXRpb25TdGFydCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25lbmQnOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25lbmQnLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICdhbmltYXRpb25pdGVyYXRpb24nOiB7XG4gICAgbm9QcmVmaXg6ICdhbmltYXRpb25pdGVyYXRpb24nLFxuICAgIHdlYmtpdFByZWZpeDogJ3dlYmtpdEFuaW1hdGlvbkl0ZXJhdGlvbicsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ2FuaW1hdGlvbicsXG4gIH0sXG4gICd0cmFuc2l0aW9uZW5kJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbmVuZCcsXG4gICAgd2Via2l0UHJlZml4OiAnd2Via2l0VHJhbnNpdGlvbkVuZCcsXG4gICAgc3R5bGVQcm9wZXJ0eTogJ3RyYW5zaXRpb24nLFxuICB9LFxufTtcblxuLyoqIEBjb25zdCB7T2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovXG5jb25zdCBjc3NQcm9wZXJ0eU1hcCA9IHtcbiAgJ2FuaW1hdGlvbic6IHtcbiAgICBub1ByZWZpeDogJ2FuaW1hdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC1hbmltYXRpb24nLFxuICB9LFxuICAndHJhbnNmb3JtJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNmb3JtJyxcbiAgICB3ZWJraXRQcmVmaXg6ICctd2Via2l0LXRyYW5zZm9ybScsXG4gIH0sXG4gICd0cmFuc2l0aW9uJzoge1xuICAgIG5vUHJlZml4OiAndHJhbnNpdGlvbicsXG4gICAgd2Via2l0UHJlZml4OiAnLXdlYmtpdC10cmFuc2l0aW9uJyxcbiAgfSxcbn07XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEByZXR1cm4ge2Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGhhc1Byb3BlclNoYXBlKHdpbmRvd09iaikge1xuICByZXR1cm4gKHdpbmRvd09ialsnZG9jdW1lbnQnXSAhPT0gdW5kZWZpbmVkICYmIHR5cGVvZiB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSA9PT0gJ2Z1bmN0aW9uJyk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHJldHVybiB7Ym9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gZXZlbnRGb3VuZEluTWFwcyhldmVudFR5cGUpIHtcbiAgcmV0dXJuIChldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwIHx8IGV2ZW50VHlwZSBpbiBjc3NQcm9wZXJ0eU1hcCk7XG59XG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IGV2ZW50VHlwZVxuICogQHBhcmFtIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59IG1hcFxuICogQHBhcmFtIHshRWxlbWVudH0gZWxcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0SmF2YVNjcmlwdEV2ZW50TmFtZShldmVudFR5cGUsIG1hcCwgZWwpIHtcbiAgcmV0dXJuIG1hcFtldmVudFR5cGVdLnN0eWxlUHJvcGVydHkgaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbn1cblxuLyoqXG4gKiBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIGJyb3dzZXIgcHJlZml4IGZvciBDU1MzIGFuaW1hdGlvbiBldmVudHNcbiAqIGFuZCBwcm9wZXJ0eSBuYW1lcy5cbiAqIEBwYXJhbSB7IU9iamVjdH0gd2luZG93T2JqXG4gKiBAcGFyYW0ge3N0cmluZ30gZXZlbnRUeXBlXG4gKiBAcmV0dXJuIHtzdHJpbmd9XG4gKi9cbmZ1bmN0aW9uIGdldEFuaW1hdGlvbk5hbWUod2luZG93T2JqLCBldmVudFR5cGUpIHtcbiAgaWYgKCFoYXNQcm9wZXJTaGFwZSh3aW5kb3dPYmopIHx8ICFldmVudEZvdW5kSW5NYXBzKGV2ZW50VHlwZSkpIHtcbiAgICByZXR1cm4gZXZlbnRUeXBlO1xuICB9XG5cbiAgY29uc3QgbWFwID0gLyoqIEB0eXBlIHshT2JqZWN0PHN0cmluZywgIVZlbmRvclByb3BlcnR5TWFwVHlwZT59ICovIChcbiAgICBldmVudFR5cGUgaW4gZXZlbnRUeXBlTWFwID8gZXZlbnRUeXBlTWFwIDogY3NzUHJvcGVydHlNYXBcbiAgKTtcbiAgY29uc3QgZWwgPSB3aW5kb3dPYmpbJ2RvY3VtZW50J11bJ2NyZWF0ZUVsZW1lbnQnXSgnZGl2Jyk7XG4gIGxldCBldmVudE5hbWUgPSAnJztcblxuICBpZiAobWFwID09PSBldmVudFR5cGVNYXApIHtcbiAgICBldmVudE5hbWUgPSBnZXRKYXZhU2NyaXB0RXZlbnROYW1lKGV2ZW50VHlwZSwgbWFwLCBlbCk7XG4gIH0gZWxzZSB7XG4gICAgZXZlbnROYW1lID0gbWFwW2V2ZW50VHlwZV0ubm9QcmVmaXggaW4gZWwuc3R5bGUgPyBtYXBbZXZlbnRUeXBlXS5ub1ByZWZpeCA6IG1hcFtldmVudFR5cGVdLndlYmtpdFByZWZpeDtcbiAgfVxuXG4gIHJldHVybiBldmVudE5hbWU7XG59XG5cbi8vIFB1YmxpYyBmdW5jdGlvbnMgdG8gYWNjZXNzIGdldEFuaW1hdGlvbk5hbWUoKSBmb3IgSmF2YVNjcmlwdCBldmVudHMgb3IgQ1NTXG4vLyBwcm9wZXJ0eSBuYW1lcy5cblxuY29uc3QgdHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzID0gWyd0cmFuc2Zvcm0nLCAnV2Via2l0VHJhbnNmb3JtJywgJ01velRyYW5zZm9ybScsICdPVHJhbnNmb3JtJywgJ01TVHJhbnNmb3JtJ107XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbi8qKlxuICogQHBhcmFtIHshT2JqZWN0fSB3aW5kb3dPYmpcbiAqIEBwYXJhbSB7c3RyaW5nfSBldmVudFR5cGVcbiAqIEByZXR1cm4ge3N0cmluZ31cbiAqL1xuZnVuY3Rpb24gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSkge1xuICByZXR1cm4gZ2V0QW5pbWF0aW9uTmFtZSh3aW5kb3dPYmosIGV2ZW50VHlwZSk7XG59XG5cbmV4cG9ydCB7dHJhbnNmb3JtU3R5bGVQcm9wZXJ0aWVzLCBnZXRDb3JyZWN0RXZlbnROYW1lLCBnZXRDb3JyZWN0UHJvcGVydHlOYW1lfTtcbiIsIi8qKlxuICogQGxpY2Vuc2VcbiAqIENvcHlyaWdodCAyMDE2IEdvb2dsZSBJbmMuXG4gKlxuICogTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTtcbiAqIHlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqICAgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXG4gKlxuICogVW5sZXNzIHJlcXVpcmVkIGJ5IGFwcGxpY2FibGUgbGF3IG9yIGFncmVlZCB0byBpbiB3cml0aW5nLCBzb2Z0d2FyZVxuICogZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIExpY2Vuc2UgaXMgZGlzdHJpYnV0ZWQgb24gYW4gXCJBUyBJU1wiIEJBU0lTLFxuICogV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZIEtJTkQsIGVpdGhlciBleHByZXNzIG9yIGltcGxpZWQuXG4gKiBTZWUgdGhlIExpY2Vuc2UgZm9yIHRoZSBzcGVjaWZpYyBsYW5ndWFnZSBnb3Zlcm5pbmcgcGVybWlzc2lvbnMgYW5kXG4gKiBsaW1pdGF0aW9ucyB1bmRlciB0aGUgTGljZW5zZS5cbiAqL1xuXG4vKipcbiAqIEB0ZW1wbGF0ZSBBXG4gKi9cbmNsYXNzIE1EQ0ZvdW5kYXRpb24ge1xuICAvKiogQHJldHVybiBlbnVte2Nzc0NsYXNzZXN9ICovXG4gIHN0YXRpYyBnZXQgY3NzQ2xhc3NlcygpIHtcbiAgICAvLyBDbGFzc2VzIGV4dGVuZGluZyBNRENGb3VuZGF0aW9uIHNob3VsZCBpbXBsZW1lbnQgdGhpcyBtZXRob2QgdG8gcmV0dXJuIGFuIG9iamVjdCB3aGljaCBleHBvcnRzIGV2ZXJ5XG4gICAgLy8gQ1NTIGNsYXNzIHRoZSBmb3VuZGF0aW9uIGNsYXNzIG5lZWRzIGFzIGEgcHJvcGVydHkuIGUuZy4ge0FDVElWRTogJ21kYy1jb21wb25lbnQtLWFjdGl2ZSd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtzdHJpbmdzfSAqL1xuICBzdGF0aWMgZ2V0IHN0cmluZ3MoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBzZW1hbnRpYyBzdHJpbmdzIGFzIGNvbnN0YW50cy4gZS5nLiB7QVJJQV9ST0xFOiAndGFibGlzdCd9XG4gICAgcmV0dXJuIHt9O1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bXtudW1iZXJzfSAqL1xuICBzdGF0aWMgZ2V0IG51bWJlcnMoKSB7XG4gICAgLy8gQ2xhc3NlcyBleHRlbmRpbmcgTURDRm91bmRhdGlvbiBzaG91bGQgaW1wbGVtZW50IHRoaXMgbWV0aG9kIHRvIHJldHVybiBhbiBvYmplY3Qgd2hpY2ggZXhwb3J0cyBhbGxcbiAgICAvLyBvZiBpdHMgc2VtYW50aWMgbnVtYmVycyBhcyBjb25zdGFudHMuIGUuZy4ge0FOSU1BVElPTl9ERUxBWV9NUzogMzUwfVxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHshT2JqZWN0fSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIC8vIENsYXNzZXMgZXh0ZW5kaW5nIE1EQ0ZvdW5kYXRpb24gbWF5IGNob29zZSB0byBpbXBsZW1lbnQgdGhpcyBnZXR0ZXIgaW4gb3JkZXIgdG8gcHJvdmlkZSBhIGNvbnZlbmllbnRcbiAgICAvLyB3YXkgb2Ygdmlld2luZyB0aGUgbmVjZXNzYXJ5IG1ldGhvZHMgb2YgYW4gYWRhcHRlci4gSW4gdGhlIGZ1dHVyZSwgdGhpcyBjb3VsZCBhbHNvIGJlIHVzZWQgZm9yIGFkYXB0ZXJcbiAgICAvLyB2YWxpZGF0aW9uLlxuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge0E9fSBhZGFwdGVyXG4gICAqL1xuICBjb25zdHJ1Y3RvcihhZGFwdGVyID0ge30pIHtcbiAgICAvKiogQHByb3RlY3RlZCB7IUF9ICovXG4gICAgdGhpcy5hZGFwdGVyXyA9IGFkYXB0ZXI7XG4gIH1cblxuICBpbml0KCkge1xuICAgIC8vIFN1YmNsYXNzZXMgc2hvdWxkIG92ZXJyaWRlIHRoaXMgbWV0aG9kIHRvIHBlcmZvcm0gaW5pdGlhbGl6YXRpb24gcm91dGluZXMgKHJlZ2lzdGVyaW5nIGV2ZW50cywgZXRjLilcbiAgfVxuXG4gIGRlc3Ryb3koKSB7XG4gICAgLy8gU3ViY2xhc3NlcyBzaG91bGQgb3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gcGVyZm9ybSBkZS1pbml0aWFsaXphdGlvbiByb3V0aW5lcyAoZGUtcmVnaXN0ZXJpbmcgZXZlbnRzLCBldGMuKVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IE1EQ0ZvdW5kYXRpb247XG4iLCIvKipcbiAqIEBsaWNlbnNlXG4gKiBDb3B5cmlnaHQgMjAxNyBHb29nbGUgSW5jLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxuICpcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5zZSwgVmVyc2lvbiAyLjAgKHRoZSBcIkxpY2Vuc2VcIik7XG4gKnlvdSBtYXkgbm90IHVzZSB0aGlzIGZpbGUgZXhjZXB0IGluIGNvbXBsaWFuY2Ugd2l0aCB0aGUgTGljZW5zZS5cbiAqIFlvdSBtYXkgb2J0YWluIGEgY29weSBvZiB0aGUgTGljZW5zZSBhdFxuICpcbiAqIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKi9cblxuaW1wb3J0IHtjc3NDbGFzc2VzLCBzdHJpbmdzLCBudW1iZXJzfSBmcm9tICcuL2NvbnN0YW50cyc7XG5pbXBvcnQgTURDU2xpZGVyQWRhcHRlciBmcm9tICcuL2FkYXB0ZXInO1xuXG5pbXBvcnQge2dldENvcnJlY3RFdmVudE5hbWUsIGdldENvcnJlY3RQcm9wZXJ0eU5hbWV9IGZyb20gJ0BtYXRlcmlhbC9hbmltYXRpb24vaW5kZXgnO1xuaW1wb3J0IE1EQ0ZvdW5kYXRpb24gZnJvbSAnQG1hdGVyaWFsL2Jhc2UvZm91bmRhdGlvbic7XG5cbi8qKiBAZW51bSB7c3RyaW5nfSAqL1xuY29uc3QgS0VZX0lEUyA9IHtcbiAgQVJST1dfTEVGVDogJ0Fycm93TGVmdCcsXG4gIEFSUk9XX1JJR0hUOiAnQXJyb3dSaWdodCcsXG4gIEFSUk9XX1VQOiAnQXJyb3dVcCcsXG4gIEFSUk9XX0RPV046ICdBcnJvd0Rvd24nLFxuICBIT01FOiAnSG9tZScsXG4gIEVORDogJ0VuZCcsXG4gIFBBR0VfVVA6ICdQYWdlVXAnLFxuICBQQUdFX0RPV046ICdQYWdlRG93bicsXG59O1xuXG4vKiogQGVudW0ge3N0cmluZ30gKi9cbmNvbnN0IE1PVkVfRVZFTlRfTUFQID0ge1xuICAnbW91c2Vkb3duJzogJ21vdXNlbW92ZScsXG4gICd0b3VjaHN0YXJ0JzogJ3RvdWNobW92ZScsXG4gICdwb2ludGVyZG93bic6ICdwb2ludGVybW92ZScsXG59O1xuXG5jb25zdCBET1dOX0VWRU5UUyA9IFsnbW91c2Vkb3duJywgJ3BvaW50ZXJkb3duJywgJ3RvdWNoc3RhcnQnXTtcbmNvbnN0IFVQX0VWRU5UUyA9IFsnbW91c2V1cCcsICdwb2ludGVydXAnLCAndG91Y2hlbmQnXTtcblxuLyoqXG4gKiBAZXh0ZW5kcyB7TURDRm91bmRhdGlvbjwhTURDU2xpZGVyQWRhcHRlcj59XG4gKi9cbmNsYXNzIE1EQ1NsaWRlckZvdW5kYXRpb24gZXh0ZW5kcyBNRENGb3VuZGF0aW9uIHtcbiAgLyoqIEByZXR1cm4gZW51bSB7Y3NzQ2xhc3Nlc30gKi9cbiAgc3RhdGljIGdldCBjc3NDbGFzc2VzKCkge1xuICAgIHJldHVybiBjc3NDbGFzc2VzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7c3RyaW5nc30gKi9cbiAgc3RhdGljIGdldCBzdHJpbmdzKCkge1xuICAgIHJldHVybiBzdHJpbmdzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4gZW51bSB7bnVtYmVyc30gKi9cbiAgc3RhdGljIGdldCBudW1iZXJzKCkge1xuICAgIHJldHVybiBudW1iZXJzO1xuICB9XG5cbiAgLyoqIEByZXR1cm4geyFNRENTbGlkZXJBZGFwdGVyfSAqL1xuICBzdGF0aWMgZ2V0IGRlZmF1bHRBZGFwdGVyKCkge1xuICAgIHJldHVybiAvKiogQHR5cGUgeyFNRENTbGlkZXJBZGFwdGVyfSAqLyAoe1xuICAgICAgaGFzQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICAgIGFkZENsYXNzOiAoLyogY2xhc3NOYW1lOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQ2xhc3M6ICgvKiBjbGFzc05hbWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBnZXRBdHRyaWJ1dGU6ICgvKiBuYW1lOiBzdHJpbmcgKi8pID0+IC8qIHN0cmluZ3xudWxsICovIG51bGwsXG4gICAgICBzZXRBdHRyaWJ1dGU6ICgvKiBuYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgcmVtb3ZlQXR0cmlidXRlOiAoLyogbmFtZTogc3RyaW5nICovKSA9PiB7fSxcbiAgICAgIGNvbXB1dGVCb3VuZGluZ1JlY3Q6ICgpID0+IC8qIENsaWVudFJlY3QgKi8gKHtcbiAgICAgICAgdG9wOiAwLCByaWdodDogMCwgYm90dG9tOiAwLCBsZWZ0OiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwLFxuICAgICAgfSksXG4gICAgICBnZXRUYWJJbmRleDogKCkgPT4gLyogbnVtYmVyICovIDAsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICgvKiB0eXBlOiBzdHJpbmcsIGhhbmRsZXI6IEV2ZW50TGlzdGVuZXIgKi8pID0+IHt9LFxuICAgICAgZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyOiAoLyogdHlwZTogc3RyaW5nLCBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIHJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKC8qIHR5cGU6IHN0cmluZywgaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICByZWdpc3RlclJlc2l6ZUhhbmRsZXI6ICgvKiBoYW5kbGVyOiBFdmVudExpc3RlbmVyICovKSA9PiB7fSxcbiAgICAgIGRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyOiAoLyogaGFuZGxlcjogRXZlbnRMaXN0ZW5lciAqLykgPT4ge30sXG4gICAgICBub3RpZnlJbnB1dDogKCkgPT4ge30sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHt9LFxuICAgICAgc2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0VHJhY2tTdHlsZVByb3BlcnR5OiAoLyogcHJvcGVydHlOYW1lOiBzdHJpbmcsIHZhbHVlOiBzdHJpbmcgKi8pID0+IHt9LFxuICAgICAgc2V0TWFya2VyVmFsdWU6ICgvKiB2YWx1ZTogbnVtYmVyICovKSA9PiB7fSxcbiAgICAgIGFwcGVuZFRyYWNrTWFya2VyczogKC8qIG51bU1hcmtlcnM6IG51bWJlciAqLykgPT4ge30sXG4gICAgICByZW1vdmVUcmFja01hcmtlcnM6ICgpID0+IHt9LFxuICAgICAgc2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHk6ICgvKiBwcm9wZXJ0eU5hbWU6IHN0cmluZywgdmFsdWU6IHN0cmluZyAqLykgPT4ge30sXG4gICAgICBpc1JUTDogKCkgPT4gLyogYm9vbGVhbiAqLyBmYWxzZSxcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgbmV3IGluc3RhbmNlIG9mIE1EQ1NsaWRlckZvdW5kYXRpb25cbiAgICogQHBhcmFtIHs/TURDU2xpZGVyQWRhcHRlcn0gYWRhcHRlclxuICAgKi9cbiAgY29uc3RydWN0b3IoYWRhcHRlcikge1xuICAgIHN1cGVyKE9iamVjdC5hc3NpZ24oTURDU2xpZGVyRm91bmRhdGlvbi5kZWZhdWx0QWRhcHRlciwgYWRhcHRlcikpO1xuICAgIC8qKiBAcHJpdmF0ZSB7P0NsaWVudFJlY3R9ICovXG4gICAgdGhpcy5yZWN0XyA9IG51bGw7XG4gICAgLy8gV2Ugc2V0IHRoaXMgdG8gTmFOIHNpbmNlIHdlIHdhbnQgaXQgdG8gYmUgYSBudW1iZXIsIGJ1dCB3ZSBjYW4ndCB1c2UgJzAnIG9yICctMSdcbiAgICAvLyBiZWNhdXNlIHRob3NlIGNvdWxkIGJlIHZhbGlkIHRhYmluZGljZXMgc2V0IGJ5IHRoZSBjbGllbnQgY29kZS5cbiAgICB0aGlzLnNhdmVkVGFiSW5kZXhfID0gTmFOO1xuICAgIHRoaXMuYWN0aXZlXyA9IGZhbHNlO1xuICAgIHRoaXMuaW5UcmFuc2l0XyA9IGZhbHNlO1xuICAgIHRoaXMuaXNEaXNjcmV0ZV8gPSBmYWxzZTtcbiAgICB0aGlzLmhhc1RyYWNrTWFya2VyXyA9IGZhbHNlO1xuICAgIHRoaXMuaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8gPSBmYWxzZTtcbiAgICB0aGlzLm1pbl8gPSAwO1xuICAgIHRoaXMubWF4XyA9IDEwMDtcbiAgICB0aGlzLnN0ZXBfID0gMDtcbiAgICB0aGlzLnZhbHVlXyA9IDA7XG4gICAgdGhpcy5kaXNhYmxlZF8gPSBmYWxzZTtcbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IGZhbHNlO1xuICAgIHRoaXMudXBkYXRlVUlGcmFtZV8gPSAwO1xuICAgIHRoaXMudGh1bWJDb250YWluZXJQb2ludGVySGFuZGxlcl8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmhhbmRsaW5nVGh1bWJUYXJnZXRFdnRfID0gdHJ1ZTtcbiAgICB9O1xuICAgIHRoaXMuaW50ZXJhY3Rpb25TdGFydEhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVEb3duXyhldnQpO1xuICAgIHRoaXMua2V5ZG93bkhhbmRsZXJfID0gKGV2dCkgPT4gdGhpcy5oYW5kbGVLZXlkb3duXyhldnQpO1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyXyA9ICgpID0+IHRoaXMuaGFuZGxlRm9jdXNfKCk7XG4gICAgdGhpcy5ibHVySGFuZGxlcl8gPSAoKSA9PiB0aGlzLmhhbmRsZUJsdXJfKCk7XG4gICAgdGhpcy5yZXNpemVIYW5kbGVyXyA9ICgpID0+IHRoaXMubGF5b3V0KCk7XG4gIH1cblxuICBpbml0KCkge1xuICAgIHRoaXMuaXNEaXNjcmV0ZV8gPSB0aGlzLmFkYXB0ZXJfLmhhc0NsYXNzKGNzc0NsYXNzZXMuSVNfRElTQ1JFVEUpO1xuICAgIHRoaXMuaGFzVHJhY2tNYXJrZXJfID0gdGhpcy5hZGFwdGVyXy5oYXNDbGFzcyhjc3NDbGFzc2VzLkhBU19UUkFDS19NQVJLRVIpO1xuICAgIERPV05fRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoZXZ0TmFtZSwgdGhpcy5pbnRlcmFjdGlvblN0YXJ0SGFuZGxlcl8pKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIoJ2ZvY3VzJywgdGhpcy5mb2N1c0hhbmRsZXJfKTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdibHVyJywgdGhpcy5ibHVySGFuZGxlcl8pO1xuICAgIERPV05fRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLnJlZ2lzdGVyUmVzaXplSGFuZGxlcih0aGlzLnJlc2l6ZUhhbmRsZXJfKTtcbiAgICB0aGlzLmxheW91dCgpO1xuICAgIC8vIEF0IGxhc3Qgc3RlcCwgcHJvdmlkZSBhIHJlYXNvbmFibGUgZGVmYXVsdCB2YWx1ZSB0byBkaXNjcmV0ZSBzbGlkZXJcbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiB0aGlzLmdldFN0ZXAoKSA9PSAwKSB7XG4gICAgICB0aGlzLnN0ZXBfID0gMTtcbiAgICB9XG4gIH1cblxuICBkZXN0cm95KCkge1xuICAgIERPV05fRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB0aGlzLmludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyk7XG4gICAgfSk7XG4gICAgdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyKCdrZXlkb3duJywgdGhpcy5rZXlkb3duSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignZm9jdXMnLCB0aGlzLmZvY3VzSGFuZGxlcl8pO1xuICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcignYmx1cicsIHRoaXMuYmx1ckhhbmRsZXJfKTtcbiAgICBET1dOX0VWRU5UUy5mb3JFYWNoKChldnROYW1lKSA9PiB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB0aGlzLnRodW1iQ29udGFpbmVyUG9pbnRlckhhbmRsZXJfKTtcbiAgICB9KTtcbiAgICB0aGlzLmFkYXB0ZXJfLmRlcmVnaXN0ZXJSZXNpemVIYW5kbGVyKHRoaXMucmVzaXplSGFuZGxlcl8pO1xuICB9XG5cbiAgc2V0dXBUcmFja01hcmtlcigpIHtcbiAgICBpZiAodGhpcy5pc0Rpc2NyZXRlXyAmJiB0aGlzLmhhc1RyYWNrTWFya2VyXyYmIHRoaXMuZ2V0U3RlcCgpICE9IDApIHtcbiAgICAgIGNvbnN0IG1pbiA9IHRoaXMuZ2V0TWluKCk7XG4gICAgICBjb25zdCBtYXggPSB0aGlzLmdldE1heCgpO1xuICAgICAgY29uc3Qgc3RlcCA9IHRoaXMuZ2V0U3RlcCgpO1xuICAgICAgbGV0IG51bU1hcmtlcnMgPSAobWF4IC0gbWluKSAvIHN0ZXA7XG5cbiAgICAgIC8vIEluIGNhc2UgZGlzdGFuY2UgYmV0d2VlbiBtYXggJiBtaW4gaXMgaW5kaXZpc2libGUgdG8gc3RlcCxcbiAgICAgIC8vIHdlIHBsYWNlIHRoZSBzZWNvbmRhcnkgdG8gbGFzdCBtYXJrZXIgcHJvcG9ydGlvbmFsbHkgYXQgd2hlcmUgdGh1bWJcbiAgICAgIC8vIGNvdWxkIHJlYWNoIGFuZCBwbGFjZSB0aGUgbGFzdCBtYXJrZXIgYXQgbWF4IHZhbHVlXG4gICAgICBjb25zdCBpbmRpdmlzaWJsZSA9IE1hdGguY2VpbChudW1NYXJrZXJzKSAhPT0gbnVtTWFya2VycztcbiAgICAgIGlmIChpbmRpdmlzaWJsZSkge1xuICAgICAgICBudW1NYXJrZXJzID0gTWF0aC5jZWlsKG51bU1hcmtlcnMpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZVRyYWNrTWFya2VycygpO1xuICAgICAgdGhpcy5hZGFwdGVyXy5hcHBlbmRUcmFja01hcmtlcnMobnVtTWFya2Vycyk7XG5cbiAgICAgIGlmIChpbmRpdmlzaWJsZSkge1xuICAgICAgICBjb25zdCBsYXN0U3RlcFJhdGlvID0gKG1heCAtIG51bU1hcmtlcnMgKiBzdGVwKSAvIHN0ZXAgKyAxO1xuICAgICAgICBjb25zdCBmbGV4ID0gZ2V0Q29ycmVjdFByb3BlcnR5TmFtZSh3aW5kb3csICdmbGV4Jyk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uc2V0TGFzdFRyYWNrTWFya2Vyc1N0eWxlUHJvcGVydHkoZmxleCwgU3RyaW5nKGxhc3RTdGVwUmF0aW8pKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBsYXlvdXQoKSB7XG4gICAgdGhpcy5yZWN0XyA9IHRoaXMuYWRhcHRlcl8uY29tcHV0ZUJvdW5kaW5nUmVjdCgpO1xuICAgIHRoaXMudXBkYXRlVUlGb3JDdXJyZW50VmFsdWVfKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRWYWx1ZSgpIHtcbiAgICByZXR1cm4gdGhpcy52YWx1ZV87XG4gIH1cblxuICAvKiogQHBhcmFtIHtudW1iZXJ9IHZhbHVlICovXG4gIHNldFZhbHVlKHZhbHVlKSB7XG4gICAgdGhpcy5zZXRWYWx1ZV8odmFsdWUsIGZhbHNlKTtcbiAgfVxuXG4gIC8qKiBAcmV0dXJuIHtudW1iZXJ9ICovXG4gIGdldE1heCgpIHtcbiAgICByZXR1cm4gdGhpcy5tYXhfO1xuICB9XG5cbiAgLyoqIEBwYXJhbSB7bnVtYmVyfSBtYXggKi9cbiAgc2V0TWF4KG1heCkge1xuICAgIGlmIChtYXggPCB0aGlzLm1pbl8pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ2Fubm90IHNldCBtYXggdG8gYmUgbGVzcyB0aGFuIHRoZSBzbGlkZXJcXCdzIG1pbmltdW0gdmFsdWUnKTtcbiAgICB9XG4gICAgdGhpcy5tYXhfID0gbWF4O1xuICAgIHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX1ZBTFVFTUFYLCBTdHJpbmcodGhpcy5tYXhfKSk7XG4gICAgdGhpcy5zZXR1cFRyYWNrTWFya2VyKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7bnVtYmVyfSAqL1xuICBnZXRNaW4oKSB7XG4gICAgcmV0dXJuIHRoaXMubWluXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gbWluICovXG4gIHNldE1pbihtaW4pIHtcbiAgICBpZiAobWluID4gdGhpcy5tYXhfKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Nhbm5vdCBzZXQgbWluIHRvIGJlIGdyZWF0ZXIgdGhhbiB0aGUgc2xpZGVyXFwncyBtYXhpbXVtIHZhbHVlJyk7XG4gICAgfVxuICAgIHRoaXMubWluXyA9IG1pbjtcbiAgICB0aGlzLnNldFZhbHVlXyh0aGlzLnZhbHVlXywgZmFsc2UsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9WQUxVRU1JTiwgU3RyaW5nKHRoaXMubWluXykpO1xuICAgIHRoaXMuc2V0dXBUcmFja01hcmtlcigpO1xuICB9XG5cbiAgLyoqIEByZXR1cm4ge251bWJlcn0gKi9cbiAgZ2V0U3RlcCgpIHtcbiAgICByZXR1cm4gdGhpcy5zdGVwXztcbiAgfVxuXG4gIC8qKiBAcGFyYW0ge251bWJlcn0gc3RlcCAqL1xuICBzZXRTdGVwKHN0ZXApIHtcbiAgICBpZiAoc3RlcCA8IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignU3RlcCBjYW5ub3QgYmUgc2V0IHRvIGEgbmVnYXRpdmUgbnVtYmVyJyk7XG4gICAgfVxuICAgIGlmICh0aGlzLmlzRGlzY3JldGVfICYmICh0eXBlb2Yoc3RlcCkgIT09ICdudW1iZXInIHx8IHN0ZXAgPCAxKSkge1xuICAgICAgc3RlcCA9IDE7XG4gICAgfVxuICAgIHRoaXMuc3RlcF8gPSBzdGVwO1xuICAgIHRoaXMuc2V0VmFsdWVfKHRoaXMudmFsdWVfLCBmYWxzZSwgdHJ1ZSk7XG4gICAgdGhpcy5zZXR1cFRyYWNrTWFya2VyKCk7XG4gIH1cblxuICAvKiogQHJldHVybiB7Ym9vbGVhbn0gKi9cbiAgaXNEaXNhYmxlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXNhYmxlZF87XG4gIH1cblxuICAvKiogQHBhcmFtIHtib29sZWFufSBkaXNhYmxlZCAqL1xuICBzZXREaXNhYmxlZChkaXNhYmxlZCkge1xuICAgIHRoaXMuZGlzYWJsZWRfID0gZGlzYWJsZWQ7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5ESVNBQkxFRCwgdGhpcy5kaXNhYmxlZF8pO1xuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgdGhpcy5zYXZlZFRhYkluZGV4XyA9IHRoaXMuYWRhcHRlcl8uZ2V0VGFiSW5kZXgoKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uc2V0QXR0cmlidXRlKHN0cmluZ3MuQVJJQV9ESVNBQkxFRCwgJ3RydWUnKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQXR0cmlidXRlKCd0YWJpbmRleCcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnJlbW92ZUF0dHJpYnV0ZShzdHJpbmdzLkFSSUFfRElTQUJMRUQpO1xuICAgICAgaWYgKCFpc05hTih0aGlzLnNhdmVkVGFiSW5kZXhfKSkge1xuICAgICAgICB0aGlzLmFkYXB0ZXJfLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCBTdHJpbmcodGhpcy5zYXZlZFRhYkluZGV4XykpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBDYWxsZWQgd2hlbiB0aGUgdXNlciBzdGFydHMgaW50ZXJhY3Rpbmcgd2l0aCB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7IUV2ZW50fSBldnRcbiAgICogQHByaXZhdGVcbiAgICovXG4gIGhhbmRsZURvd25fKGV2dCkge1xuICAgIGlmICh0aGlzLmRpc2FibGVkXykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRoaXMucHJldmVudEZvY3VzU3RhdGVfID0gdHJ1ZTtcbiAgICB0aGlzLnNldEluVHJhbnNpdF8oIXRoaXMuaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8pO1xuICAgIHRoaXMuaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8gPSBmYWxzZTtcbiAgICB0aGlzLnNldEFjdGl2ZV8odHJ1ZSk7XG5cbiAgICBjb25zdCBtb3ZlSGFuZGxlciA9IChldnQpID0+IHtcbiAgICAgIHRoaXMuaGFuZGxlTW92ZV8oZXZ0KTtcbiAgICB9O1xuXG4gICAgLy8gTm90ZTogdXBIYW5kbGVyIGlzIFtkZV1yZWdpc3RlcmVkIG9uIEFMTCBwb3RlbnRpYWwgcG9pbnRlci1yZWxhdGVkIHJlbGVhc2UgZXZlbnQgdHlwZXMsIHNpbmNlIHNvbWUgYnJvd3NlcnNcbiAgICAvLyBkbyBub3QgYWx3YXlzIGZpcmUgdGhlc2UgY29uc2lzdGVudGx5IGluIHBhaXJzLlxuICAgIC8vIChTZWUgaHR0cHM6Ly9naXRodWIuY29tL21hdGVyaWFsLWNvbXBvbmVudHMvbWF0ZXJpYWwtY29tcG9uZW50cy13ZWIvaXNzdWVzLzExOTIpXG4gICAgY29uc3QgdXBIYW5kbGVyID0gKCkgPT4ge1xuICAgICAgdGhpcy5oYW5kbGVVcF8oKTtcbiAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoTU9WRV9FVkVOVF9NQVBbZXZ0LnR5cGVdLCBtb3ZlSGFuZGxlcik7XG4gICAgICBVUF9FVkVOVFMuZm9yRWFjaCgoZXZ0TmFtZSkgPT4gdGhpcy5hZGFwdGVyXy5kZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcihldnROYW1lLCB1cEhhbmRsZXIpKTtcbiAgICB9O1xuXG4gICAgdGhpcy5hZGFwdGVyXy5yZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIoTU9WRV9FVkVOVF9NQVBbZXZ0LnR5cGVdLCBtb3ZlSGFuZGxlcik7XG4gICAgVVBfRVZFTlRTLmZvckVhY2goKGV2dE5hbWUpID0+IHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyKGV2dE5hbWUsIHVwSGFuZGxlcikpO1xuICAgIHRoaXMuc2V0VmFsdWVGcm9tRXZ0XyhldnQpO1xuICB9XG5cbiAgLyoqXG4gICAqIENhbGxlZCB3aGVuIHRoZSB1c2VyIG1vdmVzIHRoZSBzbGlkZXJcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlTW92ZV8oZXZ0KSB7XG4gICAgZXZ0LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy5zZXRWYWx1ZUZyb21FdnRfKGV2dCk7XG4gIH1cblxuICAvKipcbiAgICogQ2FsbGVkIHdoZW4gdGhlIHVzZXIncyBpbnRlcmFjdGlvbiB3aXRoIHRoZSBzbGlkZXIgZW5kc1xuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgaGFuZGxlVXBfKCkge1xuICAgIHRoaXMuc2V0QWN0aXZlXyhmYWxzZSk7XG4gICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlDaGFuZ2UoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBwYWdlWCBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGV2dFxuICAgKiBAcmV0dXJuIHtudW1iZXJ9XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBnZXRQYWdlWF8oZXZ0KSB7XG4gICAgaWYgKGV2dC50YXJnZXRUb3VjaGVzICYmIGV2dC50YXJnZXRUb3VjaGVzLmxlbmd0aCA+IDApIHtcbiAgICAgIHJldHVybiBldnQudGFyZ2V0VG91Y2hlc1swXS5wYWdlWDtcbiAgICB9XG4gICAgcmV0dXJuIGV2dC5wYWdlWDtcbiAgfVxuXG4gIC8qKlxuICAgKiBTZXRzIHRoZSBzbGlkZXIgdmFsdWUgZnJvbSBhbiBldmVudFxuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqIEBwcml2YXRlXG4gICAqL1xuICBzZXRWYWx1ZUZyb21FdnRfKGV2dCkge1xuICAgIGNvbnN0IHBhZ2VYID0gdGhpcy5nZXRQYWdlWF8oZXZ0KTtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyhwYWdlWCk7XG4gICAgdGhpcy5zZXRWYWx1ZV8odmFsdWUsIHRydWUpO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBuZXcgdmFsdWUgZnJvbSB0aGUgcGFnZVggcG9zaXRpb25cbiAgICogQHBhcmFtIHtudW1iZXJ9IHBhZ2VYXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGNvbXB1dGVWYWx1ZUZyb21QYWdlWF8ocGFnZVgpIHtcbiAgICBjb25zdCB7bWF4XzogbWF4LCBtaW5fOiBtaW59ID0gdGhpcztcbiAgICBjb25zdCB4UG9zID0gcGFnZVggLSB0aGlzLnJlY3RfLmxlZnQ7XG4gICAgbGV0IHBjdENvbXBsZXRlID0geFBvcyAvIHRoaXMucmVjdF8ud2lkdGg7XG4gICAgaWYgKHRoaXMuYWRhcHRlcl8uaXNSVEwoKSkge1xuICAgICAgcGN0Q29tcGxldGUgPSAxIC0gcGN0Q29tcGxldGU7XG4gICAgfVxuICAgIC8vIEZpdCB0aGUgcGVyY2VudGFnZSBjb21wbGV0ZSBiZXR3ZWVuIHRoZSByYW5nZSBbbWluLG1heF1cbiAgICAvLyBieSByZW1hcHBpbmcgZnJvbSBbMCwgMV0gdG8gW21pbiwgbWluKyhtYXgtbWluKV0uXG4gICAgcmV0dXJuIG1pbiArIHBjdENvbXBsZXRlICogKG1heCAtIG1pbik7XG4gIH1cblxuICAvKipcbiAgICogSGFuZGxlcyBrZXlkb3duIGV2ZW50c1xuICAgKiBAcGFyYW0geyFFdmVudH0gZXZ0XG4gICAqL1xuICBoYW5kbGVLZXlkb3duXyhldnQpIHtcbiAgICBjb25zdCBrZXlJZCA9IHRoaXMuZ2V0S2V5SWRfKGV2dCk7XG4gICAgY29uc3QgdmFsdWUgPSB0aGlzLmdldFZhbHVlRm9yS2V5SWRfKGtleUlkKTtcbiAgICBpZiAoaXNOYU4odmFsdWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gUHJldmVudCBwYWdlIGZyb20gc2Nyb2xsaW5nIGR1ZSB0byBrZXkgcHJlc3NlcyB0aGF0IHdvdWxkIG5vcm1hbGx5IHNjcm9sbCB0aGUgcGFnZVxuICAgIGV2dC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5GT0NVUyk7XG4gICAgdGhpcy5zZXRWYWx1ZV8odmFsdWUsIHRydWUpO1xuICAgIHRoaXMuYWRhcHRlcl8ubm90aWZ5Q2hhbmdlKCk7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJucyB0aGUgY29tcHV0ZWQgbmFtZSBvZiB0aGUgZXZlbnRcbiAgICogQHBhcmFtIHshRXZlbnR9IGtiZEV2dFxuICAgKiBAcmV0dXJuIHtzdHJpbmd9XG4gICAqL1xuICBnZXRLZXlJZF8oa2JkRXZ0KSB7XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuQVJST1dfTEVGVCB8fCBrYmRFdnQua2V5Q29kZSA9PT0gMzcpIHtcbiAgICAgIHJldHVybiBLRVlfSURTLkFSUk9XX0xFRlQ7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX1JJR0hUIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzOSkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfUklHSFQ7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX1VQIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzOCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuQVJST1dfVVA7XG4gICAgfVxuICAgIGlmIChrYmRFdnQua2V5ID09PSBLRVlfSURTLkFSUk9XX0RPV04gfHwga2JkRXZ0LmtleUNvZGUgPT09IDQwKSB7XG4gICAgICByZXR1cm4gS0VZX0lEUy5BUlJPV19ET1dOO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5IT01FIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzNikge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuSE9NRTtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuRU5EIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzNSkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuRU5EO1xuICAgIH1cbiAgICBpZiAoa2JkRXZ0LmtleSA9PT0gS0VZX0lEUy5QQUdFX1VQIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzMykge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuUEFHRV9VUDtcbiAgICB9XG4gICAgaWYgKGtiZEV2dC5rZXkgPT09IEtFWV9JRFMuUEFHRV9ET1dOIHx8IGtiZEV2dC5rZXlDb2RlID09PSAzNCkge1xuICAgICAgcmV0dXJuIEtFWV9JRFMuUEFHRV9ET1dOO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgdmFsdWUgZ2l2ZW4gYSBrZXlib2FyZCBrZXkgSURcbiAgICogQHBhcmFtIHtzdHJpbmd9IGtleUlkXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldFZhbHVlRm9yS2V5SWRfKGtleUlkKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWluLCBzdGVwXzogc3RlcH0gPSB0aGlzO1xuICAgIGxldCBkZWx0YSA9IHN0ZXAgfHwgKG1heCAtIG1pbikgLyAxMDA7XG4gICAgY29uc3QgdmFsdWVOZWVkc1RvQmVGbGlwcGVkID0gdGhpcy5hZGFwdGVyXy5pc1JUTCgpICYmIChcbiAgICAgIGtleUlkID09PSBLRVlfSURTLkFSUk9XX0xFRlQgfHwga2V5SWQgPT09IEtFWV9JRFMuQVJST1dfUklHSFRcbiAgICApO1xuICAgIGlmICh2YWx1ZU5lZWRzVG9CZUZsaXBwZWQpIHtcbiAgICAgIGRlbHRhID0gLWRlbHRhO1xuICAgIH1cblxuICAgIHN3aXRjaCAoa2V5SWQpIHtcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfTEVGVDpcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfRE9XTjpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyAtIGRlbHRhO1xuICAgIGNhc2UgS0VZX0lEUy5BUlJPV19SSUdIVDpcbiAgICBjYXNlIEtFWV9JRFMuQVJST1dfVVA6XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gKyBkZWx0YTtcbiAgICBjYXNlIEtFWV9JRFMuSE9NRTpcbiAgICAgIHJldHVybiB0aGlzLm1pbl87XG4gICAgY2FzZSBLRVlfSURTLkVORDpcbiAgICAgIHJldHVybiB0aGlzLm1heF87XG4gICAgY2FzZSBLRVlfSURTLlBBR0VfVVA6XG4gICAgICByZXR1cm4gdGhpcy52YWx1ZV8gKyBkZWx0YSAqIG51bWJlcnMuUEFHRV9GQUNUT1I7XG4gICAgY2FzZSBLRVlfSURTLlBBR0VfRE9XTjpcbiAgICAgIHJldHVybiB0aGlzLnZhbHVlXyAtIGRlbHRhICogbnVtYmVycy5QQUdFX0ZBQ1RPUjtcbiAgICBkZWZhdWx0OlxuICAgICAgcmV0dXJuIE5hTjtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVGb2N1c18oKSB7XG4gICAgaWYgKHRoaXMucHJldmVudEZvY3VzU3RhdGVfKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY3NzQ2xhc3Nlcy5GT0NVUyk7XG4gIH1cblxuICBoYW5kbGVCbHVyXygpIHtcbiAgICB0aGlzLnByZXZlbnRGb2N1c1N0YXRlXyA9IGZhbHNlO1xuICAgIHRoaXMuYWRhcHRlcl8ucmVtb3ZlQ2xhc3MoY3NzQ2xhc3Nlcy5GT0NVUyk7XG4gIH1cblxuICAvKipcbiAgICogU2V0cyB0aGUgdmFsdWUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRGaXJlSW5wdXRcbiAgICogQHBhcmFtIHtib29sZWFuPX0gZm9yY2VcbiAgICovXG4gIHNldFZhbHVlXyh2YWx1ZSwgc2hvdWxkRmlyZUlucHV0LCBmb3JjZSA9IGZhbHNlKSB7XG4gICAgaWYgKHZhbHVlID09PSB0aGlzLnZhbHVlXyAmJiAhZm9yY2UpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBjb25zdCB7bWluXzogbWluLCBtYXhfOiBtYXh9ID0gdGhpcztcbiAgICBjb25zdCB2YWx1ZVNldFRvQm91bmRhcnkgPSB2YWx1ZSA9PT0gbWluIHx8IHZhbHVlID09PSBtYXg7XG4gICAgaWYgKHRoaXMuc3RlcF8gJiYgIXZhbHVlU2V0VG9Cb3VuZGFyeSkge1xuICAgICAgdmFsdWUgPSB0aGlzLnF1YW50aXplXyh2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh2YWx1ZSA8IG1pbikge1xuICAgICAgdmFsdWUgPSBtaW47XG4gICAgfSBlbHNlIGlmICh2YWx1ZSA+IG1heCkge1xuICAgICAgdmFsdWUgPSBtYXg7XG4gICAgfVxuICAgIHRoaXMudmFsdWVfID0gdmFsdWU7XG4gICAgdGhpcy5hZGFwdGVyXy5zZXRBdHRyaWJ1dGUoc3RyaW5ncy5BUklBX1ZBTFVFTk9XLCBTdHJpbmcodGhpcy52YWx1ZV8pKTtcbiAgICB0aGlzLnVwZGF0ZVVJRm9yQ3VycmVudFZhbHVlXygpO1xuXG4gICAgaWYgKHNob3VsZEZpcmVJbnB1dCkge1xuICAgICAgdGhpcy5hZGFwdGVyXy5ub3RpZnlJbnB1dCgpO1xuICAgICAgaWYgKHRoaXMuaXNEaXNjcmV0ZV8pIHtcbiAgICAgICAgdGhpcy5hZGFwdGVyXy5zZXRNYXJrZXJWYWx1ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIENhbGN1bGF0ZXMgdGhlIHF1YW50aXplZCB2YWx1ZVxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWVcbiAgICogQHJldHVybiB7bnVtYmVyfVxuICAgKi9cbiAgcXVhbnRpemVfKHZhbHVlKSB7XG4gICAgY29uc3QgbnVtU3RlcHMgPSBNYXRoLnJvdW5kKHZhbHVlIC8gdGhpcy5zdGVwXyk7XG4gICAgY29uc3QgcXVhbnRpemVkVmFsID0gbnVtU3RlcHMgKiB0aGlzLnN0ZXBfO1xuICAgIHJldHVybiBxdWFudGl6ZWRWYWw7XG4gIH1cblxuICB1cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8oKSB7XG4gICAgY29uc3Qge21heF86IG1heCwgbWluXzogbWluLCB2YWx1ZV86IHZhbHVlfSA9IHRoaXM7XG4gICAgY29uc3QgcGN0Q29tcGxldGUgPSAodmFsdWUgLSBtaW4pIC8gKG1heCAtIG1pbik7XG4gICAgbGV0IHRyYW5zbGF0ZVB4ID0gcGN0Q29tcGxldGUgKiB0aGlzLnJlY3RfLndpZHRoO1xuICAgIGlmICh0aGlzLmFkYXB0ZXJfLmlzUlRMKCkpIHtcbiAgICAgIHRyYW5zbGF0ZVB4ID0gdGhpcy5yZWN0Xy53aWR0aCAtIHRyYW5zbGF0ZVB4O1xuICAgIH1cblxuICAgIGNvbnN0IHRyYW5zZm9ybVByb3AgPSBnZXRDb3JyZWN0UHJvcGVydHlOYW1lKHdpbmRvdywgJ3RyYW5zZm9ybScpO1xuICAgIGNvbnN0IHRyYW5zaXRpb25lbmRFdnROYW1lID0gZ2V0Q29ycmVjdEV2ZW50TmFtZSh3aW5kb3csICd0cmFuc2l0aW9uZW5kJyk7XG5cbiAgICBpZiAodGhpcy5pblRyYW5zaXRfKSB7XG4gICAgICBjb25zdCBvblRyYW5zaXRpb25FbmQgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuc2V0SW5UcmFuc2l0XyhmYWxzZSk7XG4gICAgICAgIHRoaXMuYWRhcHRlcl8uZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyKHRyYW5zaXRpb25lbmRFdnROYW1lLCBvblRyYW5zaXRpb25FbmQpO1xuICAgICAgfTtcbiAgICAgIHRoaXMuYWRhcHRlcl8ucmVnaXN0ZXJUaHVtYkNvbnRhaW5lckludGVyYWN0aW9uSGFuZGxlcih0cmFuc2l0aW9uZW5kRXZ0TmFtZSwgb25UcmFuc2l0aW9uRW5kKTtcbiAgICB9XG5cbiAgICB0aGlzLnVwZGF0ZVVJRnJhbWVfID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgIC8vIE5PVEUodHJhdmlza2F1Zm1hbik6IEl0IHdvdWxkIGJlIG5pY2UgdG8gdXNlIGNhbGMoKSBoZXJlLFxuICAgICAgLy8gYnV0IElFIGNhbm5vdCBoYW5kbGUgY2FsY3MgaW4gdHJhbnNmb3JtcyBjb3JyZWN0bHkuXG4gICAgICAvLyBTZWU6IGh0dHBzOi8vZ29vLmdsL05DMml0a1xuICAgICAgLy8gQWxzbyBub3RlIHRoYXQgdGhlIC01MCUgb2Zmc2V0IGlzIHVzZWQgdG8gY2VudGVyIHRoZSBzbGlkZXIgdGh1bWIuXG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eSh0cmFuc2Zvcm1Qcm9wLCBgdHJhbnNsYXRlWCgke3RyYW5zbGF0ZVB4fXB4KSB0cmFuc2xhdGVYKC01MCUpYCk7XG4gICAgICB0aGlzLmFkYXB0ZXJfLnNldFRyYWNrU3R5bGVQcm9wZXJ0eSh0cmFuc2Zvcm1Qcm9wLCBgc2NhbGVYKCR7cGN0Q29tcGxldGV9KWApO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFRvZ2dsZXMgdGhlIGFjdGl2ZSBzdGF0ZSBvZiB0aGUgc2xpZGVyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gYWN0aXZlXG4gICAqL1xuICBzZXRBY3RpdmVfKGFjdGl2ZSkge1xuICAgIHRoaXMuYWN0aXZlXyA9IGFjdGl2ZTtcbiAgICB0aGlzLnRvZ2dsZUNsYXNzXyhjc3NDbGFzc2VzLkFDVElWRSwgdGhpcy5hY3RpdmVfKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUb2dnbGVzIHRoZSBpblRyYW5zaXQgc3RhdGUgb2YgdGhlIHNsaWRlclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGluVHJhbnNpdFxuICAgKi9cbiAgc2V0SW5UcmFuc2l0XyhpblRyYW5zaXQpIHtcbiAgICB0aGlzLmluVHJhbnNpdF8gPSBpblRyYW5zaXQ7XG4gICAgdGhpcy50b2dnbGVDbGFzc18oY3NzQ2xhc3Nlcy5JTl9UUkFOU0lULCB0aGlzLmluVHJhbnNpdF8pO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbmRpdGlvbmFsbHkgYWRkcyBvciByZW1vdmVzIGEgY2xhc3MgYmFzZWQgb24gc2hvdWxkQmVQcmVzZW50XG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjbGFzc05hbWVcbiAgICogQHBhcmFtIHtib29sZWFufSBzaG91bGRCZVByZXNlbnRcbiAgICovXG4gIHRvZ2dsZUNsYXNzXyhjbGFzc05hbWUsIHNob3VsZEJlUHJlc2VudCkge1xuICAgIGlmIChzaG91bGRCZVByZXNlbnQpIHtcbiAgICAgIHRoaXMuYWRhcHRlcl8uYWRkQ2xhc3MoY2xhc3NOYW1lKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGFwdGVyXy5yZW1vdmVDbGFzcyhjbGFzc05hbWUpO1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgZGVmYXVsdCBNRENTbGlkZXJGb3VuZGF0aW9uO1xuIiwibGV0IGJ1c187XG5cbmV4cG9ydCBjb25zdCBldmVudEJ1cyA9IHtcbiAgaW5zdGFsbCh2dWUpIHtcbiAgICBidXNfID0gbmV3IHZ1ZSgpO1xuICB9LFxuICAkZW1pdChldmVudCwgLi4uYXJncykge1xuICAgIGJ1c18gJiYgYnVzXy4kZW1pdChldmVudCwgLi4uYXJncyk7XG4gIH0sXG4gICRvbihldmVudCwgY2FsbGJhY2spIHtcbiAgICBidXNfICYmIGJ1c18uJG9uKGV2ZW50LCBjYWxsYmFjayk7XG4gIH0sXG4gICRvbmNlKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGJ1c18gJiYgYnVzXy4kb25jZShldmVudCwgY2FsbGJhY2spO1xuICB9LFxuICAkb2ZmKGV2ZW50LCBjYWxsYmFjaykge1xuICAgIGJ1c18gJiYgYnVzXy4kb2ZmKGV2ZW50LCBjYWxsYmFjayk7XG4gIH0sXG59O1xuIiwiPHRlbXBsYXRlPlxuICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlclwiIDpjbGFzcz1cImNsYXNzZXNcIiB0YWJpbmRleD1cIjBcIiByb2xlPVwic2xpZGVyXCI+XG4gICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLWNvbnRhaW5lclwiPlxuICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrXCIgOnN0eWxlPVwidHJhY2tTdHlsZXNcIj48L2Rpdj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX190cmFjay1tYXJrZXItY29udGFpbmVyXCIgdi1pZj1cImhhc01hcmtlcnNcIj5cbiAgICAgICAgPGRpdiBjbGFzcz1cIm1kYy1zbGlkZXJfX3RyYWNrLW1hcmtlclwiXG4gICAgICAgICAgdi1mb3I9XCJtYXJrZXJOdW0gaW4gbnVtTWFya2Vyc1wiXG4gICAgICAgICAgOmtleT1cIm1hcmtlck51bVwiXG4gICAgICAgICAgOnN0eWxlPVwiKG1hcmtlck51bSA9PSBudW1NYXJrZXJzKSA/IGxhc3RUcmFja01hcmtlcnNTdHlsZXMgOiB7fVwiXG4gICAgICAgICAgPjwvZGl2PlxuICAgICAgPC9kaXY+XG4gICAgPC9kaXY+XG4gICAgPGRpdiByZWY9XCJ0aHVtYkNvbnRhaW5lclwiIDpzdHlsZT1cInRodW1iU3R5bGVzXCIgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYi1jb250YWluZXJcIj5cbiAgICAgIDxkaXYgY2xhc3M9XCJtZGMtc2xpZGVyX19waW5cIiB2LWlmPVwiaXNEaXNjcmV0ZVwiPlxuICAgICAgICA8c3BhbiBjbGFzcz1cIm1kYy1zbGlkZXJfX3Bpbi12YWx1ZS1tYXJrZXJcIj57e21hcmtlclZhbHVlfX08L3NwYW4+XG4gICAgICA8L2Rpdj5cbiAgICAgIDxzdmcgY2xhc3M9XCJtZGMtc2xpZGVyX190aHVtYlwiIHdpZHRoPVwiMjFcIiBoZWlnaHQ9XCIyMVwiPlxuICAgICAgICA8Y2lyY2xlIGN4PVwiMTAuNVwiIGN5PVwiMTAuNVwiIHI9XCI3Ljg3NVwiPjwvY2lyY2xlPlxuICAgICAgPC9zdmc+XG4gICAgICA8ZGl2IGNsYXNzPVwibWRjLXNsaWRlcl9fZm9jdXMtcmluZ1wiPjwvZGl2PlxuICAgIDwvZGl2PlxuICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgTURDU2xpZGVyRm91bmRhdGlvbiBmcm9tICdAbWF0ZXJpYWwvc2xpZGVyL2ZvdW5kYXRpb24nO1xuaW1wb3J0IHsgRGlzcGF0Y2hGb2N1c01peGluIH0gZnJvbSAnLi4vYmFzZSc7XG5pbXBvcnQgeyBldmVudEJ1cyB9IGZyb20gJy4uL2NvbW1vbic7XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ21kYy1zbGlkZXInLFxuICBtaXhpbnM6IFtEaXNwYXRjaEZvY3VzTWl4aW5dLFxuICBtb2RlbDoge1xuICAgIHByb3A6ICd2YWx1ZScsXG4gICAgZXZlbnQ6ICdjaGFuZ2UnLFxuICB9LFxuICBwcm9wczoge1xuICAgIHZhbHVlOiBbTnVtYmVyLCBTdHJpbmddLFxuICAgIG1pbjogeyB0eXBlOiBbTnVtYmVyLCBTdHJpbmddLCBkZWZhdWx0OiAwIH0sXG4gICAgbWF4OiB7IHR5cGU6IFtOdW1iZXIsIFN0cmluZ10sIGRlZmF1bHQ6IDEwMCB9LFxuICAgIHN0ZXA6IHsgdHlwZTogW051bWJlciwgU3RyaW5nXSwgZGVmYXVsdDogMCB9LFxuICAgIGRpc3BsYXlNYXJrZXJzOiBCb29sZWFuLFxuICAgIGRpc2FibGVkOiBCb29sZWFuLFxuICAgIGxheW91dE9uOiBTdHJpbmcsXG4gICAgbGF5b3V0T25Tb3VyY2U6IHsgdHlwZTogT2JqZWN0LCByZXF1aXJlZDogZmFsc2UgfSxcbiAgfSxcbiAgZGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgY2xhc3Nlczoge1xuICAgICAgICAnbWRjLXNsaWRlci0tZGlzY3JldGUnOiAhIXRoaXMuc3RlcCxcbiAgICAgICAgJ21kYy1zbGlkZXItLWRpc3BsYXktbWFya2Vycyc6IHRoaXMuZGlzcGxheU1hcmtlcnMsXG4gICAgICB9LFxuICAgICAgdHJhY2tTdHlsZXM6IHt9LFxuICAgICAgbGFzdFRyYWNrTWFya2Vyc1N0eWxlczoge30sXG4gICAgICB0aHVtYlN0eWxlczoge30sXG4gICAgICBtYXJrZXJWYWx1ZTogJycsXG4gICAgICBudW1NYXJrZXJzOiAwLFxuICAgIH07XG4gIH0sXG4gIGNvbXB1dGVkOiB7XG4gICAgaXNEaXNjcmV0ZSgpIHtcbiAgICAgIHJldHVybiAhIXRoaXMuc3RlcDtcbiAgICB9LFxuICAgIGhhc01hcmtlcnMoKSB7XG4gICAgICByZXR1cm4gISF0aGlzLnN0ZXAgJiYgdGhpcy5kaXNwbGF5TWFya2VycyAmJiB0aGlzLm51bU1hcmtlcnM7XG4gICAgfSxcbiAgfSxcbiAgd2F0Y2g6IHtcbiAgICB2YWx1ZSgpIHtcbiAgICAgIGlmICh0aGlzLmZvdW5kYXRpb24uZ2V0VmFsdWUoKSAhPT0gTnVtYmVyKHRoaXMudmFsdWUpKSB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZSh0aGlzLnZhbHVlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIG1pbigpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSk7XG4gICAgfSxcbiAgICBtYXgoKSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgIH0sXG4gICAgc3RlcCgpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRTdGVwKE51bWJlcih0aGlzLnN0ZXApKTtcbiAgICB9LFxuICAgIGRpc2FibGVkKCkge1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldERpc2FibGVkKHRoaXMuZGlzYWJsZWQpO1xuICAgIH0sXG4gIH0sXG4gIG1ldGhvZHM6IHtcbiAgICBsYXlvdXQoKSB7XG4gICAgICB0aGlzLiRuZXh0VGljaygoKSA9PiB7XG4gICAgICAgIHRoaXMuZm91bmRhdGlvbiAmJiB0aGlzLmZvdW5kYXRpb24ubGF5b3V0KCk7XG4gICAgICB9KTtcbiAgICB9LFxuICB9LFxuICBtb3VudGVkKCkge1xuICAgIHRoaXMuZm91bmRhdGlvbiA9IG5ldyBNRENTbGlkZXJGb3VuZGF0aW9uKHtcbiAgICAgIGhhc0NsYXNzOiBjbGFzc05hbWUgPT4gdGhpcy4kZWwuY2xhc3NMaXN0LmNvbnRhaW5zKGNsYXNzTmFtZSksXG4gICAgICBhZGRDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICByZW1vdmVDbGFzczogY2xhc3NOYW1lID0+IHtcbiAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuY2xhc3NlcywgY2xhc3NOYW1lLCB0cnVlKTtcbiAgICAgIH0sXG4gICAgICBnZXRBdHRyaWJ1dGU6IG5hbWUgPT4gdGhpcy4kZWwuZ2V0QXR0cmlidXRlKG5hbWUpLFxuICAgICAgc2V0QXR0cmlidXRlOiAobmFtZSwgdmFsdWUpID0+IHRoaXMuJGVsLnNldEF0dHJpYnV0ZShuYW1lLCB2YWx1ZSksXG4gICAgICByZW1vdmVBdHRyaWJ1dGU6IG5hbWUgPT4gdGhpcy4kZWwucmVtb3ZlQXR0cmlidXRlKG5hbWUpLFxuICAgICAgY29tcHV0ZUJvdW5kaW5nUmVjdDogKCkgPT4gdGhpcy4kZWwuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCksXG4gICAgICBnZXRUYWJJbmRleDogKCkgPT4gdGhpcy4kZWwudGFiSW5kZXgsXG4gICAgICByZWdpc3RlckludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgdGhpcy4kZWwuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVySW50ZXJhY3Rpb25IYW5kbGVyOiAodHlwZSwgaGFuZGxlcikgPT4ge1xuICAgICAgICB0aGlzLiRlbC5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyVGh1bWJDb250YWluZXJJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIHRoaXMuJHJlZnMudGh1bWJDb250YWluZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICByZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXI6ICh0eXBlLCBoYW5kbGVyKSA9PiB7XG4gICAgICAgIGRvY3VtZW50LmJvZHkuYWRkRXZlbnRMaXN0ZW5lcih0eXBlLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyQm9keUludGVyYWN0aW9uSGFuZGxlcjogKHR5cGUsIGhhbmRsZXIpID0+IHtcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGhhbmRsZXIpO1xuICAgICAgfSxcbiAgICAgIHJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBkZXJlZ2lzdGVyUmVzaXplSGFuZGxlcjogaGFuZGxlciA9PiB7XG4gICAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBoYW5kbGVyKTtcbiAgICAgIH0sXG4gICAgICBub3RpZnlJbnB1dDogKCkgPT4ge1xuICAgICAgICB0aGlzLiRlbWl0KCdpbnB1dCcsIHRoaXMuZm91bmRhdGlvbi5nZXRWYWx1ZSgpKTtcbiAgICAgIH0sXG4gICAgICBub3RpZnlDaGFuZ2U6ICgpID0+IHtcbiAgICAgICAgdGhpcy4kZW1pdCgnY2hhbmdlJywgdGhpcy5mb3VuZGF0aW9uLmdldFZhbHVlKCkpO1xuICAgICAgfSxcbiAgICAgIHNldFRodW1iQ29udGFpbmVyU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudGh1bWJTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldFRyYWNrU3R5bGVQcm9wZXJ0eTogKHByb3BlcnR5TmFtZSwgdmFsdWUpID0+IHtcbiAgICAgICAgdGhpcy4kc2V0KHRoaXMudHJhY2tTdHlsZXMsIHByb3BlcnR5TmFtZSwgdmFsdWUpO1xuICAgICAgfSxcbiAgICAgIHNldE1hcmtlclZhbHVlOiB2YWx1ZSA9PiB7XG4gICAgICAgIHRoaXMubWFya2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgIH0sXG4gICAgICBhcHBlbmRUcmFja01hcmtlcnM6IG51bU1hcmtlcnMgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSBudW1NYXJrZXJzO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZVRyYWNrTWFya2VyczogKCkgPT4ge1xuICAgICAgICB0aGlzLm51bU1hcmtlcnMgPSAwO1xuICAgICAgfSxcbiAgICAgIHNldExhc3RUcmFja01hcmtlcnNTdHlsZVByb3BlcnR5OiAocHJvcGVydHlOYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICB0aGlzLiRzZXQodGhpcy5sYXN0VHJhY2tNYXJrZXJzU3R5bGVzLCBwcm9wZXJ0eU5hbWUsIHZhbHVlKTtcbiAgICAgIH0sXG4gICAgICBpc1JUTDogKCkgPT4gZmFsc2UsXG4gICAgfSk7XG5cbiAgICB0aGlzLmZvdW5kYXRpb24uaW5pdCgpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5zZXREaXNhYmxlZCh0aGlzLmRpc2FibGVkKTtcbiAgICBpZiAoTnVtYmVyKHRoaXMubWluKSA8PSB0aGlzLmZvdW5kYXRpb24uZ2V0TWF4KCkpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXRNaW4oTnVtYmVyKHRoaXMubWluKSk7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmZvdW5kYXRpb24uc2V0TWF4KE51bWJlcih0aGlzLm1heCkpO1xuICAgICAgdGhpcy5mb3VuZGF0aW9uLnNldE1pbihOdW1iZXIodGhpcy5taW4pKTtcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLnNldFN0ZXAoTnVtYmVyKHRoaXMuc3RlcCkpO1xuICAgIHRoaXMuZm91bmRhdGlvbi5zZXRWYWx1ZShOdW1iZXIodGhpcy52YWx1ZSkpO1xuICAgIGlmICh0aGlzLmhhc01hcmtlcnMpIHtcbiAgICAgIHRoaXMuZm91bmRhdGlvbi5zZXR1cFRyYWNrTWFya2VyKCk7XG4gICAgfVxuXG4gICAgZXZlbnRCdXMuJG9uKCdtZGM6bGF5b3V0JywgdGhpcy5sYXlvdXQpO1xuXG4gICAgaWYgKHRoaXMubGF5b3V0T24pIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZSA9IHRoaXMubGF5b3V0T25Tb3VyY2UgfHwgdGhpcy4kcm9vdDtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb24odGhpcy5sYXlvdXRPbiwgdGhpcy5sYXlvdXQpO1xuICAgIH1cbiAgfSxcbiAgYmVmb3JlRGVzdHJveSgpIHtcbiAgICBldmVudEJ1cy4kb2ZmKCdtZGM6bGF5b3V0JywgdGhpcy5sYXlvdXQpO1xuICAgIGlmICh0aGlzLmxheW91dE9uRXZlbnRTb3VyY2UpIHtcbiAgICAgIHRoaXMubGF5b3V0T25FdmVudFNvdXJjZS4kb2ZmKHRoaXMubGF5b3V0T24sIHRoaXMubGF5b3V0KTtcbiAgICB9XG4gICAgdGhpcy5mb3VuZGF0aW9uLmRlc3Ryb3koKTtcbiAgfSxcbn07XG48L3NjcmlwdD5cbiIsImltcG9ydCB7QmFzZVBsdWdpbn0gZnJvbSAnLi4vYmFzZSdcbmltcG9ydCBtZGNTbGlkZXIgZnJvbSAnLi9tZGMtc2xpZGVyLnZ1ZSdcblxuZXhwb3J0IHtcbiAgbWRjU2xpZGVyXG59XG5cbmV4cG9ydCBkZWZhdWx0IEJhc2VQbHVnaW4oe1xuICBtZGNTbGlkZXJcbn0pXG4iLCJpbXBvcnQgJy4vc3R5bGVzLnNjc3MnXG5pbXBvcnQge2F1dG9Jbml0fSBmcm9tICcuLi9iYXNlJ1xuaW1wb3J0IHBsdWdpbiBmcm9tICcuL2luZGV4LmpzJ1xuZXhwb3J0IGRlZmF1bHQgcGx1Z2luXG5cbmF1dG9Jbml0KHBsdWdpbilcbiJdLCJuYW1lcyI6WyJhdXRvSW5pdCIsInBsdWdpbiIsIl9WdWUiLCJ3aW5kb3ciLCJWdWUiLCJnbG9iYWwiLCJ1c2UiLCJCYXNlUGx1Z2luIiwiY29tcG9uZW50cyIsInZlcnNpb24iLCJpbnN0YWxsIiwidm0iLCJrZXkiLCJjb21wb25lbnQiLCJuYW1lIiwiRGlzcGF0Y2hGb2N1c01peGluIiwiZGF0YSIsImhhc0ZvY3VzIiwibWV0aG9kcyIsIm9uTW91c2VEb3duIiwiX2FjdGl2ZSIsIm9uTW91c2VVcCIsIm9uRm9jdXNFdmVudCIsInNldFRpbWVvdXQiLCJkaXNwYXRjaEZvY3VzRXZlbnQiLCJvbkJsdXJFdmVudCIsIiRlbCIsImRvY3VtZW50IiwiYWN0aXZlRWxlbWVudCIsImNvbnRhaW5zIiwiJGVtaXQiLCJtb3VudGVkIiwiYWRkRXZlbnRMaXN0ZW5lciIsImJlZm9yZURlc3Ryb3kiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwiY3NzQ2xhc3NlcyIsIkFDVElWRSIsIkRJU0FCTEVEIiwiRElTQ1JFVEUiLCJGT0NVUyIsIklOX1RSQU5TSVQiLCJJU19ESVNDUkVURSIsIkhBU19UUkFDS19NQVJLRVIiLCJzdHJpbmdzIiwiVFJBQ0tfU0VMRUNUT1IiLCJUUkFDS19NQVJLRVJfQ09OVEFJTkVSX1NFTEVDVE9SIiwiTEFTVF9UUkFDS19NQVJLRVJfU0VMRUNUT1IiLCJUSFVNQl9DT05UQUlORVJfU0VMRUNUT1IiLCJQSU5fVkFMVUVfTUFSS0VSX1NFTEVDVE9SIiwiQVJJQV9WQUxVRU1JTiIsIkFSSUFfVkFMVUVNQVgiLCJBUklBX1ZBTFVFTk9XIiwiQVJJQV9ESVNBQkxFRCIsIlNURVBfREFUQV9BVFRSIiwiQ0hBTkdFX0VWRU5UIiwiSU5QVVRfRVZFTlQiLCJudW1iZXJzIiwiUEFHRV9GQUNUT1IiLCJNRENTbGlkZXJBZGFwdGVyIiwiY2xhc3NOYW1lIiwidmFsdWUiLCJ0eXBlIiwiaGFuZGxlciIsInByb3BlcnR5TmFtZSIsIm51bU1hcmtlcnMiLCJldmVudFR5cGVNYXAiLCJub1ByZWZpeCIsIndlYmtpdFByZWZpeCIsInN0eWxlUHJvcGVydHkiLCJjc3NQcm9wZXJ0eU1hcCIsImhhc1Byb3BlclNoYXBlIiwid2luZG93T2JqIiwidW5kZWZpbmVkIiwiZXZlbnRGb3VuZEluTWFwcyIsImV2ZW50VHlwZSIsImdldEphdmFTY3JpcHRFdmVudE5hbWUiLCJtYXAiLCJlbCIsInN0eWxlIiwiZ2V0QW5pbWF0aW9uTmFtZSIsImV2ZW50TmFtZSIsImdldENvcnJlY3RFdmVudE5hbWUiLCJnZXRDb3JyZWN0UHJvcGVydHlOYW1lIiwiTURDRm91bmRhdGlvbiIsImFkYXB0ZXIiLCJhZGFwdGVyXyIsIktFWV9JRFMiLCJBUlJPV19MRUZUIiwiQVJST1dfUklHSFQiLCJBUlJPV19VUCIsIkFSUk9XX0RPV04iLCJIT01FIiwiRU5EIiwiUEFHRV9VUCIsIlBBR0VfRE9XTiIsIk1PVkVfRVZFTlRfTUFQIiwiRE9XTl9FVkVOVFMiLCJVUF9FVkVOVFMiLCJNRENTbGlkZXJGb3VuZGF0aW9uIiwiaGFzQ2xhc3MiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwiZ2V0QXR0cmlidXRlIiwic2V0QXR0cmlidXRlIiwicmVtb3ZlQXR0cmlidXRlIiwiY29tcHV0ZUJvdW5kaW5nUmVjdCIsInRvcCIsInJpZ2h0IiwiYm90dG9tIiwibGVmdCIsIndpZHRoIiwiaGVpZ2h0IiwiZ2V0VGFiSW5kZXgiLCJyZWdpc3RlckludGVyYWN0aW9uSGFuZGxlciIsImRlcmVnaXN0ZXJJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlclRodW1iQ29udGFpbmVySW50ZXJhY3Rpb25IYW5kbGVyIiwicmVnaXN0ZXJCb2R5SW50ZXJhY3Rpb25IYW5kbGVyIiwiZGVyZWdpc3RlckJvZHlJbnRlcmFjdGlvbkhhbmRsZXIiLCJyZWdpc3RlclJlc2l6ZUhhbmRsZXIiLCJkZXJlZ2lzdGVyUmVzaXplSGFuZGxlciIsIm5vdGlmeUlucHV0Iiwibm90aWZ5Q2hhbmdlIiwic2V0VGh1bWJDb250YWluZXJTdHlsZVByb3BlcnR5Iiwic2V0VHJhY2tTdHlsZVByb3BlcnR5Iiwic2V0TWFya2VyVmFsdWUiLCJhcHBlbmRUcmFja01hcmtlcnMiLCJyZW1vdmVUcmFja01hcmtlcnMiLCJzZXRMYXN0VHJhY2tNYXJrZXJzU3R5bGVQcm9wZXJ0eSIsImlzUlRMIiwiYmFiZWxIZWxwZXJzLmV4dGVuZHMiLCJkZWZhdWx0QWRhcHRlciIsInJlY3RfIiwic2F2ZWRUYWJJbmRleF8iLCJOYU4iLCJhY3RpdmVfIiwiaW5UcmFuc2l0XyIsImlzRGlzY3JldGVfIiwiaGFzVHJhY2tNYXJrZXJfIiwiaGFuZGxpbmdUaHVtYlRhcmdldEV2dF8iLCJtaW5fIiwibWF4XyIsInN0ZXBfIiwidmFsdWVfIiwiZGlzYWJsZWRfIiwicHJldmVudEZvY3VzU3RhdGVfIiwidXBkYXRlVUlGcmFtZV8iLCJ0aHVtYkNvbnRhaW5lclBvaW50ZXJIYW5kbGVyXyIsImludGVyYWN0aW9uU3RhcnRIYW5kbGVyXyIsImV2dCIsImhhbmRsZURvd25fIiwia2V5ZG93bkhhbmRsZXJfIiwiaGFuZGxlS2V5ZG93bl8iLCJmb2N1c0hhbmRsZXJfIiwiaGFuZGxlRm9jdXNfIiwiYmx1ckhhbmRsZXJfIiwiaGFuZGxlQmx1cl8iLCJyZXNpemVIYW5kbGVyXyIsImxheW91dCIsImZvckVhY2giLCJldnROYW1lIiwiZ2V0U3RlcCIsIm1pbiIsImdldE1pbiIsIm1heCIsImdldE1heCIsInN0ZXAiLCJpbmRpdmlzaWJsZSIsIk1hdGgiLCJjZWlsIiwibGFzdFN0ZXBSYXRpbyIsImZsZXgiLCJTdHJpbmciLCJ1cGRhdGVVSUZvckN1cnJlbnRWYWx1ZV8iLCJzZXRWYWx1ZV8iLCJFcnJvciIsInNldHVwVHJhY2tNYXJrZXIiLCJkaXNhYmxlZCIsInRvZ2dsZUNsYXNzXyIsImlzTmFOIiwic2V0SW5UcmFuc2l0XyIsInNldEFjdGl2ZV8iLCJtb3ZlSGFuZGxlciIsImhhbmRsZU1vdmVfIiwidXBIYW5kbGVyIiwiaGFuZGxlVXBfIiwic2V0VmFsdWVGcm9tRXZ0XyIsInByZXZlbnREZWZhdWx0IiwidGFyZ2V0VG91Y2hlcyIsImxlbmd0aCIsInBhZ2VYIiwiZ2V0UGFnZVhfIiwiY29tcHV0ZVZhbHVlRnJvbVBhZ2VYXyIsInhQb3MiLCJwY3RDb21wbGV0ZSIsImtleUlkIiwiZ2V0S2V5SWRfIiwiZ2V0VmFsdWVGb3JLZXlJZF8iLCJrYmRFdnQiLCJrZXlDb2RlIiwiZGVsdGEiLCJ2YWx1ZU5lZWRzVG9CZUZsaXBwZWQiLCJzaG91bGRGaXJlSW5wdXQiLCJmb3JjZSIsInZhbHVlU2V0VG9Cb3VuZGFyeSIsInF1YW50aXplXyIsIm51bVN0ZXBzIiwicm91bmQiLCJxdWFudGl6ZWRWYWwiLCJ0cmFuc2xhdGVQeCIsInRyYW5zZm9ybVByb3AiLCJ0cmFuc2l0aW9uZW5kRXZ0TmFtZSIsIm9uVHJhbnNpdGlvbkVuZCIsInJlcXVlc3RBbmltYXRpb25GcmFtZSIsImFjdGl2ZSIsImluVHJhbnNpdCIsInNob3VsZEJlUHJlc2VudCIsImJ1c18iLCJldmVudEJ1cyIsInZ1ZSIsImV2ZW50IiwiYXJncyIsIiRvbiIsImNhbGxiYWNrIiwiJG9uY2UiLCIkb2ZmIiwicmVuZGVyIiwibWl4aW5zIiwibW9kZWwiLCJwcm9wIiwicHJvcHMiLCJOdW1iZXIiLCJkZWZhdWx0IiwiZGlzcGxheU1hcmtlcnMiLCJCb29sZWFuIiwibGF5b3V0T24iLCJsYXlvdXRPblNvdXJjZSIsIk9iamVjdCIsInJlcXVpcmVkIiwiY2xhc3NlcyIsInRyYWNrU3R5bGVzIiwibGFzdFRyYWNrTWFya2Vyc1N0eWxlcyIsInRodW1iU3R5bGVzIiwibWFya2VyVmFsdWUiLCJjb21wdXRlZCIsImlzRGlzY3JldGUiLCJoYXNNYXJrZXJzIiwid2F0Y2giLCJmb3VuZGF0aW9uIiwiZ2V0VmFsdWUiLCJzZXRWYWx1ZSIsInNldE1pbiIsInNldE1heCIsInNldFN0ZXAiLCJzZXREaXNhYmxlZCIsIiRuZXh0VGljayIsImNsYXNzTGlzdCIsIiRzZXQiLCIkZGVsZXRlIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwidGFiSW5kZXgiLCIkcmVmcyIsInRodW1iQ29udGFpbmVyIiwiYm9keSIsImluaXQiLCJsYXlvdXRPbkV2ZW50U291cmNlIiwiJHJvb3Qi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
