{"remainingRequest":"/Users/danielsecco/Downloads/quasela-master/node_modules/babel-loader/lib/index.js!/Users/danielsecco/Downloads/quasela-master/src/main.js","dependencies":[{"path":"/Users/danielsecco/Downloads/quasela-master/src/main.js","mtime":1529106825000},{"path":"/Users/danielsecco/Downloads/quasela-master/node_modules/cache-loader/dist/cjs.js","mtime":1528752079000},{"path":"/Users/danielsecco/Downloads/quasela-master/node_modules/babel-loader/lib/index.js","mtime":1519636541000}],"contextDependencies":[],"result":["(function showIndexedDbSize() {\n  \"use strict\";\n\n  var db;\n  var storesizes = new Array();\n\n  function openDatabase() {\n    return new Promise(function (resolve, reject) {\n      //prompt for DB name\n      var dbname = 'posts-store'; //prompt('Please enter your Database Name', '');\n\n      if (dbname !== null) {\n        var request = window.indexedDB.open(dbname);\n\n        request.onsuccess = function (event) {\n          db = event.target.result;\n          resolve(db.objectStoreNames);\n        };\n      }\n    });\n  }\n\n  function getObjectStoreData(storename) {\n    return new Promise(function (resolve, reject) {\n      var trans = db.transaction(storename, IDBTransaction.READ_ONLY);\n      var store = trans.objectStore(storename);\n      var items = [];\n\n      trans.oncomplete = function (evt) {\n        var szBytes = toSize(items);\n        var szMBytes = (szBytes / 1024 / 1024).toFixed(2);\n        storesizes.push({\n          'Store Name': storename,\n          'Items': items.length,\n          'Size': szMBytes + 'MB (' + szBytes + ' bytes)'\n        });\n        resolve();\n      };\n\n      var cursorRequest = store.openCursor();\n\n      cursorRequest.onerror = function (error) {\n        reject(error);\n      };\n\n      cursorRequest.onsuccess = function (evt) {\n        var cursor = evt.target.result;\n\n        if (cursor) {\n          items.push(cursor.value);\n          cursor.continue();\n        }\n      };\n    });\n  }\n\n  function toSize(items) {\n    var size = 0;\n\n    for (var i = 0; i < items.length; i++) {\n      var objectSize = JSON.stringify(items[i]).length;\n      size += objectSize * 2;\n    }\n\n    return size;\n  }\n\n  openDatabase().then(function (stores) {\n    var PromiseArray = [];\n\n    for (var i = 0; i < stores.length; i++) {\n      PromiseArray.push(getObjectStoreData(stores[i]));\n    }\n\n    Promise.all(PromiseArray).then(function () {\n      console.table(storesizes);\n    });\n  });\n})();\n\nimport Vue from 'vue'; //import ElementUI from 'element-ui';\n//import 'element-ui/lib/theme-chalk/index.css';\n\nimport App from './App.vue';\nimport router from './router';\nimport { store } from './store/store';\nimport * as config from './assets/js/config.js';\nimport VueAwesomeSwiper from 'vue-awesome-swiper';\nimport VueMDCAdapter from 'vue-mdc-adapter';\nimport Vuex from 'vuex';\nimport VueFire from 'vuefire';\nimport 'swiper/dist/css/swiper.css';\nimport './registerServiceWorker';\n\nrequire('../public/src/js/promise.js');\n\nrequire('../public/src/js/fetch.js'); //require('../public/src/js/idb.js')\n\n\nrequire('../public/src/js/material.min.js');\n\nrequire('../public/src/js/utility.js'); //require('./index.js')\n//Vue.use(ElementUI);\n\n\nVue.use(VueFire);\nVue.use(Vuex);\nVue.use(VueMDCAdapter);\nVue.use(VueAwesomeSwiper\n/* { default global options } */\n);\nVue.config.productionTip = false; // set firebase/firestore\n\nvar $ = require('jquery');\n\nvar defaultApp = firebase.initializeApp(config.configFirebase);\nexport const firestore = firebase.firestore();\n\nfunction storageEstimateWrapper() {\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    // We've got the real thing! Return its response.\n    return navigator.storage.estimate();\n  }\n\n  if ('webkitTemporaryStorage' in navigator && 'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {\n    // Return a promise-based wrapper that will follow the expected interface.\n    return new Promise(function (resolve, reject) {\n      navigator.webkitTemporaryStorage.queryUsageAndQuota(function (usage, quota) {\n        resolve({\n          usage: usage,\n          quota: quota\n        });\n      }, reject);\n    });\n  } // If we can't estimate the values, return a Promise that resolves with NaN.\n\n\n  return Promise.resolve({\n    usage: NaN,\n    quota: NaN\n  });\n} //storageEstimateWrapper();\n\n\nimport './assets/js/pushnoty.js';\nif (navigator.storage && navigator.storage.persist) navigator.storage.persist().then(function (persistent) {\n  if (persistent) console.log(\"Storage will not be cleared except by explicit user action\");else console.log(\"Storage may be cleared by the UA under storage pressure.\");\n});\n/*navigator.storage.estimate().then(function(estimate) {\n  document.getElementById(\"percent\").innerHTML =\n      (estimate.usage / estimate.quota).toFixed(2);\n});*/\n\nif ('storage' in navigator && 'estimate' in navigator.storage) {\n  navigator.storage.estimate().then(function (result) {\n    console.log('navigator.storage.estimate()');\n    console.log(result.usage);\n    console.log(result.quota);\n    document.getElementById(\"percent\").innerHTML = (result.usage / result.quota).toFixed(2);\n  });\n} else if ('webkitTemporaryStorage' in navigator && 'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {\n  navigator.webkitTemporaryStorage.queryUsageAndQuota(function (usage, quota) {\n    console.log('navigator.webkitTemporaryStorage.queryUsageAndQuota()');\n    console.log(usage);\n    console.log(quota);\n    document.getElementById(\"percent\").innerHTML = (usage / quota).toFixed(2);\n  });\n} else {\n  console.log('none');\n  console.log(NaN);\n  console.log(NaN);\n}\n/** Check if storage is persisted already.\n  @returns {Promise<boolean>} Promise resolved with true if current origin is\n  using persistent storage, false if not, and undefined if the API is not\n  present.\n*/\n\n\nasync function isStoragePersisted() {\n  return (await navigator.storage) && navigator.storage.persisted ? navigator.storage.persisted() : undefined;\n}\n/** Tries to convert to persisted storage.\n  @returns {Promise<boolean>} Promise resolved with true if successfully\n  persisted the storage, false if not, and undefined if the API is not present.\n*/\n\n\nasync function persist() {\n  return (await navigator.storage) && navigator.storage.persist ? navigator.storage.persist() : undefined;\n}\n/** Queries available disk quota.\n  @see https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate\n  @returns {Promise<{quota: number, usage: number}>} Promise resolved with\n  {quota: number, usage: number} or undefined.\n*/\n\n\nasync function showEstimatedQuota() {\n  return (await navigator.storage) && navigator.storage.estimate ? navigator.storage.estimate() : undefined;\n}\n/** Tries to persist storage without ever prompting user.\n  @returns {Promise<string>}\n    \"never\" In case persisting is not ever possible. Caller don't bother\n      asking user for permission.\n    \"prompt\" In case persisting would be possible if prompting user first.\n    \"persisted\" In case this call successfully silently persisted the storage,\n      or if it was already persisted.\n*/\n\n\nasync function tryPersistWithoutPromtingUser() {\n  if (!navigator.storage || !navigator.storage.persisted) {\n    return \"never\";\n  }\n\n  let persisted = await navigator.storage.persisted();\n\n  if (persisted) {\n    return \"persisted\";\n  }\n\n  if (!navigator.permissions || !navigator.permissions.query) {\n    return \"prompt\"; // It MAY be successful to prompt. Don't know.\n  }\n\n  const permission = await navigator.permissions.query({\n    name: \"persistent-storage\"\n  });\n\n  if (permission.status === \"granted\") {\n    persisted = await navigator.storage.persist();\n\n    if (persisted) {\n      return \"persisted\";\n    } else {\n      throw new Error(\"Failed to persist\");\n    }\n  }\n\n  if (permission.status === \"prompt\") {\n    return \"prompt\";\n  }\n\n  return \"never\";\n}\n\nasync function initStoragePersistence() {\n  const persist = await tryPersistWithoutPromtingUser();\n\n  switch (persist) {\n    case \"never\":\n      console.log(\"Not possible to persist storage\");\n      break;\n\n    case \"persisted\":\n      console.log(\"Successfully persisted storage silently\");\n      break;\n\n    case \"prompt\":\n      console.log(\"Not persisted, but we may prompt user when we want to.\");\n      break;\n  }\n}\n\ninitStoragePersistence();\n/*navigator.webkitPersistentStorage().then(function(estimate) {\n  document.getElementById(\"percent\").innerHTML =\n      (estimate.usage / estimate.quota).toFixed(2);\n});*/\n\n/*let geo = new GeolocationSensor({ frequency: 1 });\ngeo.start();\n\ngeo.onreading = () => console.log(`lat: ${geo.latitude}, long: ${geo.longitude}`);\n\ngeo.onerror = event => console.error(event.error.name, event.error.message);*/\n\n/*(function(globalObject) {\n  'use strict';\n  if (!('navigator' in globalObject) || !('location' in globalObject))\n    return;\n  \n  // [SecureContext]\n  if (globalObject.location.protocol !== 'https:')\n    return;\n  \n  if (!('storage' in globalObject.navigator))\n    globalObject.navigator.storage = {};\n  \n  var storage = globalObject.navigator.storage;\n  \n  // Promise<boolean> persisted();\n  storage.persisted = storage.persisted || function() {\n    return Promise.resolve(false);\n  };\n  \n  // [Exposed=Window] Promise<boolean> persist();\n  if ('window' in globalObject && globalObject.window === window) {\n    storage.persist = storage.persist || function() {\n      return Promise.resolve(false);\n    }; \n  }*/\n\n/*\n\nvar storageInfo = null;\n\nif(navigator.webkitTemporaryStorage) {\n  storageInfo = navigator.webkitTemporaryStorage;\n\tconsole.log('persistence ok')\n\tconsole.log(storageInfo);\n} else if(navigator.webkitPersistentStorage) {\n  storageInfo = navigator.webkitPersistentStorage;\n\tconsole.log(storageInfo);\n} else if (window.webkitStorageInfo) {\n  storageInfo = window.webkitStorageInfo;\n\tconsole.log(storageInfo);\n}\n*/\n\n/*navigator.webkitTemporaryStorage.queryUsageAndQuota ( \n    function(usedBytes, grantedBytes) {  \n        console.log('we are using ', usedBytes, ' of ', grantedBytes, 'bytes');\n    }, \n    function(e) { console.log('Error', e);  }\n);*/\n\nfirestore.settings({\n  timestampsInSnapshots: true\n});\nfirestore.enablePersistence().then(function () {\n  console.log('persistence ok');\n}).catch(function (err) {\n  store.dispatch('setErro', err);\n}); //////////////// promise\n\nvar promise = new Promise(function (resolve, reject) {\n  setTimeout(function () {\n    resolve('This is executed once the timer is done!');\n    reject({\n      code: 500,\n      message: 'An error occurred!'\n    }); //console.log('This is executed once the timer is done!');\n  }, 100);\n});\n\nif (!window.Promise) {\n  window.Promise = promise;\n}\n\n; ///////////////////////interface\n\nfunction updateUI(data) {\n  for (var i = 0; i < data.length; i++) {\n    writeData('trees', data[i]); //console.log(data);\n  }\n}\n\n;\nlet deferredPrompt;\nwindow.addEventListener('beforeinstallprompt', e => {\n  // Prevent Chrome 67 and earlier from automatically showing the prompt\n  e.preventDefault(); // Stash the event so it can be triggered later.\n\n  deferredPrompt = e;\n});\n\nfunction updateUI2(data) {\n  for (var i = 0; i < data.length; i++) {\n    delete data[i].image;\n    writeData('posts', data[i]);\n  }\n}\n\n; // header fetch(url,{myInit})\n\nvar myInit = {\n  method: 'GET',\n  headers: {\n    'Access-Control-Allow-Origin': '*/*',\n    'Content-Type': 'application/json',\n    'Accept': 'application/json'\n  },\n  mode: 'cors'\n}; //////\n\nvar networkDataReceived = false;\nfetch(config.urlTree).then(function (response) {\n  console.table(response);\n  return response.json();\n}).then(function (data) {\n  networkDataReceived = true;\n  window.furlf = data; // console.log(data.foto + '<???>' + jhg);\n\n  console.log('From web FETCH 1 >', data);\n  var dataArray = [];\n  var uio = [];\n\n  for (var key in data) {\n    dataArray.push(data[key]);\n    uio.push(data[key]); // writeData('trees', data[key]);\n  }\n\n  updateUI(dataArray); //window.ltt = uio[0];\n\n  window.dados1 = uio; // console.log(uio.length + '<???>' + jhg);\n\n  return window.dados1, window.furlf;\n}).catch(function (err) {\n  console.log(err);\n});\n/*networkDataReceived = false;\nfetch(config.url2)\n    .then(function (res) {\n        console.log(res);\n        return res.json();\n    })\n    .then(function (data) {\n        networkDataReceived = true;\n        // console.log(data.foto + '<???>' + jhg);\n        console.log('From web FETCH post fire >', data);\n        var dataArray = [];\n        $(\"#imgf\").text('');\n        for (var key in data) {\n            dataArray.push(data[key]);\n            $(\"#imgf\").append(\"<p> \" + data[key].data + '----' + data[key].id + '-->' + data[key].hora + \"</p><br> \");\n        }\n        updateUI2(dataArray);\n        // console.log(uio.length + '<???>' + jhg);\n    }).catch(function (err) {\n        console.log(err);\n    });*/\n\nexport const eventHub = new Vue();\nnew Vue({\n  router,\n  store,\n  render: h => h(App)\n}).$mount('#app');\npromise.then(function (text) {\n  return text;\n}).then(function (newText) {\n  console.log(newText);\n}).catch(function (err) {\n  console.log(err.code, err.message);\n}); ////// push",{"version":3,"sources":["src/main.js"],"names":["showIndexedDbSize","db","storesizes","Array","openDatabase","Promise","resolve","reject","dbname","request","window","indexedDB","open","onsuccess","event","target","result","objectStoreNames","getObjectStoreData","storename","trans","transaction","IDBTransaction","READ_ONLY","store","objectStore","items","oncomplete","evt","szBytes","toSize","szMBytes","toFixed","push","length","cursorRequest","openCursor","onerror","error","cursor","value","continue","size","i","objectSize","JSON","stringify","then","stores","PromiseArray","all","console","table","Vue","App","router","config","VueAwesomeSwiper","VueMDCAdapter","Vuex","VueFire","require","use","productionTip","$","defaultApp","firebase","initializeApp","configFirebase","firestore","storageEstimateWrapper","navigator","storage","estimate","webkitTemporaryStorage","queryUsageAndQuota","usage","quota","NaN","persist","persistent","log","document","getElementById","innerHTML","isStoragePersisted","persisted","undefined","showEstimatedQuota","tryPersistWithoutPromtingUser","permissions","query","permission","name","status","Error","initStoragePersistence","settings","timestampsInSnapshots","enablePersistence","catch","err","dispatch","promise","setTimeout","code","message","updateUI","data","writeData","deferredPrompt","addEventListener","e","preventDefault","updateUI2","image","myInit","method","headers","mode","networkDataReceived","fetch","urlTree","response","json","furlf","dataArray","uio","key","dados1","eventHub","render","h","$mount","text","newText"],"mappings":"AAEC,UAASA,iBAAT,GAA6B;AAC5B;;AACA,MAAIC,EAAJ;AACA,MAAIC,aAAa,IAAIC,KAAJ,EAAjB;;AAEA,WAASC,YAAT,GAAwB;AACtB,WAAO,IAAIC,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AAC3C;AACA,UAAIC,SAAS,aAAb,CAF2C,CAEhB;;AAE3B,UAAIA,WAAW,IAAf,EAAqB;AACnB,YAAIC,UAAUC,OAAOC,SAAP,CAAiBC,IAAjB,CAAsBJ,MAAtB,CAAd;;AACAC,gBAAQI,SAAR,GAAoB,UAAUC,KAAV,EAAiB;AACnCb,eAAKa,MAAMC,MAAN,CAAaC,MAAlB;AACAV,kBAAQL,GAAGgB,gBAAX;AACD,SAHD;AAID;AAEF,KAZM,CAAP;AAaD;;AAED,WAASC,kBAAT,CAA4BC,SAA5B,EAAuC;AACrC,WAAO,IAAId,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AAC3C,UAAIa,QAAQnB,GAAGoB,WAAH,CAAeF,SAAf,EAA0BG,eAAeC,SAAzC,CAAZ;AACA,UAAIC,QAAQJ,MAAMK,WAAN,CAAkBN,SAAlB,CAAZ;AACA,UAAIO,QAAQ,EAAZ;;AACAN,YAAMO,UAAN,GAAmB,UAASC,GAAT,EAAc;AAC/B,YAAIC,UAAUC,OAAOJ,KAAP,CAAd;AACA,YAAIK,WAAW,CAACF,UAAU,IAAV,GAAiB,IAAlB,EAAwBG,OAAxB,CAAgC,CAAhC,CAAf;AACA9B,mBAAW+B,IAAX,CAAgB;AAAC,wBAAcd,SAAf;AAA0B,mBAASO,MAAMQ,MAAzC;AAAkD,kBAAQH,WAAW,MAAX,GAAoBF,OAApB,GAA8B;AAAxF,SAAhB;AACAvB;AACD,OALD;;AAMA,UAAI6B,gBAAgBX,MAAMY,UAAN,EAApB;;AACAD,oBAAcE,OAAd,GAAwB,UAASC,KAAT,EAAgB;AACtC/B,eAAO+B,KAAP;AACD,OAFD;;AAGAH,oBAActB,SAAd,GAA0B,UAASe,GAAT,EAAc;AACtC,YAAIW,SAASX,IAAIb,MAAJ,CAAWC,MAAxB;;AACA,YAAIuB,MAAJ,EAAY;AACRb,gBAAMO,IAAN,CAAWM,OAAOC,KAAlB;AACAD,iBAAOE,QAAP;AACH;AACF,OAND;AAOD,KArBM,CAAP;AAsBD;;AAED,WAASX,MAAT,CAAgBJ,KAAhB,EAAuB;AACrB,QAAIgB,OAAO,CAAX;;AACA,SAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAIjB,MAAMQ,MAA1B,EAAkCS,GAAlC,EAAuC;AACnC,UAAIC,aAAaC,KAAKC,SAAL,CAAepB,MAAMiB,CAAN,CAAf,EAAyBT,MAA1C;AACAQ,cAAQE,aAAa,CAArB;AACH;;AACD,WAAOF,IAAP;AACD;;AAEDtC,iBAAe2C,IAAf,CAAoB,UAASC,MAAT,EAAiB;AACnC,QAAIC,eAAe,EAAnB;;AACA,SAAK,IAAIN,IAAE,CAAX,EAAcA,IAAIK,OAAOd,MAAzB,EAAiCS,GAAjC,EAAsC;AACpCM,mBAAahB,IAAb,CAAkBf,mBAAmB8B,OAAOL,CAAP,CAAnB,CAAlB;AACD;;AACDtC,YAAQ6C,GAAR,CAAYD,YAAZ,EAA0BF,IAA1B,CAA+B,YAAW;AACvCI,cAAQC,KAAR,CAAclD,UAAd;AACF,KAFD;AAGD,GARD;AASD,CAhEA,GAAD;;AAmEA,OAAOmD,GAAP,MAAgB,KAAhB,C,CACA;AACA;;AAEA,OAAOC,GAAP,MAAgB,WAAhB;AACA,OAAOC,MAAP,MAAmB,UAAnB;AACA,SAAQ/B,KAAR,QAAoB,eAApB;AACA,OAAO,KAAKgC,MAAZ,MAAwB,uBAAxB;AACA,OAAOC,gBAAP,MAA6B,oBAA7B;AACA,OAAOC,aAAP,MAA0B,iBAA1B;AACA,OAAOC,IAAP,MAAiB,MAAjB;AACA,OAAOC,OAAP,MAAoB,SAApB;AACA,OAAO,4BAAP;AACA,OAAO,yBAAP;;AAEAC,QAAQ,6BAAR;;AACAA,QAAQ,2BAAR,E,CACA;;;AACAA,QAAQ,kCAAR;;AACAA,QAAQ,6BAAR,E,CACA;AACA;;;AACAR,IAAIS,GAAJ,CAAQF,OAAR;AACAP,IAAIS,GAAJ,CAAQH,IAAR;AACAN,IAAIS,GAAJ,CAAQJ,aAAR;AACAL,IAAIS,GAAJ,CAAQL;AAAkB;AAA1B;AACAJ,IAAIG,MAAJ,CAAWO,aAAX,GAA2B,KAA3B,C,CACA;;AACA,IAAIC,IAAIH,QAAQ,QAAR,CAAR;;AACA,IAAII,aAAaC,SAASC,aAAT,CAAuBX,OAAOY,cAA9B,CAAjB;AAEA,OAAO,MAAMC,YAAYH,SAASG,SAAT,EAAlB;;AACP,SAASC,sBAAT,GAAkC;AAChC,MAAI,aAAaC,SAAb,IAA0B,cAAcA,UAAUC,OAAtD,EAA+D;AAC7D;AACA,WAAOD,UAAUC,OAAV,CAAkBC,QAAlB,EAAP;AACD;;AAED,MAAI,4BAA4BF,SAA5B,IACA,wBAAwBA,UAAUG,sBADtC,EAC8D;AAC5D;AACA,WAAO,IAAIrE,OAAJ,CAAY,UAASC,OAAT,EAAkBC,MAAlB,EAA0B;AAC3CgE,gBAAUG,sBAAV,CAAiCC,kBAAjC,CACE,UAASC,KAAT,EAAgBC,KAAhB,EAAuB;AAACvE,gBAAQ;AAACsE,iBAAOA,KAAR;AAAeC,iBAAOA;AAAtB,SAAR;AAAsC,OADhE,EAEEtE,MAFF;AAID,KALM,CAAP;AAMD,GAf+B,CAiBhC;;;AACA,SAAOF,QAAQC,OAAR,CAAgB;AAACsE,WAAOE,GAAR;AAAaD,WAAOC;AAApB,GAAhB,CAAP;AACD,C,CACD;;;AACA,OAAO,yBAAP;AACA,IAAIP,UAAUC,OAAV,IAAqBD,UAAUC,OAAV,CAAkBO,OAA3C,EACER,UAAUC,OAAV,CAAkBO,OAAlB,GAA4BhC,IAA5B,CAAiC,UAASiC,UAAT,EAAqB;AACpD,MAAIA,UAAJ,EACE7B,QAAQ8B,GAAR,CAAY,4DAAZ,EADF,KAGE9B,QAAQ8B,GAAR,CAAY,0DAAZ;AACH,CALD;AAOF;;;;;AAKC,IAAI,aAAaV,SAAb,IAA0B,cAAcA,UAAUC,OAAtD,EAA+D;AAC5DD,YAAUC,OAAV,CAAkBC,QAAlB,GAA6B1B,IAA7B,CAAkC,UAAS/B,MAAT,EAAiB;AACpDmC,YAAQ8B,GAAR,CAAa,8BAAb;AACA9B,YAAQ8B,GAAR,CAAYjE,OAAO4D,KAAnB;AACAzB,YAAQ8B,GAAR,CAAYjE,OAAO6D,KAAnB;AACDK,aAASC,cAAT,CAAwB,SAAxB,EAAmCC,SAAnC,GACI,CAACpE,OAAO4D,KAAP,GAAe5D,OAAO6D,KAAvB,EAA8B7C,OAA9B,CAAsC,CAAtC,CADJ;AAEG,GAND;AAOD,CARF,MAQQ,IAAI,4BAA4BuC,SAA5B,IAAyC,wBAAwBA,UAAUG,sBAA/E,EAAuG;AAC5GH,YAAUG,sBAAV,CAAiCC,kBAAjC,CAAoD,UAASC,KAAT,EAAgBC,KAAhB,EAAuB;AAC5E1B,YAAQ8B,GAAR,CAAa,uDAAb;AACA9B,YAAQ8B,GAAR,CAAYL,KAAZ;AACAzB,YAAQ8B,GAAR,CAAYJ,KAAZ;AACDK,aAASC,cAAT,CAAwB,SAAxB,EAAmCC,SAAnC,GACI,CAACR,QAAQC,KAAT,EAAgB7C,OAAhB,CAAwB,CAAxB,CADJ;AAEG,GAND;AAOD,CARM,MAQA;AACRmB,UAAQ8B,GAAR,CAAa,MAAb;AACA9B,UAAQ8B,GAAR,CAAYH,GAAZ;AACA3B,UAAQ8B,GAAR,CAAYH,GAAZ;AACE;AACH;;;;;;;AAKA,eAAeO,kBAAf,GAAoC;AAClC,SAAO,OAAMd,UAAUC,OAAhB,KAA2BD,UAAUC,OAAV,CAAkBc,SAA7C,GACLf,UAAUC,OAAV,CAAkBc,SAAlB,EADK,GAELC,SAFF;AAGD;AAED;;;;;;AAIA,eAAeR,OAAf,GAAyB;AACvB,SAAO,OAAMR,UAAUC,OAAhB,KAA2BD,UAAUC,OAAV,CAAkBO,OAA7C,GACLR,UAAUC,OAAV,CAAkBO,OAAlB,EADK,GAELQ,SAFF;AAGD;AAED;;;;;;;AAKA,eAAeC,kBAAf,GAAoC;AAClC,SAAO,OAAMjB,UAAUC,OAAhB,KAA2BD,UAAUC,OAAV,CAAkBC,QAA7C,GACLF,UAAUC,OAAV,CAAkBC,QAAlB,EADK,GAELc,SAFF;AAGD;AAED;;;;;;;;;;AAQA,eAAeE,6BAAf,GAA+C;AAC7C,MAAI,CAAClB,UAAUC,OAAX,IAAsB,CAACD,UAAUC,OAAV,CAAkBc,SAA7C,EAAwD;AACtD,WAAO,OAAP;AACD;;AACD,MAAIA,YAAY,MAAMf,UAAUC,OAAV,CAAkBc,SAAlB,EAAtB;;AACA,MAAIA,SAAJ,EAAe;AACb,WAAO,WAAP;AACD;;AACD,MAAI,CAACf,UAAUmB,WAAX,IAA0B,CAACnB,UAAUmB,WAAV,CAAsBC,KAArD,EAA4D;AAC1D,WAAO,QAAP,CAD0D,CACzC;AAClB;;AACD,QAAMC,aAAa,MAAMrB,UAAUmB,WAAV,CAAsBC,KAAtB,CAA4B;AACnDE,UAAM;AAD6C,GAA5B,CAAzB;;AAGA,MAAID,WAAWE,MAAX,KAAsB,SAA1B,EAAqC;AACnCR,gBAAY,MAAMf,UAAUC,OAAV,CAAkBO,OAAlB,EAAlB;;AACA,QAAIO,SAAJ,EAAe;AACb,aAAO,WAAP;AACD,KAFD,MAEO;AACL,YAAM,IAAIS,KAAJ,CAAU,mBAAV,CAAN;AACD;AACF;;AACD,MAAIH,WAAWE,MAAX,KAAsB,QAA1B,EAAoC;AAClC,WAAO,QAAP;AACD;;AACD,SAAO,OAAP;AACD;;AACD,eAAeE,sBAAf,GAAwC;AACtC,QAAMjB,UAAU,MAAMU,+BAAtB;;AACA,UAAQV,OAAR;AACE,SAAK,OAAL;AACE5B,cAAQ8B,GAAR,CAAY,iCAAZ;AACA;;AACF,SAAK,WAAL;AACE9B,cAAQ8B,GAAR,CAAY,yCAAZ;AACA;;AACF,SAAK,QAAL;AACE9B,cAAQ8B,GAAR,CAAY,wDAAZ;AACA;AATJ;AAWD;;AACDe;AACA;;;;;AAKA;;;;;;;AAQA;;;;;;;;;;;;;;;;;;;;;;;;;;AA2BA;;;;;;;;;;;;;;;;;AAiBA;;;;;;;AAQA3B,UAAU4B,QAAV,CAAmB;AACfC,yBAAuB;AADR,CAAnB;AAGA7B,UAAU8B,iBAAV,GAA8BpD,IAA9B,CAAmC,YAAY;AACvCI,UAAQ8B,GAAR,CAAY,gBAAZ;AACH,CAFL,EAGKmB,KAHL,CAGW,UAAUC,GAAV,EAAe;AAClB7E,QAAM8E,QAAN,CAAe,SAAf,EAA0BD,GAA1B;AACH,CALL,E,CAMA;;AACA,IAAIE,UAAU,IAAIlG,OAAJ,CAAY,UAAUC,OAAV,EAAmBC,MAAnB,EAA2B;AACjDiG,aAAW,YAAY;AACnBlG,YAAQ,0CAAR;AACAC,WAAO;AACHkG,YAAM,GADH;AAEHC,eAAS;AAFN,KAAP,EAFmB,CAMnB;AACH,GAPD,EAOG,GAPH;AAQH,CATa,CAAd;;AAWA,IAAI,CAAChG,OAAOL,OAAZ,EAAqB;AACjBK,SAAOL,OAAP,GAAiBkG,OAAjB;AACH;;AAAA,C,CACD;;AACA,SAASI,QAAT,CAAkBC,IAAlB,EAAwB;AACpB,OAAK,IAAIjE,IAAI,CAAb,EAAgBA,IAAIiE,KAAK1E,MAAzB,EAAiCS,GAAjC,EAAsC;AAClCkE,cAAU,OAAV,EAAmBD,KAAKjE,CAAL,CAAnB,EADkC,CAElC;AACH;AACJ;;AAAA;AACD,IAAImE,cAAJ;AAEApG,OAAOqG,gBAAP,CAAwB,qBAAxB,EAAgDC,CAAD,IAAO;AACpD;AACAA,IAAEC,cAAF,GAFoD,CAGpD;;AACAH,mBAAiBE,CAAjB;AACD,CALD;;AAOA,SAASE,SAAT,CAAmBN,IAAnB,EAAyB;AACrB,OAAK,IAAIjE,IAAI,CAAb,EAAgBA,IAAIiE,KAAK1E,MAAzB,EAAiCS,GAAjC,EAAsC;AAClC,WAAOiE,KAAKjE,CAAL,EAAQwE,KAAf;AACAN,cAAU,OAAV,EAAmBD,KAAKjE,CAAL,CAAnB;AACH;AACJ;;AAAA,C,CACD;;AACA,IAAIyE,SAAS;AACTC,UAAQ,KADC;AAETC,WAAS;AACL,mCAA+B,KAD1B;AAEL,oBAAgB,kBAFX;AAGL,cAAU;AAHL,GAFA;AAOTC,QAAM;AAPG,CAAb,C,CASA;;AACA,IAAIC,sBAAsB,KAA1B;AACAC,MAAMjE,OAAOkE,OAAb,EACK3E,IADL,CACU,UAAU4E,QAAV,EAAoB;AACtBxE,UAAQC,KAAR,CAAcuE,QAAd;AACA,SAAOA,SAASC,IAAT,EAAP;AACH,CAJL,EAKK7E,IALL,CAKU,UAAU6D,IAAV,EAAgB;AAClBY,wBAAsB,IAAtB;AACA9G,SAAOmH,KAAP,GAAejB,IAAf,CAFkB,CAGlB;;AACAzD,UAAQ8B,GAAR,CAAY,oBAAZ,EAAkC2B,IAAlC;AACA,MAAIkB,YAAY,EAAhB;AACA,MAAIC,MAAM,EAAV;;AACA,OAAK,IAAIC,GAAT,IAAgBpB,IAAhB,EAAsB;AAClBkB,cAAU7F,IAAV,CAAe2E,KAAKoB,GAAL,CAAf;AACAD,QAAI9F,IAAJ,CAAS2E,KAAKoB,GAAL,CAAT,EAFkB,CAGlB;AACH;;AACDrB,WAASmB,SAAT,EAZkB,CAalB;;AACApH,SAAOuH,MAAP,GAAgBF,GAAhB,CAdkB,CAelB;;AACA,SAAOrH,OAAOuH,MAAP,EAAevH,OAAOmH,KAA7B;AACH,CAtBL,EAsBOzB,KAtBP,CAsBa,UAAUC,GAAV,EAAe;AACpBlD,UAAQ8B,GAAR,CAAYoB,GAAZ;AACH,CAxBL;AAyBA;;;;;;;;;;;;;;;;;;;;;;AAsBA,OAAO,MAAM6B,WAAW,IAAI7E,GAAJ,EAAjB;AACP,IAAIA,GAAJ,CAAQ;AACJE,QADI;AAEJ/B,OAFI;AAGJ2G,UAAQC,KAAKA,EAAE9E,GAAF;AAHT,CAAR,EAIG+E,MAJH,CAIU,MAJV;AAOA9B,QAAQxD,IAAR,CAAa,UAAUuF,IAAV,EAAgB;AACzB,SAAOA,IAAP;AACH,CAFD,EAEGvF,IAFH,CAEQ,UAAUwF,OAAV,EAAmB;AACvBpF,UAAQ8B,GAAR,CAAYsD,OAAZ;AACH,CAJD,EAIGnC,KAJH,CAIS,UAAUC,GAAV,EAAe;AACpBlD,UAAQ8B,GAAR,CAAYoB,IAAII,IAAhB,EAAsBJ,IAAIK,OAA1B;AACH,CAND,E,CASA","sourceRoot":"/Users/danielsecco/Downloads/quasela-master","sourcesContent":["\n\n(function showIndexedDbSize() {\n  \"use strict\";\n  var db;\n  var storesizes = new Array();\n \n  function openDatabase() {\n    return new Promise(function(resolve, reject) {\n      //prompt for DB name\n      var dbname = 'posts-store' //prompt('Please enter your Database Name', '');\n\n      if (dbname !== null) {\n        var request = window.indexedDB.open(dbname);\n        request.onsuccess = function (event) {\n          db = event.target.result;\n          resolve(db.objectStoreNames);\n        };\n      }\n      \n    });\n  }\n \n  function getObjectStoreData(storename) {\n    return new Promise(function(resolve, reject) {\n      var trans = db.transaction(storename, IDBTransaction.READ_ONLY);\n      var store = trans.objectStore(storename);\n      var items = [];\n      trans.oncomplete = function(evt) {\n        var szBytes = toSize(items);\n        var szMBytes = (szBytes / 1024 / 1024).toFixed(2);\n        storesizes.push({'Store Name': storename, 'Items': items.length,  'Size': szMBytes + 'MB (' + szBytes + ' bytes)'});\n        resolve();\n      };\n      var cursorRequest = store.openCursor();\n      cursorRequest.onerror = function(error) {\n        reject(error);\n      };\n      cursorRequest.onsuccess = function(evt) {                   \n        var cursor = evt.target.result;\n        if (cursor) {\n            items.push(cursor.value);\n            cursor.continue();\n        }\n      }\n    });\n  }\n \n  function toSize(items) {\n    var size = 0;\n    for (var i = 0; i < items.length; i++) {\n        var objectSize = JSON.stringify(items[i]).length;\n        size += objectSize * 2;\n    }\n    return size;\n  }\n \n  openDatabase().then(function(stores) {\n    var PromiseArray = [];\n    for (var i=0; i < stores.length; i++) {\n      PromiseArray.push(getObjectStoreData(stores[i]));    \n    }\n    Promise.all(PromiseArray).then(function() {\n       console.table(storesizes);\n    });\n  });\n}());\n\n\nimport Vue from 'vue'\n//import ElementUI from 'element-ui';\n//import 'element-ui/lib/theme-chalk/index.css';\n\nimport App from './App.vue'\nimport router from './router'\nimport {store} from './store/store'\nimport * as config from './assets/js/config.js'\nimport VueAwesomeSwiper from 'vue-awesome-swiper'\nimport VueMDCAdapter from 'vue-mdc-adapter';\nimport Vuex from 'vuex'\nimport VueFire from 'vuefire'\nimport 'swiper/dist/css/swiper.css'\nimport './registerServiceWorker'\n\nrequire('../public/src/js/promise.js')\nrequire('../public/src/js/fetch.js')\n//require('../public/src/js/idb.js')\nrequire('../public/src/js/material.min.js')\nrequire('../public/src/js/utility.js')\n//require('./index.js')\n//Vue.use(ElementUI);\nVue.use(VueFire)\nVue.use(Vuex)\nVue.use(VueMDCAdapter)\nVue.use(VueAwesomeSwiper, /* { default global options } */ )\nVue.config.productionTip = false\n// set firebase/firestore\nvar $ = require('jquery')\nvar defaultApp = firebase.initializeApp(config.configFirebase);\n \nexport const firestore = firebase.firestore()\nfunction storageEstimateWrapper() {\n  if ('storage' in navigator && 'estimate' in navigator.storage) {\n    // We've got the real thing! Return its response.\n    return navigator.storage.estimate();\n  }\n\n  if ('webkitTemporaryStorage' in navigator &&\n      'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {\n    // Return a promise-based wrapper that will follow the expected interface.\n    return new Promise(function(resolve, reject) {\n      navigator.webkitTemporaryStorage.queryUsageAndQuota(\n        function(usage, quota) {resolve({usage: usage, quota: quota})},\n        reject\n      );\n    });\n  }\n\n  // If we can't estimate the values, return a Promise that resolves with NaN.\n  return Promise.resolve({usage: NaN, quota: NaN});\n}\n//storageEstimateWrapper();\nimport './assets/js/pushnoty.js'\nif (navigator.storage && navigator.storage.persist)\n  navigator.storage.persist().then(function(persistent) {\n    if (persistent)\n      console.log(\"Storage will not be cleared except by explicit user action\");\n    else\n      console.log(\"Storage may be cleared by the UA under storage pressure.\");\n  });\n\n/*navigator.storage.estimate().then(function(estimate) {\n  document.getElementById(\"percent\").innerHTML =\n      (estimate.usage / estimate.quota).toFixed(2);\n});*/\n\n if ('storage' in navigator && 'estimate' in navigator.storage) {\n    navigator.storage.estimate().then(function(result) {\n   console.log( 'navigator.storage.estimate()');\n   console.log(result.usage);\n   console.log(result.quota);\n\t\tdocument.getElementById(\"percent\").innerHTML =\n      (result.usage / result.quota).toFixed(2);\n    });\n  } else if ('webkitTemporaryStorage' in navigator && 'queryUsageAndQuota' in navigator.webkitTemporaryStorage) {\n    navigator.webkitTemporaryStorage.queryUsageAndQuota(function(usage, quota) {\n   console.log( 'navigator.webkitTemporaryStorage.queryUsageAndQuota()');\n   console.log(usage);\n   console.log(quota);\n\t\tdocument.getElementById(\"percent\").innerHTML =\n      (usage / quota).toFixed(2);\n    });\n  } else {\n console.log( 'none');\n console.log(NaN);\n console.log(NaN);\n  }\n/** Check if storage is persisted already.\n  @returns {Promise<boolean>} Promise resolved with true if current origin is\n  using persistent storage, false if not, and undefined if the API is not\n  present.\n*/\nasync function isStoragePersisted() {\n  return await navigator.storage && navigator.storage.persisted ?\n    navigator.storage.persisted() :\n    undefined;\n}\n\n/** Tries to convert to persisted storage.\n  @returns {Promise<boolean>} Promise resolved with true if successfully\n  persisted the storage, false if not, and undefined if the API is not present.\n*/\nasync function persist() {\n  return await navigator.storage && navigator.storage.persist ?\n    navigator.storage.persist() :\n    undefined;\n}\n\n/** Queries available disk quota.\n  @see https://developer.mozilla.org/en-US/docs/Web/API/StorageEstimate\n  @returns {Promise<{quota: number, usage: number}>} Promise resolved with\n  {quota: number, usage: number} or undefined.\n*/\nasync function showEstimatedQuota() {\n  return await navigator.storage && navigator.storage.estimate ?\n    navigator.storage.estimate() :\n    undefined;\n}\n\n/** Tries to persist storage without ever prompting user.\n  @returns {Promise<string>}\n    \"never\" In case persisting is not ever possible. Caller don't bother\n      asking user for permission.\n    \"prompt\" In case persisting would be possible if prompting user first.\n    \"persisted\" In case this call successfully silently persisted the storage,\n      or if it was already persisted.\n*/\nasync function tryPersistWithoutPromtingUser() {\n  if (!navigator.storage || !navigator.storage.persisted) {\n    return \"never\";\n  }\n  let persisted = await navigator.storage.persisted();\n  if (persisted) {\n    return \"persisted\";\n  }\n  if (!navigator.permissions || !navigator.permissions.query) {\n    return \"prompt\"; // It MAY be successful to prompt. Don't know.\n  }\n  const permission = await navigator.permissions.query({\n    name: \"persistent-storage\"\n  });\n  if (permission.status === \"granted\") {\n    persisted = await navigator.storage.persist();\n    if (persisted) {\n      return \"persisted\";\n    } else {\n      throw new Error(\"Failed to persist\");\n    }\n  }\n  if (permission.status === \"prompt\") {\n    return \"prompt\";\n  }\n  return \"never\";\n}\nasync function initStoragePersistence() {\n  const persist = await tryPersistWithoutPromtingUser();\n  switch (persist) {\n    case \"never\":\n      console.log(\"Not possible to persist storage\");\n      break;\n    case \"persisted\":\n      console.log(\"Successfully persisted storage silently\");\n      break;\n    case \"prompt\":\n      console.log(\"Not persisted, but we may prompt user when we want to.\");\n      break;\n  }\n}\ninitStoragePersistence();\n/*navigator.webkitPersistentStorage().then(function(estimate) {\n  document.getElementById(\"percent\").innerHTML =\n      (estimate.usage / estimate.quota).toFixed(2);\n});*/\n\n/*let geo = new GeolocationSensor({ frequency: 1 });\ngeo.start();\n\ngeo.onreading = () => console.log(`lat: ${geo.latitude}, long: ${geo.longitude}`);\n\ngeo.onerror = event => console.error(event.error.name, event.error.message);*/\n\n\n/*(function(globalObject) {\n  'use strict';\n  if (!('navigator' in globalObject) || !('location' in globalObject))\n    return;\n  \n  // [SecureContext]\n  if (globalObject.location.protocol !== 'https:')\n    return;\n  \n  if (!('storage' in globalObject.navigator))\n    globalObject.navigator.storage = {};\n  \n  var storage = globalObject.navigator.storage;\n  \n  // Promise<boolean> persisted();\n  storage.persisted = storage.persisted || function() {\n    return Promise.resolve(false);\n  };\n  \n  // [Exposed=Window] Promise<boolean> persist();\n  if ('window' in globalObject && globalObject.window === window) {\n    storage.persist = storage.persist || function() {\n      return Promise.resolve(false);\n    }; \n  }*/\n  \n  \n/*\n\nvar storageInfo = null;\n\nif(navigator.webkitTemporaryStorage) {\n  storageInfo = navigator.webkitTemporaryStorage;\n\tconsole.log('persistence ok')\n\tconsole.log(storageInfo);\n} else if(navigator.webkitPersistentStorage) {\n  storageInfo = navigator.webkitPersistentStorage;\n\tconsole.log(storageInfo);\n} else if (window.webkitStorageInfo) {\n  storageInfo = window.webkitStorageInfo;\n\tconsole.log(storageInfo);\n}\n*/\n\n/*navigator.webkitTemporaryStorage.queryUsageAndQuota ( \n    function(usedBytes, grantedBytes) {  \n        console.log('we are using ', usedBytes, ' of ', grantedBytes, 'bytes');\n    }, \n    function(e) { console.log('Error', e);  }\n);*/\n\n\nfirestore.settings({\n    timestampsInSnapshots: true\n});\nfirestore.enablePersistence().then(function () {\n        console.log('persistence ok')\n    })\n    .catch(function (err) {\n        store.dispatch('setErro', err)\n    });\n//////////////// promise\nvar promise = new Promise(function (resolve, reject) {\n    setTimeout(function () {\n        resolve('This is executed once the timer is done!');\n        reject({\n            code: 500,\n            message: 'An error occurred!'\n        });\n        //console.log('This is executed once the timer is done!');\n    }, 100);\n});\n\nif (!window.Promise) {\n    window.Promise = promise;\n};\n///////////////////////interface\nfunction updateUI(data) {\n    for (var i = 0; i < data.length; i++) {\n        writeData('trees', data[i]);\n        //console.log(data);\n    }\n};\nlet deferredPrompt;\n\nwindow.addEventListener('beforeinstallprompt', (e) => {\n  // Prevent Chrome 67 and earlier from automatically showing the prompt\n  e.preventDefault();\n  // Stash the event so it can be triggered later.\n  deferredPrompt = e;\n});\n\nfunction updateUI2(data) {\n    for (var i = 0; i < data.length; i++) {\n        delete data[i].image;\n        writeData('posts', data[i]);\n    }\n};\n// header fetch(url,{myInit})\nvar myInit = {\n    method: 'GET',\n    headers: {\n        'Access-Control-Allow-Origin': '*/*',\n        'Content-Type': 'application/json',\n        'Accept': 'application/json',\n    },\n    mode: 'cors'\n};\n//////\nvar networkDataReceived = false;\nfetch(config.urlTree)\n    .then(function (response) {\n        console.table(response);\n        return response.json();\n    })\n    .then(function (data) {\n        networkDataReceived = true;\n        window.furlf = data;\n        // console.log(data.foto + '<???>' + jhg);\n        console.log('From web FETCH 1 >', data);\n        var dataArray = [];\n        var uio = [];\n        for (var key in data) {\n            dataArray.push(data[key]);\n            uio.push(data[key]);\n            // writeData('trees', data[key]);\n        }\n        updateUI(dataArray);\n        //window.ltt = uio[0];\n        window.dados1 = uio;\n        // console.log(uio.length + '<???>' + jhg);\n        return window.dados1, window.furlf;\n    }).catch(function (err) {\n        console.log(err);\n    });\n/*networkDataReceived = false;\nfetch(config.url2)\n    .then(function (res) {\n        console.log(res);\n        return res.json();\n    })\n    .then(function (data) {\n        networkDataReceived = true;\n        // console.log(data.foto + '<???>' + jhg);\n        console.log('From web FETCH post fire >', data);\n        var dataArray = [];\n        $(\"#imgf\").text('');\n        for (var key in data) {\n            dataArray.push(data[key]);\n            $(\"#imgf\").append(\"<p> \" + data[key].data + '----' + data[key].id + '-->' + data[key].hora + \"</p><br> \");\n        }\n        updateUI2(dataArray);\n        // console.log(uio.length + '<???>' + jhg);\n    }).catch(function (err) {\n        console.log(err);\n    });*/\n\nexport const eventHub = new Vue();\nnew Vue({\n    router,\n    store,\n    render: h => h(App)\n}).$mount('#app');\n\n\npromise.then(function (text) {\n    return text;\n}).then(function (newText) {\n    console.log(newText);\n}).catch(function (err) {\n    console.log(err.code, err.message);\n});\n\n\n////// push\n"]}]}